var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [JosephsonCircuits]","category":"page"},{"location":"reference/#JosephsonCircuits.CircuitGraph","page":"Reference","title":"JosephsonCircuits.CircuitGraph","text":"CircuitGraph(edge2indexdict, Rbn, searray, cearray, glearray, lvarray,\n    isolatednodes, gl, Nbranches)\n\nA simple structure to hold the circuit graph information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.CircuitMatrices","page":"Reference","title":"JosephsonCircuits.CircuitMatrices","text":"CircuitMatrices(Cnm::SparseMatrixCSC, Gnm::SparseMatrixCSC, Lb::SparseVector\n    Lbm::SparseVector, Ljb::SparseVector, Ljbm::SparseVector,\n    Mb::SparseMatrixCSC, invLnm::SparseMatrixCSC,\n    Rbnm::SparseMatrixCSC{Int, Int}, portindices::Vector{Int},\n    portnumbers::Vector{Int}, portimpedanceindices::Vector{Int}\n    noiseportimpedanceindices::Vector{Int}, Lmean, vvn)\n\nA simple structure to hold the circuit matrices including the capacitance matrix, the conductance matrix, the inductance vectors, the Josephson inductance vectors, the mutual inductance matrix, the inverse inductance matrix, the incidence matrix, the dictionary of port and resistor values where the nodes are the keys and the values are the values, and the mean of the inductances. See also numericmatrices and symbolicmatrices.\n\nFields\n\nCnm::SparseMatrixCSC: the capacitance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.\nGnm::SparseMatrixCSC: the conductance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.\nLb::SparseVector: vector of branch linear inductances.\nLbm::SparseVector: vector of branch linear inductances with each element   duplicated Nmodes times.\nLjb::SparseVector: vector of branch Josephson junction inductances.\nLjbm::SparseVector: vector of branch Josephson junction inductances with   each element duplicated Nmodes times.\nMb::SparseMatrixCSC: the mutual inductance matrix in the branch basis with   each element duplicated along the diagonal Nmodes times.\ninvLnm::SparseMatrixCSC: the inverse inductance matrix in the node basis   with each element duplicated along the diagonal Nmodes times.\nRbnm::SparseMatrixCSC{Int, Int}: incidence matrix to convert between the   node and branch bases.\nportindices::Vector{Int}: vector of indices at which ports occur.\nportnumbers::Vector{Int}: vector of port numbers.\nportimpedanceindices::Vector{Int}: vector of indices at which port   impedances occur.\nnoiseportimpedanceindices::Vector{Int}: vector of indices at which   resistive elements other than port impedances occur, for noise   calculations.\nLmean: the mean of all of the geometric and Josephson inductances.\nvvn: the vector of component values with numbers substituted in.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.FactorizationCache","page":"Reference","title":"JosephsonCircuits.FactorizationCache","text":"FactorizationCache(factorization)\n\nA cache for the factorization object.\n\nExamples\n\njulia> JosephsonCircuits.FactorizationCache(JosephsonCircuits.KLU.klu(JosephsonCircuits.sparse([1, 2], [1, 2], [1/2, 1/2], 2, 2)));\n\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.FourierIndices","page":"Reference","title":"JosephsonCircuits.FourierIndices","text":"FourierIndices(conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}},\n    vectomatmap::Vector{Int}, conjsourceindices::Vector{Int},\n    conjtargetindices::Vector{Int}, hbmatmodes::Matrix{NTuple{N, Int}},\n    hbmatindices::Matrix{Int})\n\nA simple structure to hold time and frequency domain information for the signals, particularly the indices for converting between the node flux vectors and matrices. See also fourierindices.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.Frequencies","page":"Reference","title":"JosephsonCircuits.Frequencies","text":"Frequencies(Nharmonics::NTuple{N, Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int},\n    coords::Vector{CartesianIndex{N}}, modes::Vector{NTuple{N,Int})\n\nA simple structure to hold time and frequency domain information for the signals. See also calcfreqsrdft and calcfreqsdft.\n\nFields\n\nNharmonics::NTuple{N, Int}: The number of harmonics for each frequency.\nNw::NTuple{N,Int}: The dimensions of the frequency domain signal for a   single node.\nNt::NTuple{N,Int}: The dimensions of the time domain signal for a single   node.\ncoords::Vector{CartesianIndex{N}}: The coordinates of each mixing products.\nmodes::Vector{NTuple{N,Int}}: The mode indices of each mixing product, eg.    (0,0), (1,0), (2,1).\n\nExamples\n\nNharmonics = (2,1)\nNw = (3, 3)\nNt = (4, 3)\ncoords = CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)]\nmodes = [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)]\nJosephsonCircuits.Frequencies(Nharmonics, Nw,Nt,coords,modes)\n\n# output\nJosephsonCircuits.Frequencies{2}((2, 1), (3, 3), (4, 3), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)])\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.HB","page":"Reference","title":"JosephsonCircuits.HB","text":"HB(nonlinear, linearized)\n\nA simple structure to hold the nonlinear and linearized harmonic balance solutions.\n\nFields\n\nnonlinear: nonlinear harmonic balance solution for pump and pump   harmonics. See NonlinearHB.\nlinearized: linearized harmonic balance solution.   See LinearizedHB.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.LinearizedHB","page":"Reference","title":"JosephsonCircuits.LinearizedHB","text":"LinearizedHB(S, Snoise, QE, QEideal, CM, nodeflux, voltage, Nmodes, Nnodes,\n    Nbranches, signalindex, w)\n\nA simple structure to hold the linearized harmonic balance solutions.\n\nFields\n\nw: the signal frequencies.\nmodes: tuple of the signal mode indices where (0,) is the signal.\nS: the scattering matrix relating inputs and outputs for each combination   of port and frequency.\nSnoise: the scattering matrix relating inputs at the noise ports.   (lossy devices) and outputs at the physical ports for each combination of   port and frequency.\nSsensitivity:\nZ:\nZadjoint: \nZsensitivity: \nZsensitivityadjoint: \nQE: the quantum efficiency for each combination of port and frequency.\nQEideal: the quantum efficiency for an ideal amplifier with the same level   of gain, for each combination of port and frequency.\nCM: the commutation relations (equal to ±1), for each combination of port   and frequency.\nnodeflux: the node fluxes resulting from inputs at each frequency and port.\nnodefluxadjoint: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.\nvoltage: the node voltages resulting from inputs at each frequency and port.\nvoltageadjoint: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.\nnodenames: the vector of unique node strings.\nnodeindices:\ncomponentnames:\ncomponenttypes:\ncomponentnamedict:\nmutualinductorbranchnames:\nportnumbers: vector of port numbers.\nportindices:\nportimpedanceindices:\nnoiseportimpedanceindices:\nsensitivitynames:\nsensitivityindices:\nNmodes: the number of signal and idler frequencies.\nNnodes: the number of nodes in the circuit (including the ground node).\nNbranches: the number of branches in the circuit.\nNports: the number of ports.\nsignalindex: the index of the signal mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.NonlinearHB","page":"Reference","title":"JosephsonCircuits.NonlinearHB","text":"NonlinearHB(nodeflux, Rbnm, Ljb, Lb, Ljbm, Nmodes, Nbranches, S)\n\nA simple structure to hold the nonlinear harmonic balance solutions.\n\nFields\n\nw: a tuple containing the the angular frequency of the pump in radians/s.\nfrequencies:\nnodeflux: the node fluxes resulting from inputs at each frequency and   port.\nRbnm: incidence matrix to convert between the node and branch basis.\nLjb: sparse vector of Josephson junction inductances.\nLb: sparse vector of linear inductances.\nLjbm: sparse vector of linear inductances with each element duplicated   Nmodes times.\nNmodes: the number of signal and idler frequencies.\nNbranches: the number of branches in the circuit.\nnodenames: the vector of unique node name strings.\ncomponentnames: the vector of component name strings\nportnumbers: vector of port numbers.\nportindices: \nmodes: tuple of the pump mode indices where (1,) is the pump in the single   pump case.\nS: the scattering matrix relating inputs and outputs for each combination   of port and frequency.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.ParsedCircuit","page":"Reference","title":"JosephsonCircuits.ParsedCircuit","text":"ParsedCircuit(nodeindexvector::Vector{Int},\n    uniquenodevector::Vector{String},\n    mutualinductorbranchnames::Vector{String},\n    componentnames::Vector{String}, componenttypes::Vector{Symbol},\n    componentvalues::Vector, componentnamedict::Dict{String, Int},\n    Nnodes::Int)\n\nA simple structure to hold the parsed circuit including a vector of node indices, the unique node names, the inductors coupled by the mutual inductors, the component names, the component types, the values of the components, a dictionary of the names of the components as keys and the index at which the component occurs as the value, and dictionaries for the ports and resistors where the pair of nodes is the key and value is the component value.\n\nSee also parsecircuit.\n\nFields\n\nnodeindexvector::Vector{Int}: sorted vector of node indices where the   two nodes for each component occur as consecutive elements (pairs).\nuniquenodevector::Vector{String}: the unique node names.\nmutualinductorbranchnames::Vector{String}: the inductors coupled by the   mutual inductors.\ncomponentnames::Vector{String}: component names.\ncomponenttypes::Vector{Symbol}: the component (electrical engineering)   types.\ncomponentvalues::Vector: the component values.\ncomponentnamedict::Dict{String, Int}: names of the components as keys and   the index at which the component occurs as the value.\nNnodes::Int: number of nodes including the ground node.\n\nExamples\n\n@variables Ipump Rleft L1 K1 L2 C2\nprintln(JosephsonCircuits.ParsedCircuit(\n    [1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],\n    [\"1\", \"0\", \"2\"], [\"L1\", \"L2\"],\n    [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"],\n    [:P, :I, :R, :L, :K, :L, :C],\n    Num[1, Ipump, Rleft, L1, K1, L2, C2],\n    Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5),\n    3))\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.ParsedSortedCircuit","page":"Reference","title":"JosephsonCircuits.ParsedSortedCircuit","text":"ParsedSortedCircuit(nodeindices::Matrix{Int},\n    nodenames::Vector{String},\n    mutualinductorbranchnames::Vector{String},\n    componentnames::Vector{String},\n    componenttypes::Vector{Symbol}, componentvalues::Vector,\n    componentnamedict::Dict{String, Int}, Nnodes::Int)\n\nA simple structure to hold the parsed and sorted circuit. See also parsesortcircuit, parsecircuit, and sortnodes for more explanation.\n\nFields\n\nnodeindices::Matrix{Int}: sorted array of node indices (where the length   of the first axis is 2).\nnodenames::Vector{String}: the sorted unique node names.\nmutualinductorbranchnames::Vector{String}: the inductors coupled by the   mutual inductors.\ncomponentnames::Vector{String}: component names.\ncomponenttypes::Vector{Symbol}: the component (electrical engineering) types.\ncomponentvalues::Vector: the component values.\ncomponentnamedict::Dict{String, Int}: names of the components as keys and   the index at which the component occurs as the value.\nNnodes::Int: number of nodes including the ground node.\n\nExamples\n\n@variables Ipump Rleft L1 K1 L2 C2\nprintln(JosephsonCircuits.ParsedSortedCircuit(\n    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],\n    [\"0\", \"1\", \"2\"],\n    [\"L1\", \"L2\"],\n    [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"],\n    [:P, :I, :R, :L, :K, :L, :C],\n    Num[1, Ipump, Rleft, L1, K1, L2, C2],\n    Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5),\n    3))\n\n# output\nJosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [\"0\", \"1\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.SpiceRaw","page":"Reference","title":"JosephsonCircuits.SpiceRaw","text":"SpiceRaw(header::SpiceRawHeader, variables::Dict{String, Vector{String}},\n    values::Dict{String,T})\n\nA simple structure to hold the SPICE raw file contents including the header, variables, and values.\n\nExamples\n\njulia> JosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(\"CKT1\", \"Thu Dec 29 01:29:27 2022\", \"A.C. Small signal analysis\", \"complex\", 4, 3, \"version 4.3.14\", \"\"), Dict(\"V\" => [\"v(1)\", \"v(2)\", \"v(3)\"], \"Hz\" => [\"frequency\"]), Dict{String, Matrix{ComplexF64}}(\"V\" => [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], \"Hz\" => [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))\nJosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(\"CKT1\", \"Thu Dec 29 01:29:27 2022\", \"A.C. Small signal analysis\", \"complex\", 4, 3, \"version 4.3.14\", \"\"), Dict(\"V\" => [\"v(1)\", \"v(2)\", \"v(3)\"], \"Hz\" => [\"frequency\"]), Dict{String, Matrix{ComplexF64}}(\"V\" => [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], \"Hz\" => [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.SpiceRawHeader","page":"Reference","title":"JosephsonCircuits.SpiceRawHeader","text":"SpiceRawHeader(title::String, date::String, plotname::String,\n    flags::String, nvariables::Int, npoints::Int, command::String,\n    option::String)\n\nA simple structure to hold the SPICE raw file header.\n\nExamples\n\njulia> JosephsonCircuits.SpiceRawHeader(\"CKT1\", \"Thu Dec 29 01:29:27 2022\", \"A.C. Small signal analysis\", \"complex\", 4, 3, \"version 4.3.14\", \"\")\nJosephsonCircuits.SpiceRawHeader(\"CKT1\", \"Thu Dec 29 01:29:27 2022\", \"A.C. Small signal analysis\", \"complex\", 4, 3, \"version 4.3.14\", \"\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.TouchstoneFile","page":"Reference","title":"JosephsonCircuits.TouchstoneFile","text":"TouchstoneFile(f::Vector{Float64},\n    N::Array{Complex{Float64}},\n    frequencyunit::String,\n    parameter::String,\n    format::String,\n    R::Float64,\n    version::Float64,\n    numberofports::Int,\n    twoportdataorder::String,\n    numberoffrequencies::Int,\n    numberofnoisefrequencies::Int,\n    reference::Vector{Float64},\n    information::Vector{String},\n    matrixformat::String,\n    mixedmodeorder::Vector{Tuple{Char, Vector{Int}}},\n    comments::Vector{String},\n    networkdata::Vector{Float64},\n    noisedata::Vector{Float64})\n\nA structure to hold the data contained in a Touchstone file. In most cases, the user will not generate the struct directly. Instead, they will load a Touchstone file with touchstone_load, parse an IOStream or IOBuffer with touchstone_parse, or generate a TouchstoneFile struct with touchstone_file.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JosephsonCircuits.CMtokeyed-NTuple{4, Any}","page":"Reference","title":"JosephsonCircuits.CMtokeyed","text":"CMtokeyed(CM, outputmodes, outputportnumbers, w)\n\nConvert a commutation relation array CM vs frequency w to a keyed array. Return the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.CMtokeyed([1 2;3 4;;;],[(0,)],[1,2],[1.0,1.1])\n3-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   outputmode ∈ 1-element Vector{Tuple{Int64}}\n→   outputport ∈ 2-element Vector{Int64}\n◪   freqindex ∈ 2-element UnitRange{Int64}\nAnd data, 1×2×2 Array{Int64, 3}:\n[:, :, 1] ~ (:, :, 1):\n          (1)  (2)\n   (0,)     1    3\n\n[:, :, 2] ~ (:, :, 2):\n          (1)  (2)\n   (0,)     2    4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.IctoLj-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.IctoLj","text":"IctoLj(Ic)\n\nConvert the junction critical current to inductance in SI base units. \n\nExamples\n\njulia> IctoLj(3.29105976e-6)\n1.0e-10\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.LjtoIc-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.LjtoIc","text":"LjtoIc(Lj)\n\nConvert the junction inductance to critical current in SI base units. \n\nExamples\n\njulia> LjtoIc(100e-12)\n3.29105976e-6\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.Snoisetokeyed-NTuple{6, Any}","page":"Reference","title":"JosephsonCircuits.Snoisetokeyed","text":"Snoisetokeyed(Snoise, inputmodes, components, outputmodes,\n    outputportnumbers, w)\n\nConvert a noise scattering parameter array Snoise vs frequency w to a keyed array. Return the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.Snoisetokeyed([11 12;21 22;;;],[(0,)],[\"C1\",\"C2\"],[(0,)],[1,2],[1.0])\n5-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   inputmode ∈ 1-element Vector{Tuple{Int64}}\n→   component ∈ 2-element Vector{String}\n◪   outputmode ∈ 1-element Vector{Tuple{Int64}}\n▨   outputport ∈ 2-element Vector{Int64}\n▨   freqindex ∈ 1-element UnitRange{Int64}\nAnd data, 1×2×1×2×1 Array{Int64, 5}:\n[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):\n          (\"C1\")  (\"C2\")\n   (0,)   11      21\n\n[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):\n          (\"C1\")  (\"C2\")\n   (0,)   12      22\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.StoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}","page":"Reference","title":"JosephsonCircuits.StoY!","text":"StoY!(Y::AbstractMatrix,S::AbstractMatrix,tmp::AbstractMatrix,sqrtportadmittances)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.StoY-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.StoY","text":"StoY(S;portimpedances=50.0)\n\nConvert the scattering parameter matrix S to an admittance parameter matrix Y and return the result. \n\nY=sqrty(I_N-S)(I_N+S)^-1sqrty =sqrt y(I_N+S)^-1(I_N-S)sqrt y\n\nExamples\n\njulia> S = [0.0 0.0;0.0 0.0];JosephsonCircuits.StoY(S)\n2×2 Matrix{Float64}:\n  0.02  -0.0\n -0.0    0.02\n\njulia> S = [0.0 0.999;0.999 0.0];JosephsonCircuits.StoY(S)\n2×2 Matrix{Float64}:\n  19.99  -19.99\n -19.99   19.99\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.StoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}","page":"Reference","title":"JosephsonCircuits.StoZ!","text":"StoZ!(Z::AbstractMatrix,S::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.StoZ-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.StoZ","text":"StoZ(S;portimpedances=50.0)\n\nConvert the scattering parameter matrix S to an impedance parameter matrix Z and return the result. \n\nZ=sqrtz(1_N-S)^-1(1_N+S)sqrtz\n\nsqrtz^-1Z=(1_N-S)^-1(1_N+S)sqrtz\n\nsqrtz^-1Z=(1_N-S) div (1_N+S)sqrtz\n\nZ= sqrtz((1_N-S) div (1_N+S)sqrtz)\n\nExamples\n\njulia> S = [0.0 0.0;0.0 0.0];JosephsonCircuits.StoZ(S)\n2×2 Matrix{Float64}:\n 50.0   0.0\n  0.0  50.0\n\njulia> S = [0.0 0.999;0.999 0.0];JosephsonCircuits.StoZ(S)\n2×2 Matrix{Float64}:\n 49975.0  49975.0\n 49975.0  49975.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.Stokeyed-NTuple{5, Any}","page":"Reference","title":"JosephsonCircuits.Stokeyed","text":"Stokeyed(S, outputmodes, outputportnumbers, inputmodes, inputportnumbers)\n\nConvert a scattering parameter array S to a keyed array. Returned the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.Stokeyed([11 12;21 22],[(0,)],[1,2],[(0,)],[1,2])\n4-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   outputmode ∈ 1-element Vector{Tuple{Int64}}\n→   outputport ∈ 2-element Vector{Int64}\n◪   inputmode ∈ 1-element Vector{Tuple{Int64}}\n▨   inputport ∈ 2-element Vector{Int64}\nAnd data, 1×2×1×2 Array{Int64, 4}:\n[:, :, 1, 1] ~ (:, :, (0,), 1):\n          (1)  (2)\n   (0,)    11   21\n\n[:, :, 1, 2] ~ (:, :, (0,), 2):\n          (1)  (2)\n   (0,)    12   22\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.Stokeyed-NTuple{6, Any}","page":"Reference","title":"JosephsonCircuits.Stokeyed","text":"Stokeyed(S, outputmodes, outputportnumbers, inputmodes, \n    inputportnumbers, w)\n\nConvert a scattering parameter array S vs frequency w to a keyed array. Returned the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.Stokeyed([11 12;21 22;;;],[(0,)],[1,2],[(0,)],[1,2],[1.0])\n5-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   outputmode ∈ 1-element Vector{Tuple{Int64}}\n→   outputport ∈ 2-element Vector{Int64}\n◪   inputmode ∈ 1-element Vector{Tuple{Int64}}\n▨   inputport ∈ 2-element Vector{Int64}\n▨   freqindex ∈ 1-element UnitRange{Int64}\nAnd data, 1×2×1×2×1 Array{Int64, 5}:\n[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):\n          (1)  (2)\n   (0,)    11   21\n\n[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):\n          (1)  (2)\n   (0,)    12   22\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.YtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}","page":"Reference","title":"JosephsonCircuits.YtoS!","text":"YtoS!(S::AbstractMatrix,Y::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.YtoS-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.YtoS","text":"YtoS(Y;portimpedances=50.0)\n\nConvert the admittance parameter matrix Y to a scattering parameter matrix S and return the result. portimpedances is a scalar, vector, or matrix of port impedances.\n\nS=(I_N-sqrt zYsqrt z)(I_N+sqrt zYsqrt z)^-1 =(I_N+sqrt zYsqrt z)^-1(I_N-sqrt zYsqrtz\n\nwhere `sqrty=(sqrtz)^-1 where z is a diagonal matrix of port impedances. \n\nFirst compute ildeY = sqrtzYsqrtz, then:\n\nS =(1_N+tildeY) div (1_N-tildeY)\n\nExamples\n\njulia> Y = [1/50.0 0.0;0.0 1/50.0];JosephsonCircuits.YtoS(Y)\n2×2 Matrix{Float64}:\n  0.0  -0.0\n -0.0   0.0\n\njulia> Y = [0.0 0.0;0.0 0.0];JosephsonCircuits.YtoS(Y)\n2×2 Matrix{Float64}:\n  1.0  -0.0\n -0.0   1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.ZtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}","page":"Reference","title":"JosephsonCircuits.ZtoS!","text":"ZtoS!(S::AbstractMatrix,Z::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.ZtoS-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.ZtoS","text":"ZtoS(Z;portimpedances=50.0)\n\nConvert the impedance parameter matrix Z to a scattering parameter matrix S and return the result. portimpedances is a scalar, vector, or matrix of port impedances.\n\nS=(sqrtyZsqrty-1_N)(sqrtyZsqrty+1_N)^-1 S =(sqrtyZsqrty+1_N)^-1(sqrtyZsqrty-1_N) S =(sqrtyZsqrty+1_N) div (sqrtyZsqrty-1_N)\n\nwhere `sqrty=(sqrtz)^-1 where z is a diagonal matrix of port impedances. \n\nFirst compute ildeZ = sqrtyZsqrty, then:\n\nS =(tildeZ+1_N) div (tildeZ-1_N)\n\nExamples\n\njulia> Z = [50.0 0.0;0.0 50.0];JosephsonCircuits.ZtoS(Z)\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\njulia> Z = [0.0 0.0;0.0 0.0];JosephsonCircuits.ZtoS(Z)\n2×2 Matrix{Float64}:\n -1.0   0.0\n  0.0  -1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.addsources!-NTuple{11, Any}","page":"Reference","title":"JosephsonCircuits.addsources!","text":"addsources!(bbm, modes, sources, portindices, portnumbers,\n    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)\n\nCalculate the source terms in the branch basis. Overwrite bbm with the output. See also calcsources.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T","page":"Reference","title":"JosephsonCircuits.applynl!","text":"applynl!(fd::Array{Complex{T}}, td::Array{T}, f::Function, irfftplan,\n    rfftplan)\n\nApply the nonlinear function f to the frequency domain data by transforming to the time domain, applying the function, then transforming back to the frequency domain, overwriting the contents of fd and td in the process. We use plans for the forward and reverse RFFT prepared by plan_applynl.\n\nExamples\n\nfd=ones(Complex{Float64},3,2)\ntd, irfftplan, rfftplan = JosephsonCircuits.plan_applynl(fd)\nJosephsonCircuits.applynl!(fd, td, cos, irfftplan, rfftplan)\nfd\n\n# output\n3×2 Matrix{ComplexF64}:\n  0.586589+0.0im   0.586589+0.0im\n -0.413411+0.0im  -0.413411+0.0im\n -0.413411+0.0im  -0.413411+0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.applynl-Tuple{Array{ComplexF64}, Any}","page":"Reference","title":"JosephsonCircuits.applynl","text":"applynl(am::Array{Complex{Float64}}, f::Function)\n\nPerform the inverse discrete Fourier transform on an array am of complex frequency domain data, apply the function f in the time domain, then perform the discrete Fourier transform to return to the frequency domain. Apply the Fourier transform on all but the last dimensions. See also applynl! and plan_applynl.\n\nExamples\n\njulia> JosephsonCircuits.applynl([[0, 0.2+0.0im, 0, 0];;],cos)\n4×1 Matrix{ComplexF64}:\n   0.9603980498951228 + 0.0im\n                  0.0 + 0.0im\n -0.01966852794611884 + 0.0im\n                  0.0 + 0.0im\n\njulia> JosephsonCircuits.applynl([[0, 0.2+0.0im];;],cos)\n2×1 Matrix{ComplexF64}:\n   0.9603980498951228 + 0.0im\n -0.01966852794611884 + 0.0im\n\njulia> JosephsonCircuits.applynl([0.0 + 0.0im 0.45 + 0.0im 0.45 + 0.0im; 0.55 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;],sin)\n3×3×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n -0.0209812+0.0im   0.295151+0.0im   0.295151+0.0im\n   0.359826+0.0im  -0.041417+0.0im  -0.041417+0.0im\n 0.00788681+0.0im  -0.110947+0.0im  -0.110947+0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.arraytonetworkdata-NTuple{11, Any}","page":"Reference","title":"JosephsonCircuits.arraytonetworkdata","text":"arraytonetworkdata(frequencies,N, numberofports, numberoffrequencies,\n    matrixformat, twoportdataorder, parameter, frequencyunit, format, R,\n    version)\n\nExamples\n\nfrequencies = 4.0e9:5.0e8:6.0e9\nN = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]\nnumberofports = 1\nnumberoffrequencies = 5\nmatrixformat = \"Full\"\ntwoportdataorder = \"12_21\"\nparameter = \"S\"\nfrequencyunit = \"GHz\"\nformat = \"MA\"\nR = 50.0\nversion = 2.0\nJosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports, numberoffrequencies, \n    matrixformat, twoportdataorder, parameter, frequencyunit, format, R, version)\n\n# output\n15-element Vector{Float64}:\n   4.0\n   0.9995813511383583\n -17.248815971093425\n   4.5\n   0.9958480363660398\n -26.451285931791276\n   5.0\n   0.9868361175866559\n   2.711906450972103\n   5.5\n   0.9985678550072272\n -12.21545548845392\n   6.0\n   0.9993761539770525\n -16.045248853866596\n\nfrequencies = 4.0e9:5.0e8:6.0e9\nN = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]\nnumberofports = 1\nnumberoffrequencies = 5\nmatrixformat = \"Lower\"\ntwoportdataorder = \"12_21\"\nparameter = \"Z\"\nfrequencyunit = \"GHz\"\nformat = \"MA\"\nR = 50.0\nversion = 2.0\nJosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports,\n    numberoffrequencies, matrixformat, twoportdataorder, parameter,\n    frequencyunit, format, R, version)\n\n# output\n15-element Vector{Float64}:\n   4.0\n   0.9995813511383583\n -17.248815971093425\n   4.5\n   0.9958480363660398\n -26.451285931791276\n   5.0\n   0.9868361175866559\n   2.711906450972103\n   5.5\n   0.9985678550072272\n -12.21545548845392\n   6.0\n   0.9993761539770525\n -16.045248853866596\n\nfrequencies = 4.0e9:5.0e8:6.0e9\nN = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]\nnumberofports = 1\nnumberoffrequencies = 5\nmatrixformat = \"Lower\"\ntwoportdataorder = \"12_21\"\nparameter = \"Z\"\nfrequencyunit = \"GHz\"\nformat = \"MA\"\nR = 50.0\nversion = 1.0\nJosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports,\n    numberoffrequencies, matrixformat, twoportdataorder, parameter,\n    frequencyunit, format, R, version)\n\n# output\n15-element Vector{Float64}:\n   4.0\n   0.019991627022767165\n -17.248815971093425\n   4.5\n   0.019916960727320795\n -26.451285931791276\n   5.0\n   0.01973672235173312\n   2.7119064509721027\n   5.5\n   0.019971357100144544\n -12.215455488453918\n   6.0\n   0.019987523079541047\n -16.0452488538666\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcAoLjbm-Tuple{Any, SparseArrays.SparseVector, Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcAoLjbm","text":"calcAoLjbm(Am, Ljb::SparseVector, Lmean, Nmodes, Nbranches)\n\nExamples\n\njulia> @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,2,1)\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:\n A11 / Lj1  A31 / Lj1\n A31 / Lj1  A11 / Lj1\n\njulia> @syms Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,2,1).nzval\n4-element Vector{Any}:\n A11 / Lj1\n A31 / Lj1\n conj(A31 / Lj1)\n A11 / Lj1\n\njulia> @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)\n4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:\n A11 / Lj1  A31 / Lj1          ⋅          ⋅\n A31 / Lj1  A11 / Lj1          ⋅          ⋅\n         ⋅          ⋅  A12 / Lj2  A32 / Lj2\n         ⋅          ⋅  A32 / Lj2  A12 / Lj2\n\njulia> @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,3,1)\n3×3 SparseArrays.SparseMatrixCSC{Num, Int64} with 9 stored entries:\n A11 / Lj1  A31 / Lj1          0\n A31 / Lj1  A11 / Lj1  A31 / Lj1\n         0  A31 / Lj1  A11 / Lj1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcAoLjbm2-Tuple{Array, Matrix, SparseArrays.SparseVector, Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcAoLjbm2","text":"calcAoLjbm2(Am::Array, Amatrixindices::Matrix, Ljb::SparseVector, Lmean,\n    Nmodes, Nbranches, Nfreq)\n\nReturn the harmonic balance matrix divided by the Josephson inductance.\n\nExamples\n\nAmatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]\nAmatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])\nLmean = 1\nNmodes = 3\nNbranches = 2\nJosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)\n\n# output\n6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 18 stored entries:\n 1.0+1.0im  1.0-1.0im  1.0-1.0im      ⋅          ⋅          ⋅    \n 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    \n 1.0+1.0im  1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im  0.5-0.5im\n     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im\n     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5+0.5im\n\nAmatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]\nAmatrixindices = [1 -2 0; 2 1 -2; 0 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])\nLmean = 1\nNmodes = 3\nNbranches = 2\nJosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)\n\n# output\n6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 14 stored entries:\n 1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅          ⋅    \n 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    \n     ⋅      1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im      ⋅    \n     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im\n     ⋅          ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im\n\n@variables A11 A12 A21 A22 A31 A32 Lj1 Lj2\nAmatrix = [A11 A12;A21 A22;A31 A32]\nAmatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2])\nLmean = 1\nNmodes = 3\nNbranches = 2\nJosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)\n\n# output\n6×6 SparseArrays.SparseMatrixCSC{Num, Int64} with 18 stored entries:\n A11 / Lj1  A21 / Lj1  A31 / Lj1          ⋅          ⋅          ⋅\n A21 / Lj1  A11 / Lj1  A21 / Lj1          ⋅          ⋅          ⋅\n A31 / Lj1  A21 / Lj1  A11 / Lj1          ⋅          ⋅          ⋅\n         ⋅          ⋅          ⋅  A12 / Lj2  A22 / Lj2  A32 / Lj2\n         ⋅          ⋅          ⋅  A22 / Lj2  A12 / Lj2  A22 / Lj2\n         ⋅          ⋅          ⋅  A32 / Lj2  A22 / Lj2  A12 / Lj2\n\n@syms A11 A12 A21 A22 A31 A32 Lj1 Lj2\nAmatrix = [A11 A12;A21 A22;A31 A32]\nAmatrixindices = [1 0 0; 0 1 0; 0 0 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2])\nLmean = 1\nNmodes = 3\nNbranches = 2\nJosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches).nzval\n\n# output\n6-element Vector{Any}:\n A11 / Lj1\n A11 / Lj1\n A11 / Lj1\n A12 / Lj2\n A12 / Lj2\n A12 / Lj2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcAoLjbmindices-Tuple{Matrix, SparseArrays.SparseVector, Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcAoLjbmindices","text":"calcAoLjbmindices(Amatrixindices, Ljb::SparseVector, Nmodes, Nbranches,\n    Nfreq)\n\nReturn the sparse matrix containing the indices from the frequency domain RFFT data as well as the indices of the sparse matrix to conjugate.\n\nExamples\n\nAmatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])\nNmodes = 4\nNbranches = length(Ljb)\nNfreq = 4\nAoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(\n    Amatrixindices,\n    Ljb,\n    Nmodes,\n    Nbranches,\n    Nfreq);\nAoLjbmindices\n\n# output\n8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:\n 1  2  3  4  ⋅  ⋅  ⋅  ⋅\n 2  1  2  3  ⋅  ⋅  ⋅  ⋅\n 3  2  1  2  ⋅  ⋅  ⋅  ⋅\n 4  3  2  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  5  6  7  8\n ⋅  ⋅  ⋅  ⋅  6  5  6  7\n ⋅  ⋅  ⋅  ⋅  7  6  5  6\n ⋅  ⋅  ⋅  ⋅  8  7  6  5\n\nAmatrixindices = [1 -2 -3 0; 2 1 -2 -3; 3 2 1 -2; 0 3 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])\nNmodes = 4\nNbranches = length(Ljb)\nNfreq = 4\nAoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(\n    Amatrixindices,\n    Ljb,\n    Nmodes,\n    Nbranches,\n    Nfreq);\nAoLjbmindices\n\n# output\n8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 28 stored entries:\n 1  2  3  ⋅  ⋅  ⋅  ⋅  ⋅\n 2  1  2  3  ⋅  ⋅  ⋅  ⋅\n 3  2  1  2  ⋅  ⋅  ⋅  ⋅\n ⋅  3  2  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  5  6  7  ⋅\n ⋅  ⋅  ⋅  ⋅  6  5  6  7\n ⋅  ⋅  ⋅  ⋅  7  6  5  6\n ⋅  ⋅  ⋅  ⋅  ⋅  7  6  5\n\nAmatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]\nLjb = JosephsonCircuits.SparseArrays.sparsevec([1,3],[1.0,1.0])\nNmodes = 4\nNbranches = length(Ljb)\nNfreq = 4\nAoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(\n    Amatrixindices,\n    Ljb,\n    Nmodes,\n    Nbranches,\n    Nfreq);\nfor c in conjindicessorted;AoLjbmindices.nzval[c] = -AoLjbmindices.nzval[c];end;AoLjbmindices\n\n# output\n12×12 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:\n 1  -2  -3  -4  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n 2   1  -2  -3  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n 3   2   1  -2  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n 4   3   2   1  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  5  -6  -7  -8\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  6   5  -6  -7\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  7   6   5  -6\n ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  8   7   6   5\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcCjIcmean-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector{String}, Dict, Dict}","page":"Reference","title":"JosephsonCircuits.calcCjIcmean","text":"calcCjIcmean(componenttypes::Vector{Symbol}, nodeindexarray::Matrix{Int},\n    componentvalues::Vector, componentnamedict::Dict,\n    mutualinductorbranchnames::Vector{String}, countdict::Dict,\n    indexdict::Dict)\n\nCalculate the junction properties including the max and min critical currents and ratios of critical current to junction capacitance. This is necessary in order to set the junction properties of the JJ model in WRSPICE.\n\nExamples\n\ncomponenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]\nnodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]\ncomponentvalues = Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]\ncomponentnamedict = Dict(\"R1\" => 2, \"Cc2\" => 6, \"Cj2\" => 8, \"Cj1\" => 5, \"P1\" => 1, \"Cc1\" => 3, \"Lj2\" => 7, \"Lj1\" => 4)\nmutualinductorbranchnames = String[]\ncountdict = Dict((:Lj, 1, 4) => 1, (:C, 3, 4) => 1, (:C, 1, 4) => 1, (:Lj, 1, 3) => 1, (:R, 1, 2) => 1, (:P, 1, 2) => 1, (:C, 1, 3) => 1, (:C, 2, 3) => 1)\nindexdict = Dict((:C, 2, 3, 1) => 3, (:Lj, 1, 3, 1) => 4, (:C, 1, 3, 1) => 5, (:R, 1, 2, 1) => 2, (:C, 3, 4, 1) => 6, (:P, 1, 2, 1) => 1, (:C, 1, 4, 1) => 8, (:Lj, 1, 4, 1) => 7)\nCj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,\n    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)\n\n# output\n(3.1100514732000003e-13, 3.1414661345454545e-7)\n\ncomponenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]\nnodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]\ncomponentvalues = Real[1, 50.0, 1.0e-13, 2.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]\ncomponentnamedict = Dict(\"R1\" => 2, \"Cc2\" => 6, \"Cj2\" => 8, \"Cj1\" => 5, \"P1\" => 1, \"Cc1\" => 3, \"Lj2\" => 7, \"Lj1\" => 4)\nmutualinductorbranchnames = String[]\ncountdict = Dict((:Lj, 1, 4) => 1, (:C, 3, 4) => 1, (:C, 1, 4) => 1, (:Lj, 1, 3) => 1, (:R, 1, 2) => 1, (:P, 1, 2) => 1, (:C, 1, 3) => 1, (:C, 2, 3) => 1)\nindexdict = Dict((:C, 2, 3, 1) => 3, (:Lj, 1, 3, 1) => 4, (:C, 1, 3, 1) => 5, (:R, 1, 2, 1) => 2, (:C, 3, 4, 1) => 6, (:P, 1, 2, 1) => 1, (:C, 1, 4, 1) => 8, (:Lj, 1, 4, 1) => 7)\nCj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,\n    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)\n\n# output\n(2.2955141825999997e-13, 2.3187011945454544e-7)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcCn","text":"calcCn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, Nmodes, Nnodes)\n\nReturns the node capacitance matrix from the capacitance values in componentvalues when componenttypes has the symbol :C with node indices from nodeindices. Other symbols are ignored. Capacitances to ground become diagonal elements. Capacitance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are (Nnodes-1)*Nmodes by (Nnodes-1) times Nmodes where Nnodes is the number of nodes including ground and Nmodes is the number of different frequencies. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\njulia> JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[1.0,2.0],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅ \n  ⋅   2.0\n\njulia> JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  1.1  -0.1\n -0.1   2.1\n\njulia> JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],2,3)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  1.1    ⋅   -0.1    ⋅ \n   ⋅    1.1    ⋅   -0.1\n -0.1    ⋅    2.1    ⋅ \n   ⋅   -0.1    ⋅    2.1\n\njulia> @variables Cg1 Cg2;JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[Cg1,Cg2],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:\n Cg1    ⋅\n   ⋅  Cg2\n\njulia> @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:\n Cc + Cg1       -Cc\n      -Cc  Cc + Cg1\n\njulia> @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],2,3)\n4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:\n Cc + Cg1         ⋅       -Cc         ⋅\n        ⋅  Cc + Cg1         ⋅       -Cc\n      -Cc         ⋅  Cc + Cg1         ⋅\n        ⋅       -Cc         ⋅  Cc + Cg1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcGn","text":"calcGn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, Nmodes, Nnodes)\n\nReturns the node conductance matrix from the resistance values in componentvalues when componenttypes has the symbol :R. The node indices are taken from nodeindices. Conductances to ground are diagonal elements. Conductance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are (Nnodes-1) times Nmodes by (Nnodes-1) times Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nWe have to calculate the inverse of the individual components so select a type that allows that.\n\nExamples\n\njulia> JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[1.0,2.0],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅ \n  ⋅   0.5\n\njulia> JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  1.01  -0.01\n -0.01   0.51\n\njulia> JosephsonCircuits.calcGn([:R,:R,:R],[1 3 1;2 2 3],[1.0,100.0,2.0],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  1.01  -0.01\n -0.01   0.51\n\njulia> JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],2,3)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  1.01    ⋅    -0.01    ⋅ \n   ⋅     1.01    ⋅    -0.01\n -0.01    ⋅     0.51    ⋅ \n   ⋅    -0.01    ⋅     0.51\n\njulia> @variables Rg1 Rg2;JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[Rg1,Rg2],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:\n 1 / Rg1        ⋅\n       ⋅  1 / Rg2\n\njulia> @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],1,3)\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:\n 1 / Rg1 + 1 / Rc           -1 / Rc\n          -1 / Rc  1 / Rg2 + 1 / Rc\n\njulia> @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],2,3)\n4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:\n 1 / Rg1 + 1 / Rc                 ⋅           -1 / Rc                 ⋅\n                ⋅  1 / Rg1 + 1 / Rc                 ⋅           -1 / Rc\n          -1 / Rc                 ⋅  1 / Rg2 + 1 / Rc                 ⋅\n                ⋅           -1 / Rc                 ⋅  1 / Rg2 + 1 / Rc\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcIb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcIb","text":"calcIb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)\n\nCalculate the sparse branch current source vector whose length is Nbranches*Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:I,:C,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [1e-9, 0.2, 4e-9, 1e-12]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L1 => 3,:I1 => 1,:C1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nIb = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Ib)\n\n# output\nsparsevec([1], [1.0e-9], 2)\n\n@variables I1 C1 L1 C2\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:I,:C,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [I1, C1, L1, C2]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L1 => 3,:I1 => 1,:C1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nIb = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Ib)\n\n# output\nsparsevec([1], Num[I1], 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcLb","text":"calcLb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)\n\nCalculate the sparse branch inductance vector whose length is Nbranches*Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:L,:K,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [1e-9, 0.2, 4e-9, 1e-12]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L2 => 3,:L1 => 1,:K1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nLb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Lb)\n\n# output\nsparsevec([1, 2], [1.0e-9, 4.0e-9], 2)\n\n@variables L1 K1 L2 C1\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:L,:K,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [L1, K1, L2, C1]\ncomponentnamedict = Dict{Symbol, Int}(:C1 => 4,:L2 => 3,:L1 => 1,:K1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nLb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Lb)\n\n# output\nsparsevec([1, 2], Num[L1, L2], 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcLjb","text":"calcLjb(componenttypes, nodeindices, componentvalues, edge2indexdict,\n    Nmodes, Nbranches)\n\nCalculate the sparse branch Josephson inductance vector whose length is Nbranches*Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:Lj,:C,:Lj,:C]\nnodeindices = [2 3 3 3; 1 2 1 1]\ncomponentvalues = [1e-9, 1e-12, 4e-9, 1e-12]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L2 => 3,:L1 => 1,:Cc => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nLjb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Ljb)\n\n# output\nsparsevec([1, 2], [1.0e-9, 4.0e-9], 2)\n\n@variables Lj1 K1 Lj2 C1\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:Lj,:K,:Lj,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [Lj1, K1, Lj2, C1]\ncomponentnamedict = Dict{Symbol, Int}(:C1 => 4,:Lj2 => 3,:Lj1 => 1,:K1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nLjb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Ljb)\n\n# output\nsparsevec([1, 2], Num[Lj1, Lj2], 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}","page":"Reference","title":"JosephsonCircuits.calcLmean","text":"calcLmean(componenttypes::Vector{Symbol}, componentvalues::Vector)\n\nReturn the mean of the linear and Josephson inductors.\n\nExamples\n\njulia> JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[10,4,5,1])\n2.5\n\njulia> @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[R1, L1, C1, Lj1])\n(1//2)*(L1 + Lj1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector{Nothing}}","page":"Reference","title":"JosephsonCircuits.calcLmean_inner","text":"calcLmean_inner(componenttypes::Vector, componentvalues::Vector,\n    valuecomponenttypes::Vector{Nothing})\n\nReturn the mean of the linear and Josephson inductors. Return 0 if the expected return type is Nothing.\n\nExamples\n\njulia> JosephsonCircuits.calcLmean_inner([:R,:C,:C,:P],[10,4,5,1],Nothing[])\n0\n\njulia> @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[R1, L1, C1, Lj1],Nothing[])\n0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector}","page":"Reference","title":"JosephsonCircuits.calcLmean_inner","text":"calcLmean_inner(componenttypes::Vector, componentvalues::Vector,\n    valuecomponenttypes::Vector)\n\nReturn the mean of the linear and Josephson inductors.\n\nExamples\n\njulia> JosephsonCircuits.calcLmean_inner([:R,:L,:C,:Lj],[10,4,5,1],Float64[])\n2.5\n\njulia> JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[10,4,5,1],Float64[])\n0.0\n\njulia> @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean_inner([:R,:L,:C,:Lj],[R1, L1, C1, Lj1], Num[])\n(1//2)*(L1 + Lj1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcMb","text":"calcMb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, componentnamedict::Dict,\n    mutualinductorbranchnames::Vector, edge2indexdict::Dict, Nmodes,\n    Nbranches)\n\nReturns the branch mutual inductance matrix. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:L,:K,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [1e-9, 0.2, 2e-9, 1e-12]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L2 => 3,:L1 => 1,:K1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nmutualinductorbranchnames = [ :L1, :L2]\nMb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅           2.82843e-10\n 2.82843e-10   ⋅ \n\n@variables L1 L2 K1 C1\nNmodes = 2\nNbranches = 2\ncomponenttypes = [:L,:K,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [L1, K1, L2, C1]\ncomponentnamedict = Dict{Symbol, Int}(:C1 => 4,:L2 => 3,:L1 => 1,:K1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nmutualinductorbranchnames = [ :L1, :L2]\nMb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)\n\n# output\n4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:\n              ⋅               ⋅  K1*sqrt(L1*L2)               ⋅\n              ⋅               ⋅               ⋅  K1*sqrt(L1*L2)\n K1*sqrt(L1*L2)               ⋅               ⋅               ⋅\n              ⋅  K1*sqrt(L1*L2)               ⋅               ⋅\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcVb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcVb","text":"calcVb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)\n\nCalculate the sparse branch voltage source vector whose length is Nbranches*Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\nExamples\n\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:V,:C,:L1,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [1e-9, 0.2, 4e-9, 1e-12]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L1 => 3,:V1 => 1,:C1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nVb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Vb)\n\n# output\nsparsevec([1], [1.0e-9], 2)\n\n@variables V1 C1 L1 C2\nNmodes = 1\nNbranches = 2\ncomponenttypes = [:V,:C,:L,:C]\nnodeindices = [2 0 3 3; 1 0 1 1]\ncomponentvalues = [V1, C1, L1, C2]\ncomponentnamedict = Dict{Symbol, Int}(:C2 => 4,:L1 => 3,:V1 => 1,:C1 => 2)\nedge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) => 1,(3, 1) => 2,(1, 3) => 2,(2, 1) => 1)\nVb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)\nJosephsonCircuits.testshow(stdout,Vb)\n\n# output\nsparsevec([1], Num[V1], 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcbranchvector-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Dict, Any, Any, Symbol}","page":"Reference","title":"JosephsonCircuits.calcbranchvector","text":"calcbranchvector(componenttypes::Vector{Symbol},\n    nodeindices::Matrix{Int}, componentvalues::Vector,\n    valuecomponenttypes::Vector, edge2indexdict::Dict, Nmodes, Nbranches,\n    component::Symbol)\n\nCalculate the sparse branch vector whose length is Nbranches*Nmodes for the given component symbol. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccircuitgraph-Tuple{JosephsonCircuits.ParsedSortedCircuit}","page":"Reference","title":"JosephsonCircuits.calccircuitgraph","text":"calccircuitgraph(parsedsortedcircuit::ParsedSortedCircuit)\n\nCalculate the superconducting spanning tree, incidence matrix, closure branches, and loops from the parsed and sorted circuit.\n\nSee also CircuitGraph, calcgraphs, and extractbranches  for more explanation.\n\nExamples\n\n@variables Ipump Rleft L1 K1 L2 C2\npsc = JosephsonCircuits.ParsedSortedCircuit(\n    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],\n    [\"0\", \"1\", \"2\"],\n    [\"L1\", \"L2\"],\n    [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"],\n    [:P, :I, :R, :L, :K, :L, :C],\n    Num[1, Ipump, Rleft, L1, K1, L2, C2],\n    Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5),\n    3)\ncg = JosephsonCircuits.calccircuitgraph(psc)\n# output\nJosephsonCircuits.CircuitGraph(Dict((1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (2, 1) => 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)\n\n@variables Ipump Rleft L Lj Cj\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"2\",L))\npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj))\npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\npsc = JosephsonCircuits.parsesortcircuit(circuit)\ncg = JosephsonCircuits.calccircuitgraph(psc)\n# output\nJosephsonCircuits.CircuitGraph(Dict((3, 2) => 3, (1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (2, 1) => 1, (2, 3) => 3), sparse([1, 3, 2, 3], [1, 1, 2, 2], [1, -1, 1, 1], 3, 2), [(1, 2), (1, 3)], [(3, 2)], [(1, 2), (1, 3), (2, 3)], [[1, 2, 3]], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm!-NTuple{4, Any}","page":"Reference","title":"JosephsonCircuits.calccm!","text":"calccm!(cm, S, Snoise, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output.\n\nExamples\n\njulia> @variables a b c d an bn cn dn;cm = Num[0, 0];JosephsonCircuits.calccm!(cm,Num[a b; c d],[an bn; cn dn],[1, -1]);cm\n2-element Vector{Num}:\n abs2(an) + abs2(a) - abs2(b) - abs2(bn)\n abs2(c) + abs2(cn) - abs2(d) - abs2(dn)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm!-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calccm!","text":"calccm!(cm, S, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the field ladder operator basis. Overwrites cm with output. \n\nExamples\n\njulia> @variables a b;cm=Num[0,0];JosephsonCircuits.calccm!(cm,[a b; b a],[-1,1]);cm\n2-element Vector{Num}:\n -abs2(a) + abs2(b)\n  abs2(a) - abs2(b)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any, Any}} where T<:AbstractFloat","page":"Reference","title":"JosephsonCircuits.calccm!","text":"calccm!(cm, S, Snoise, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output.  Use a compensated sum to reduce floating point errors.\n\nExamples\n\njulia> cm=Float64[0, 0];JosephsonCircuits.calccm!(cm,[1 2;3 4],[1 2 3 4;5 6 7 8],[-1,1]);cm\n2-element Vector{Float64}:\n 13.0\n 33.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T<:AbstractFloat","page":"Reference","title":"JosephsonCircuits.calccm!","text":"calccm!(cm, S, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output. Use a compensated sum to reduce floating point errors.\n\nExamples\n\njulia> cm=Float64[0,0];JosephsonCircuits.calccm!(cm,[3/5 4/5;4/5 3/5],[-1,1]);cm\n2-element Vector{Float64}:\n  0.28000000000000014\n -0.28000000000000014\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Any}} where T","page":"Reference","title":"JosephsonCircuits.calccm","text":"calccm(S, Snoise, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation. \n\nExamples\n\njulia> JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 1 1 1],[1 1e-100 2e-100 1;1 1 1 1],[1, -1])\n2-element Vector{Float64}:\n 6.0e-200\n 0.0\n\njulia> JosephsonCircuits.calccm(Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],[1, -1])\n2-element Vector{Float64}:\n 6.0e-200\n 0.0\n\njulia> @variables a b c d an bn cn dn;JosephsonCircuits.calccm([a b; c d],[an bn; cn dn],[1, -1])\n2-element Vector{Num}:\n abs2(an) + abs2(a) - abs2(b) - abs2(bn)\n abs2(c) + abs2(cn) - abs2(d) - abs2(dn)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T","page":"Reference","title":"JosephsonCircuits.calccm","text":"calccm(S, w)\n\nCalculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation.\n\nExamples\n\njulia> JosephsonCircuits.calccm(Complex{Float64}[3/5 4/5;4/5 3/5],[1])\n2-element Vector{Float64}:\n 1.0\n 1.0\n\njulia> JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 0 0 1],[1, -1])\n2-element Vector{Float64}:\n 3.0e-200\n 0.0\n\njulia> @variables a b;JosephsonCircuits.calccm([a b; b a],[1, -1])\n2-element Vector{Num}:\n  abs2(a) - abs2(b)\n -abs2(a) + abs2(b)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcdZdroZ2-NTuple{5, Any}","page":"Reference","title":"JosephsonCircuits.calcdZdroZ2","text":"calcdZdroZ2(sensitivityindices, componenttypes, componentvalues, wmodes,\n    symfreqvar)\n\nCalculate 1/Z^2 times the derivative of Z with respect to parameter scaling the value of the circuit component. For example: Zc = 1/(imwCgr) 1/Zc^2dZc/dr|_{r=1} = -imCgw\n\nZl = imwLjr 1/Zl^2dZl/dr =1/(imLjr^2w)|_{r=1} = 1/(imLj*w)\n\nZr = Rr 1/Zr^2dZr/dr|_{r=1} = 1/(r^2*R) = 1/R\n\nExamples\n\njulia> JosephsonCircuits.calcdZdroZ2([1],[:R], [50.0], [1.0],nothing)\n1-element Vector{ComplexF64}:\n 0.02 + 0.0im\n\njulia> JosephsonCircuits.calcdZdroZ2([1],[:C], [2.0], [1.0],nothing)\n1-element Vector{ComplexF64}:\n 0.0 - 2.0im\n\njulia> JosephsonCircuits.calcdZdroZ2([1],[:L], [2.0], [1.0],nothing)\n1-element Vector{ComplexF64}:\n 0.0 - 0.5im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcfj!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 9}}","page":"Reference","title":"JosephsonCircuits.calcfj!","text":"calcfj(F,J,nodeflux,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,\n    Ljbindicesm,Nmodes,Lmean,AoLjbm)\n\nCalculate the residual and the Jacobian. These are calculated with one function in order to reuse the time domain nonlinearity calculation.\n\nLeave off the type signatures on F and J because the solver will pass a type of Nothing if it only wants to calculate F or J. \n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcfj2!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 18}}","page":"Reference","title":"JosephsonCircuits.calcfj2!","text":"calcfj2(F,J,phin,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,\n    Ljbindicesm,Nmodes,Lmean,AoLjbm)\n\nCalculate the residual and the Jacobian. These are calculated with one function in order to reuse as much as possible.\n\nLeave off the type signatures on F and J because the solver will pass nothing if it only wants to calculate F or J.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcfreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Reference","title":"JosephsonCircuits.calcfreqs","text":"calcfreqs(Nharmonics::NTuple{N,Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int})\n\nCalculate the dimensions of the DFT or RFDT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array. See also calcfreqsrdft and calcfreqsdft.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N","page":"Reference","title":"JosephsonCircuits.calcfreqsdft","text":"calcfreqsdft(Nharmonics::NTuple{N,Int})\n\nCalculate the dimensions of the DFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain DFT array.\n\nArguments\n\nNharmonics: is a tuple of the number of harmonics to calculate for   each frequency.\n\nReturns\n\nFrequencies: A simple structure to hold time and frequency domain   information for the signal for a single node. See Frequencies.\n\nExamples\n\njulia> JosephsonCircuits.calcfreqsrdft((1,))\nJosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((2,))\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((3,))\nJosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((3,3))\nJosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N","page":"Reference","title":"JosephsonCircuits.calcfreqsrdft","text":"calcfreqsrdft(Nharmonics::NTuple{N,Int})\n\nCalculate the dimensions of the RDFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array.\n\nArguments\n\nNharmonics: is a tuple of the number of harmonics to calculate for   each frequency.\n\nReturns\n\nFrequencies: A simple structure to hold time and frequency domain   information for the signal for a single node. See Frequencies.\n\nExamples\n\njulia> JosephsonCircuits.calcfreqsrdft((1,))\nJosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((2,))\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((3,))\nJosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])\n\njulia> JosephsonCircuits.calcfreqsrdft((3,3))\nJosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}","page":"Reference","title":"JosephsonCircuits.calcgraphs","text":"calcgraphs(Ledgearray::Array{Tuple{Int, Int}, 1}, Nnodes::Int)\n\nCalculate the superconducting spanning tree, closure branches, and loops. Accepts the graph of linear inductors and Josephson junctions. Outputs lists of edges that can be used to generate graphs.\n\nExamples\n\njulia> JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (2, 1), (3, 1)], 3)\nJosephsonCircuits.CircuitGraph(Dict((1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (2, 1) => 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)\n\njulia> JosephsonCircuits.calcgraphs([(4, 3), (3, 6), (5, 3), (3, 7), (2, 4), (6, 8), (2, 5), (8, 7), (2, 8)], 8)\nJosephsonCircuits.CircuitGraph(Dict((6, 8) => 8, (2, 5) => 2, (3, 7) => 7, (6, 3) => 6, (7, 8) => 9, (3, 4) => 4, (7, 3) => 7, (2, 8) => 3, (4, 2) => 1, (8, 6) => 8…), sparse([1, 2, 3, 4, 5, 6, 7, 1, 4, 2, 5, 6, 8, 7, 9, 3, 8, 9], [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7], [-1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1], 9, 7), [(2, 4), (2, 5), (2, 8), (3, 4), (3, 6), (3, 7)], [(5, 3), (8, 6), (8, 7)], [(2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (3, 7), (6, 8), (7, 8)], [[2, 4, 3, 5], [2, 4, 3, 6, 8], [2, 4, 3, 7, 8]], [1], Graphs.SimpleGraphs.SimpleGraph{Int64}(9, [Int64[], [4, 5, 8], [4, 5, 6, 7], [2, 3], [2, 3], [3, 8], [3, 8], [2, 6, 7]]), 9)\n\njulia> JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (3, 1)],4)\nJosephsonCircuits.CircuitGraph(Dict((1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (2, 1) => 1), sparse([1, 2], [1, 2], [1, 1], 2, 3), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcimpedance-NTuple{4, Any}","page":"Reference","title":"JosephsonCircuits.calcimpedance","text":"calcimpedance(c, type, w, symfreqvar)\n\nExamples\n\njulia> @variables w;JosephsonCircuits.calcimpedance(30*w,:R,2.0,w)\n60.0 + 0.0im\n\njulia> @variables w;JosephsonCircuits.calcimpedance(30*w,:C,2.0,w)\n0.0 - 0.008333333333333333im\n\njulia> @variables w;JosephsonCircuits.calcimpedance(30*w,:R,-2.0,w)\n-60.0 + 0.0im\n\njulia> @variables w;JosephsonCircuits.calcimpedance(30*w,:C,-2.0,w)\n0.0 - 0.008333333333333333im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcimpedance-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Any, Any, Any}} where T<:Union{AbstractFloat, Integer}","page":"Reference","title":"JosephsonCircuits.calcimpedance","text":"calcimpedance(c::Union{Integer,T,Complex{T}}, type, w, symfreqvar,\n    ) where {T<:AbstractFloat}\n\nExamples\n\njulia> JosephsonCircuits.calcimpedance(30.0,:C,1.0,nothing)\n0.0 - 0.03333333333333333im\n\njulia> JosephsonCircuits.calcimpedance(30.0,:R,1.0,nothing)\n30.0 + 0.0im\n\njulia> JosephsonCircuits.calcimpedance(30.0,:C,-1.0,nothing)\n-0.0 + 0.03333333333333333im\n\njulia> JosephsonCircuits.calcimpedance(30.0,:R,-1.0,nothing)\n30.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcindexdict-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.calcindexdict","text":"calcindexdict(N::Int)\n\nReturn a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.\n\nExamples\n\njulia> JosephsonCircuits.calcindexdict(3)\nDict{CartesianIndex{1}, Int64} with 3 entries:\n  CartesianIndex(2,) => 2\n  CartesianIndex(3,) => 3\n  CartesianIndex(1,) => 1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcindexdict-Tuple{Tuple}","page":"Reference","title":"JosephsonCircuits.calcindexdict","text":"calcindexdict(N::Tuple)\n\nReturn a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.\n\nExamples\n\njulia> JosephsonCircuits.calcindexdict((2,3))\nDict{CartesianIndex{2}, Int64} with 6 entries:\n  CartesianIndex(2, 3) => 6\n  CartesianIndex(2, 1) => 2\n  CartesianIndex(1, 3) => 5\n  CartesianIndex(1, 1) => 1\n  CartesianIndex(2, 2) => 4\n  CartesianIndex(1, 2) => 3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcindices-Tuple{Integer}","page":"Reference","title":"JosephsonCircuits.calcindices","text":"calcindices(m::Integer)\n\nThe indices over which to calculate the idlers using the formula ws+2iwp  where i is an index. This could be defined differently without causing any issues.\n\nExamples\n\njulia> JosephsonCircuits.calcindices(7)\n-3:3\n\njulia> JosephsonCircuits.calcindices(8)\n-4:3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinputcurrentoutputvoltage!-NTuple{8, Any}","page":"Reference","title":"JosephsonCircuits.calcinputcurrentoutputvoltage!","text":"calcinputcurrentoutputvoltage!(inputcurrent, outputvoltage, nodeflux,\n    bnm, inputportindices, outputportindices, nodeindices, wmodes)\n\nCalculate the elements of the Z matrix.\n\nExamples\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[-1; 1;;]\nportimpedanceindices = [2]\nportimpedances = ComplexF64[50.0 + 0.0im]\nnodeindices = [2 2 2 2 3; 3 3 1 1 1]\ncomponenttypes = [:P, :R, :L, :C, :C]\nwmodes = [1]\nphin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputcurrentoutputvoltage!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,nodeindices,wmodes)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[-1.0 + 0.0im;;]\nComplexF64[-100.0 + 0.0im;;]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinputoutput!-NTuple{12, Any}","page":"Reference","title":"JosephsonCircuits.calcinputoutput!","text":"calcinputoutput!(inputwave, outputwave, phin, bnm, inputportindices,\n    outputportindices, inputportimpedances, outputportimpedances,\n    nodeindices, componenttypes, wmodes, symfreqvar)\n\nReturn the input and output waves for the system linearized around the strong pump.\n\nExamples\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[1; 0;;]\nportimpedanceindices = [3]\nportimpedances = ComplexF64[50]\nnodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]\ncomponenttypes = [:P, :I, :R, :L, :K, :L, :C]\nwmodes = [1]\nphin = ComplexF64[0;0;;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,\n    wmodes,symfreqvar)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[3.5355339059327378 + 0.0im;;]\nComplexF64[-3.5355339059327378 + 0.0im;;]\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[1; 0;;]\nportimpedanceindices = [3]\nportimpedances = ComplexF64[50]\nnodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]\ncomponenttypes = [:P, :I, :R, :L, :K, :L, :C]\nwmodes = [1]\nphin = ComplexF64[50/(im*wmodes[1]);0;;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,\n    wmodes,symfreqvar)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[3.5355339059327378 + 0.0im;;]\nComplexF64[3.5355339059327378 + 0.0im;;]\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[1; 0;;]\nportimpedanceindices = [3]\nportimpedances = ComplexF64[50]\nnodeindices = [1 1 1 1 0 1 1; 2 2 2 2 0 3 3;]\ncomponenttypes = [:P, :I, :R, :L, :K, :L, :C]\nwmodes = [1]\nphin = ComplexF64[50/(im*wmodes[1]);0;;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,\n    wmodes,symfreqvar)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[-3.5355339059327378 - 0.0im;;]\nComplexF64[-3.5355339059327378 + 0.0im;;]\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[-1; 1;;]\nportimpedanceindices = [2]\nportimpedances = ComplexF64[50.0 + 0.0im]\nnodeindices = [2 2 2 2 3; 3 3 1 1 1]\ncomponenttypes = [:P, :R, :L, :C, :C]\nwmodes = [1]\nphin = ComplexF64[0;0;;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,\n    wmodes,symfreqvar)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[-3.5355339059327378 + 0.0im;;]\nComplexF64[3.5355339059327378 + 0.0im;;]\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\noutputwave = ComplexF64[0;;]\nbnm = ComplexF64[-1; 1;;]\nportimpedanceindices = [2]\nportimpedances = ComplexF64[50.0 + 0.0im]\nnodeindices = [2 2 2 2 3; 3 3 1 1 1]\ncomponenttypes = [:P, :R, :L, :C, :C]\nwmodes = [1]\nphin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,\n    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,\n    wmodes,symfreqvar)\nprintln(inputwave)\nprintln(outputwave)\n\n# output\nComplexF64[-3.5355339059327378 + 0.0im;;]\nComplexF64[-10.606601717798213 + 0.0im;;]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinputoutput_inner!-NTuple{13, Any}","page":"Reference","title":"JosephsonCircuits.calcinputoutput_inner!","text":"calcinputoutput_inner!(inputwave, outputwave, phin, bnm, inputportindices,\n    outputportindices, inputportimpedances, outputportimpedances,\n    nodeindices, componenttypes, wmodes, symfreqvar, nosource)\n\nCalculate the input and output power waves as defined in (except in units of sqrt(photons/second) instead of sqrt(power) K. Kurokawa, \"Power Waves and the Scattering Matrix\", IEEE Trans. Micr. Theory and Tech. 13, 194–202 (1965)  doi: 10.1109/TMTT.1965.1125964 inputwave[(i-1)Nmodes+j,k] = 1/2kval * (portvoltage + portimpedance * portcurrent) we can simplify the above to: inputwave[(i-1)Nmodes+j,k] = 1/2kval * portimpedance * sourcecurrent outputwave[(i-1)Nmodes+j,k] = 1/2kval * (portvoltage - conj(portimpedance) * portcurrent)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinputoutputnoise!-NTuple{12, Any}","page":"Reference","title":"JosephsonCircuits.calcinputoutputnoise!","text":"calcinputoutputnoise!(S, inputwave, outputwave, phin, bnm,\n    inputportindices, outputportindices, inputportimpedances,\n    outputportimpedances, nodeindices, componenttypes, wmodes, symfreqvar)\n\nReturn the input and output waves for the system linearized around the strong pump.\n\nThis is a bit of a hack but I ran into issues with complex capacitance when the capacitor was at the same branch as a current source. the calcS function would use that current source in calculating the output waves, which it should not do.\n\nExamples\n\ninputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])\nnoiseoutputwave = ComplexF64[0;;]\nphin = ComplexF64[-2.5000000000007394e-10 - 0.000795774715459398im; 1.983790476804266e-20 + 3.141592641138603e-16im;;]\nbnm = ComplexF64[1.0 + 0.0im; 0.0 + 0.0im;;]\nportimpedanceindices = [2]\nnoiseportimpedanceindices = [6]\nportimpedances = [50]\nnoiseportimpedances = [1]\nnodeindices = [2 2 2 3 3 3; 1 1 3 1 1 1]\ncomponenttypes = [:P, :R, :C, :Lj, :C, :R]\nwmodes = [2*pi*5e9]\nsymfreqvar = nothing\nJosephsonCircuits.calcinputoutputnoise!(inputwave,noiseoutputwave,\n    phin,bnm,portimpedanceindices,noiseportimpedanceindices,\n    portimpedances,noiseportimpedances,nodeindices,\n    componenttypes,wmodes,symfreqvar)\nprintln(inputwave)\nprintln(noiseoutputwave)\n\n# output\nComplexF64[1.994711402007163e-5 + 0.0im;;]\nComplexF64[-5.568327974762547e-11 + 3.516177070001411e-15im;;]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}","page":"Reference","title":"JosephsonCircuits.calcinvLn","text":"calcinvLn(Lb::SparseVector, Rbn::SparseMatrixCSC, Nmodes)\n\nReturns the nodal inverse inductance matrix. Accepts the vector of branch inductances Lb and the incidence matrix Rbn.\n\nExamples\n\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0e9   ⋅ \n  ⋅     2.5e8\n\n@variables L1 L2\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:\n 1 / L1       ⋅\n      ⋅  1 / L2\n\n@variables L1 L2\nNmodes = 2\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)\n\n# output\n4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:\n 1 / L1       ⋅       ⋅       ⋅\n      ⋅  1 / L1       ⋅       ⋅\n      ⋅       ⋅  1 / L2       ⋅\n      ⋅       ⋅       ⋅  1 / L2\n\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([],Nothing[])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval\n\n# output\nNothing[]\n\n@syms L1 L2\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval\n\n# output\n2-element Vector{Any}:\n 1 / L1\n 1 / L2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}","page":"Reference","title":"JosephsonCircuits.calcinvLn","text":"calcinvLn(Lb::SparseVector, Mb::SparseMatrixCSC,\n    Rbn::SparseMatrixCSC, Nmodes)\n\nReturns the nodal inverse inductance matrix. Accepts the vector of branch inductances Lb, the branch mutual inductance matrix Mb, and the incidence matrix Rbn.\n\nUsing ldiv instead of an inverse: (where the extra div is an escape sequence) Can solve A x = B with: x = A \\ B or x = invA * B, so we can perform the inverse here with: s = RbnT * invL * Rbn or s = RbnT * (L \\ Rbn), the latter of which should be faster and more numerically stable.\n\nExamples\n\nNmodes = 2\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])\nMb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [4e-10,4e-10])\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nJosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes)\n\n# output\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  1.04167e9    ⋅         -1.04167e8    ⋅ \n   ⋅          1.04167e9    ⋅         -1.04167e8\n -1.04167e8    ⋅          2.60417e8    ⋅ \n   ⋅         -1.04167e8    ⋅          2.60417e8\n\n@variables L1 L2 Lm\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);\nMb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])\nprintln(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))\n\n# output\nsparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm*(Lm / L1)) / (L2 + (-(Lm^2)) / L1)) / L1, (-(Lm / L1)) / (L2 + (-(Lm^2)) / L1), (-(Lm / (L2 + (-(Lm^2)) / L1))) / L1, 1.0 / (L2 + (-(Lm^2)) / L1)], 2, 2)\n\n@syms L1 L2 Lm\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);\nMb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])\nprintln(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))\n\n# output\nsparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm*(Lm / L1)) / (L2 + (-(Lm^2)) / L1)) / L1, (-(Lm / L1)) / (L2 + (-(Lm^2)) / L1), (-(Lm / (L2 + (-(Lm^2)) / L1))) / L1, 1.0 / (L2 + (-(Lm^2)) / L1)], 2, 2)\n\n@variables L1 L2\nNmodes = 1\nLb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);\nMb = JosephsonCircuits.SparseArrays.sparse([], [], Nothing[]);\nRbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])\nprintln(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))\n\n# output\nsparse([1, 2], [1, 2], Num[1 / L1, 1 / L2], 2, 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcmodefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Array{Tuple{Vararg{Int64, N}}, 1}}} where N","page":"Reference","title":"JosephsonCircuits.calcmodefreqs","text":"calcmodefreqs(w::NTuple{N},modes::Vector{NTuple{N,Int}})\n\nCalculate the frequencies of the modes given a tuple of fundamental frequencies and a vector of tuples containing the mixing products and harmonics.\n\nExamples\n\njulia> @variables wp1 wp2;JosephsonCircuits.calcmodefreqs((wp1, wp2),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])\n6-element Vector{Num}:\n          0\n        wp1\n       2wp1\n        wp2\n  wp1 + wp2\n 2wp1 + wp2\n\njulia> JosephsonCircuits.calcmodefreqs((1., 1.1),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])\n6-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 1.1\n 2.1\n 3.1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcnodematrix-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Any, Any, Symbol, Bool}","page":"Reference","title":"JosephsonCircuits.calcnodematrix","text":"calcnodematrix(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},\n    componentvalues::Vector, valuecomponenttypes::Vector, Nmodes, Nnodes,\n    component::Symbol, invert::Bool)\n\nReturns either the capacitance or conductance matrix depending on the values of component and invert. :C and false for capacitance and :R and true for conductance. The dimensions of the output are (Nnodes-1) times Nmodes by (Nnodes-1) times Nmodes. Note that nodeindices is \"one indexed\" so 1 is the ground node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcnodes-Tuple{Int64, Int64, Vector{Symbol}, Matrix, Dict, Vector{String}}","page":"Reference","title":"JosephsonCircuits.calcnodes","text":"calcnodes(nodeindex::Int, mutualinductorindex::Int,\n    componenttypes::Vector{Symbol}, nodeindexarray::Matrix,\n    componentnamedict::Dict, mutualinductorbranchnames::Vector{String})\n\nCalculate the two nodes (or mutual inductor indices) given the index in the typvector and the component type. For component types where order matters, such as mutual inductors, the nodes are not sorted. For other component types where order does not matter, the nodes are sorted. \n\nExamples\n\n@variables R Cc L1 L2 Cj1 Cj2 I1 V1\n@variables Ipump Rleft L1 K1 K2 L2 C2 C3\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",K1))\npush!(circuit,(\"K2\",\"L1\",\"L2\",K2))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\npush!(circuit,(\"C3\",\"2\",\"0\",C3))\npsc = JosephsonCircuits.parsesortcircuit(circuit)\nprintln(JosephsonCircuits.calcnodes(1,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))\nprintln(JosephsonCircuits.calcnodes(5,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))\n\n# output\n(1, 2)\n(4, 7)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcnodesorting-Tuple{Vector{String}}","page":"Reference","title":"JosephsonCircuits.calcnodesorting","text":"calcnodesorting(uniquenodevector::Vector{String};sorting=:number)\n\nSort the unique node names in uniquenodevector according to the specified sorting scheme, always placing the ground node at the beginning. Return the indices which sort uniquenodevector.\n\nKeywords\n\nsorting = :name: Sort the vector of strings. This always works but leads   to results like \"101\" comes before \"11\".\nsorting = :number: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).\nsorting = :none: Don't perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   circuit.\n\nExamples\n\njulia> JosephsonCircuits.calcnodesorting([\"30\",\"11\",\"0\",\"2\"];sorting=:name)\n4-element Vector{Int64}:\n 3\n 2\n 4\n 1\n\njulia> JosephsonCircuits.calcnodesorting([\"30\",\"11\",\"0\",\"2\"];sorting=:number)\n4-element Vector{Int64}:\n 3\n 4\n 2\n 1\n\njulia> JosephsonCircuits.calcnodesorting([\"30\",\"11\",\"0\",\"2\"];sorting=:none)\n4-element Vector{Int64}:\n 3\n 1\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}","page":"Reference","title":"JosephsonCircuits.calcnoiseportimpedanceindices","text":"calcnoiseportimpedanceindices(componenttypes::Vector{Symbol},\n    nodeindexarray::Matrix{Int}, mutualinductorbranchnames::Vector,\n    componentvalues::Vector)\n\nFind the resistors (not located at a port) or lossy capacitors or lossy inductors  and return their indices. \n\nExamples\n\nJosephsonCircuits.calcnoiseportimpedanceindices(\n    [:R,:C,:Lj,:C],\n    [2 2 3 3; 1 3 1 1],\n    [],\n    [50,5e-15,1e-12,30e-15])\n\n# output\n1-element Vector{Int64}:\n 1\n\nJosephsonCircuits.calcnoiseportimpedanceindices(\n    [:P,:R,:C,:Lj,:C],\n    [2 2 2 3 3; 1 1 3 1 1],\n    [],\n    [1,50,5e-15,1e-12,30e-15])\n\n# output\nInt64[]\n\nJosephsonCircuits.calcnoiseportimpedanceindices(\n    [:R,:C,:Lj,:C],\n    [2 2 3 3; 1 3 1 1],\n    [],\n    [50,5e-15,1e-12,(30+1im)*1e-15])\n\n# output\n2-element Vector{Int64}:\n 1\n 4\n\nJosephsonCircuits.calcnoiseportimpedanceindices(\n    [:R,:C,:L,:C],\n    [2 2 3 3; 1 3 1 1],\n    [],\n    [50,5e-15,(1+1im)*1e-12,30e-15])\n\n# output\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcphiindices-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, Dict{CartesianIndex{N}, CartesianIndex{N}}}} where N","page":"Reference","title":"JosephsonCircuits.calcphiindices","text":"calcphiindicescalcphiindices(frequencies::Frequencies{N},\n    conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}})\n\nReturn the indices which map the elements of the frequency domain vector to the corresponding elements of the frequency domain array. Also return the indices conjsourceindices whose data should be copied from the vector to conjtargetindices in the array then complex conjugated\n\nArguments\n\nNt: tuple with dimensions of signal in time domain \ndropdict: dictionary of elements of frequency domain signal to drop where   the key is the Cartesian index and the value is the value. \n\nReturns\n\nindexmap: the indices which map the elements of the frequency domain   vector elements to the corresponding elements of the frequency domain array\nconjsourceindices: data should be copied from here\nconjtargetindices: data should be copied to here and conjugated\n\nExamples\n\nfreq = JosephsonCircuits.Frequencies{2}((4, 3), (5, 7), (8, 7), CartesianIndex{2}[CartesianIndex(2, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(3, 2), CartesianIndex(2, 3), CartesianIndex(1, 4), CartesianIndex(2, 6), CartesianIndex(3, 7)], [(1, 0), (3, 0), (0, 1), (2, 1), (1, 2), (0, 3), (1, -2), (2, -1)])\nconjsymdict = Dict{CartesianIndex{2}, CartesianIndex{2}}(CartesianIndex(5, 4) => CartesianIndex(5, 5), CartesianIndex(1, 3) => CartesianIndex(1, 6), CartesianIndex(5, 2) => CartesianIndex(5, 7), CartesianIndex(1, 4) => CartesianIndex(1, 5), CartesianIndex(1, 2) => CartesianIndex(1, 7), CartesianIndex(5, 3) => CartesianIndex(5, 6))\nJosephsonCircuits.calcphiindices(freq, conjsymdict)\n\n# output\n([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])\n\nfreq = JosephsonCircuits.calcfreqsrdft((4,3));\ntruncfreq = JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=3)\nnoconjtruncfreq = JosephsonCircuits.removeconjfreqs(truncfreq)\nconjsymdict = JosephsonCircuits.conjsym(noconjtruncfreq)\nJosephsonCircuits.calcphiindices(noconjtruncfreq,conjsymdict)\n\n# output\n([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}","page":"Reference","title":"JosephsonCircuits.calcportimpedanceindices","text":"calcportimpedanceindices(componenttypes::Vector{Symbol},\n    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,\n    componentvalues::Vector)\n\nFind the resistors located at a port and return their indices.\n\nExamples\n\nJosephsonCircuits.calcportimpedanceindices(\n    [:P,:R,:C,:Lj,:C],\n    [2 2 2 3 3; 1 1 3 1 1],\n    [],\n    [1,50,5e-15,1e-12,30e-15])\n\n# output\n1-element Vector{Int64}:\n 2\n\nJosephsonCircuits.calcportimpedanceindices(\n    [:R,:C,:Lj,:C],\n    [2 2 3 3; 1 3 1 1],\n    [],\n    [50,5e-15,1e-12,30e-15])\n\n# output\nInt64[]\n\nJosephsonCircuits.calcportimpedanceindices(\n    [:P,:R,:C,:Lj,:C,:P,:R],\n    [2 3 2 3 3 3 2; 1 1 3 1 1 1 1],\n    [],\n    [1,50,5e-15,1e-12,30e-15,2,50.0])\n\n# output\n2-element Vector{Int64}:\n 7\n 2\n\nJosephsonCircuits.calcportimpedanceindices(\n    [:P,:R,:C,:Lj,:C,:P,:R],\n    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],\n    [],\n    [1,50,5e-15,1e-12,30e-15,2,50.0])\n\n# output\n2-element Vector{Int64}:\n 2\n 7\n\nJosephsonCircuits.calcportimpedanceindices(\n    [:P,:R,:C,:Lj,:C,:P,:R],\n    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],\n    [],\n    [2,50,5e-15,1e-12,30e-15,1,50.0])\n\n# output\n2-element Vector{Int64}:\n 7\n 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}","page":"Reference","title":"JosephsonCircuits.calcportindicesnumbers","text":"calcportindicesnumbers(componenttypes::Vector{Symbol},\n    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,\n    componentvalues::Vector)\n\nReturn vectors containing the indices of the ports and their numbers.\n\nExamples\n\nJosephsonCircuits.calcportindicesnumbers(\n    [:P,:R,:C,:Lj,:C],\n    [2 2 2 3 3; 1 1 3 1 1],\n    [],\n    [1,50,5e-15,1e-12,30e-15])\n\n# output\n([1], [1])\n\nJosephsonCircuits.calcportindicesnumbers(\n    [:P,:R,:C,:Lj,:P],\n    [2 2 2 3 3; 1 1 3 1 1],\n    [],\n    [1,50,5e-15,1e-12,2])\n\n# output\n([1, 5], [1, 2])\n\nJosephsonCircuits.calcportindicesnumbers(\n    [:P,:R,:C,:Lj,:P],\n    [2 2 2 3 3; 1 1 3 1 1],\n    [],\n    [2,50,5e-15,1e-12,1])\n\n# output\n([5, 1], [1, 2])\n\nJosephsonCircuits.calcportindicesnumbers(\n    [:R,:C,:Lj,:C],\n    [2 2 3 3; 1 3 1 1],\n    [],\n    [50,5e-15,1e-12,30e-15])\n\n# output\n(Int64[], Int64[])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqe!-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcqe!","text":"calcqe!(qe, S, Snoise)\n\nCalculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output. \n\nExamples\n\njulia> qe=Float64[1 2;3 4];JosephsonCircuits.calcqe!(qe,[1 2;3 4],[1 2 3;4 5 6]);qe\n2×2 Matrix{Float64}:\n 0.0526316  0.210526\n 0.0882353  0.156863\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqe!-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.calcqe!","text":"calcqe!(qe, S)\n\nCalculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqe-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Reference","title":"JosephsonCircuits.calcqe","text":"calcqe(S)\n\nCalculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. \n\nExamples\n\njulia> JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5])\n2×2 Matrix{Float64}:\n 0.36  0.64\n 0.64  0.36\n\njulia> JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5])\n2×2 Matrix{Float64}:\n 0.36  0.64\n 0.64  0.36\n\njulia> @variables a b c d;JosephsonCircuits.calcqe([a b; c d])\n2×2 Matrix{Num}:\n abs2(a) / (abs2(a) + abs2(b))  abs2(b) / (abs2(a) + abs2(b))\n abs2(c) / (abs2(c) + abs2(d))  abs2(d) / (abs2(c) + abs2(d))\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqe-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T","page":"Reference","title":"JosephsonCircuits.calcqe","text":"calcqe(S, Snoise)\n\nCalculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. \n\nExamples\n\njulia> JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5],[0.0 0.0;0.0 0.0])\n2×2 Matrix{Float64}:\n 0.36  0.64\n 0.64  0.36\n\njulia> JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5],Complex{Float64}[0.0 0.0;0.0 0.0])\n2×2 Matrix{Float64}:\n 0.36  0.64\n 0.64  0.36\n\njulia> @variables a b c d an bn cn dn;JosephsonCircuits.calcqe([a b; c d],[an bn; cn dn])\n2×2 Matrix{Num}:\n abs2(a) / (abs2(an) + abs2(a) + abs2(b) + abs2(bn))  …  abs2(b) / (abs2(an) + abs2(a) + abs2(b) + abs2(bn))\n abs2(c) / (abs2(c) + abs2(cn) + abs2(d) + abs2(dn))     abs2(d) / (abs2(c) + abs2(cn) + abs2(d) + abs2(dn))\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqeideal!-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.calcqeideal!","text":"calcqeideal!(qeideal,S)\n\nSee calcqeideal. \n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Reference","title":"JosephsonCircuits.calcqeideal","text":"calcqeideal(S::AbstractArray)\n\nCalculate the ideal (best possible) quantum efficiency for each element of a scattering matrix. See also calcqeideal!. \n\nExamples\n\njulia> JosephsonCircuits.calcqeideal([3/5 4/5;4/5 3/5])\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\njulia> JosephsonCircuits.calcqeideal(Complex{Float64}[3/5 4/5;4/5 3/5])\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.calcscatteringmatrix!","text":"calcscatteringmatrix!(S, inputwave, outputwave)\n\nThe scattering matrix is defined as outputwave = S * inputwave.\n\nExamples\n\njulia> inputwave=[1.0 0.0;0.0 1.0];outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S\n2×2 Matrix{ComplexF64}:\n      0.0+0.707107im  0.707107+0.0im\n 0.707107+0.0im            0.0+0.707107im\n\njulia> inputwave = rand(Complex{Float64},2,2);outputwave = rand(Complex{Float64},2,2);S=zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);isapprox(S*inputwave,outputwave)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, LinearAlgebra.Diagonal, Any}","page":"Reference","title":"JosephsonCircuits.calcscatteringmatrix!","text":"calcscatteringmatrix!(S, inputwave::Diagonal, outputwave)\n\nThe scattering matrix is defined as outputwave = S * inputwave.\n\nExamples\n\njulia> inputwave=JosephsonCircuits.LinearAlgebra.Diagonal([1.0,1.0]);outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S\n2×2 Matrix{ComplexF64}:\n      0.0+0.707107im  0.707107+0.0im\n 0.707107+0.0im            0.0+0.707107im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Vector, Vector}","page":"Reference","title":"JosephsonCircuits.calcscatteringmatrix!","text":"calcscatteringmatrix!(S, inputwave::Vector, outputwave::Vector)\n\nThe scattering matrix is defined as outputwave = S * inputwave.\n\nExamples\n\njulia> inputwave=[1.0,0.0];outputwave=[im/sqrt(2), 1/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S\n2×2 Matrix{ComplexF64}:\n      0.0+0.707107im  0.0+0.0im\n 0.707107+0.0im       0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcsources-NTuple{10, Any}","page":"Reference","title":"JosephsonCircuits.calcsources","text":"calcsources(modes, sources, portindices, portnumbers, nodeindices,\n    edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)\n\nCalculate the source terms in the branch basis. See also addsources!.\n\nExamples\n\nmodes = [(0,), (1,)]\nsources = [(mode = (0,), port = 1, current = 0.0005), (mode = (1,), port = 1, current = 1.0e-10)]\nportindices = [1]\nportnumbers = [1]\nnodeindices = [2 2 2 2 0 2 3 4 3 3; 1 1 1 1 0 3 4 1 1 1]\nedge2indexdict = Dict((1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (4, 1) => 3, (2, 1) => 1, (1, 4) => 3, (3, 4) => 4, (4, 3) => 4)\nLmean = 1.005e-9 + 0.0im\nNnodes = 4\nNbranches = 4\nNmodes = 2\nJosephsonCircuits.calcsources(modes, sources, portindices, portnumbers,\n    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)\n\n# output\n8-element Vector{ComplexF64}:\n     1526.863796602709 + 0.0im\n 0.0003053727593205418 + 0.0im\n                   0.0 + 0.0im\n                   0.0 + 0.0im\n                   0.0 + 0.0im\n                   0.0 + 0.0im\n                   0.0 + 0.0im\n                   0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcspicesortperms-Tuple{Dict{String, Vector{String}}}","page":"Reference","title":"JosephsonCircuits.calcspicesortperms","text":"calcspicesortperms(variabledict::Dict{String,Vector{String}})\n\nCalculate the sortperms which will sort the variable and node names.\n\nExamples\n\njulia> JosephsonCircuits.calcspicesortperms(Dict(\"V\" => [\"v(1)\", \"v(2)\", \"v(3)\"], \"Hz\" => [\"frequency\"]))\nDict{String, Vector{Int64}} with 2 entries:\n  \"V\"  => [1, 2, 3]\n  \"Hz\" => [1]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcvaluetype-Tuple{Vector{Symbol}, Vector, Vector{Symbol}}","page":"Reference","title":"JosephsonCircuits.calcvaluetype","text":"calcvaluetype(componenttypes::Vector{Symbol},componentvalues::Vector,\n    components::Vector{Symbol};checkinverse::Bool=true)\n\nReturns a zero length vector with the (computer science) type which will hold a set of circuit components of the (electrical engineering) types given in components. This function is not type stable by design, but exists to make the later function calls type stable.\n\nArguments\n\ncomponenttypes::Vector{Symbol}: the component (electrical engineering) types.\ncomponentvalues::Vector: the component values.\ncomponents::Vector{Symbol}: find a (computer science) type which will   hold the component (electrical engineering) types in this vector.\n\nKeywords\n\ncheckinverse = true: also check the inverse of each element. This is   useful if the type would be integer but we later want to take the inverse   and want an array with a type that supports this operation.\n\nExamples\n\njulia> JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3],[:R])\nFloat64[]\n\njulia> JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3+0.0im],[:R])\nComplexF64[]\n\njulia> @variables R1 C1 R2;JosephsonCircuits.calcvaluetype([:R,:C,:R],[R1,C1,R2],[:R])\nNum[]\n\njulia> @syms R1 C1 R2;JosephsonCircuits.calcvaluetype([:R,:C,:R],[R1,C1,R2],[:R])\nSymbolicUtils.BasicSymbolic{Number}[]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcw!-Tuple{Any, AbstractVector, Any, AbstractVector}","page":"Reference","title":"JosephsonCircuits.calcw!","text":"calcw!(ws, i, wp, w)\n\nGenerate the signal and idler frequencies using the formula ws + 2iwp. Overwrites w with output. \n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.calcw-Tuple{Any, Integer, Any}","page":"Reference","title":"JosephsonCircuits.calcw","text":"calcw(ws::Number, i::Integer, wp::Number)\n\nGenerate the signal and idler frequencies using the formula ws + 2iwp\n\nShould I switch this to ws+i*wp so it can handle three wave mixing then  always double i for four wave mixing?\n\nExamples\n\njulia> JosephsonCircuits.calcw(2*pi*4.0e9,-1,2*pi*5.0e9)/(2*pi*1.0e9)\n-5.999999999999999\n\njulia> JosephsonCircuits.calcw(2*pi*4.0e9,[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)\n3-element Vector{Float64}:\n -5.999999999999999\n  4.0\n 14.0\n\njulia> JosephsonCircuits.calcw([2*pi*4.0e9,2*pi*4.1e9],[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)\n2×3 Matrix{Float64}:\n -6.0  4.0  14.0\n -5.9  4.1  14.1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.checkcomponenttypes-Tuple{Vector{String}}","page":"Reference","title":"JosephsonCircuits.checkcomponenttypes","text":"checkcomponenttypes(allowedcomponents::Vector{String})\n\nCheck that each element in allowedcomponents is found at the correct place. This will detect the case where a two letter component appears in  allowedcomponents after a one letter component with the same starting letter. parsecomponenttype() will match on the first value and this function will throw an error.\n\nExamples\n\njulia> JosephsonCircuits.checkcomponenttypes([\"Lj\",\"L\",\"C\",\"K\",\"I\",\"R\",\"P\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.checkissymbolic-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.checkissymbolic","text":"checkissymbolic(a)\n\nCheck if a is a symbolic variable. Define a function to do this because a different function call is required for @syms vs @variables.\n\nExamples\n\njulia> @syms w;JosephsonCircuits.checkissymbolic(w)\ntrue\n\njulia> JosephsonCircuits.checkissymbolic(1.0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.checkissymbolic-Tuple{Num}","page":"Reference","title":"JosephsonCircuits.checkissymbolic","text":"checkissymbolic(a::Num)\n\nCheck if a is a symbolic variable.\n\nExamples\n\njulia> @variables w;JosephsonCircuits.checkissymbolic(w)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.comparestruct-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.comparestruct","text":"comparestruct(x,y)\n\nCompare two structures for testing purposes.\n\nExamples\n\njulia> JosephsonCircuits.comparestruct(JosephsonCircuits.warmupnumericmatrices(),JosephsonCircuits.warmupnumericmatrices())\ntrue\n\njulia> JosephsonCircuits.comparestruct(JosephsonCircuits.warmup(),JosephsonCircuits.warmup())\ntrue\n\njulia> JosephsonCircuits.comparestruct(nothing,nothing)\ntrue\n\njulia> JosephsonCircuits.compare(nothing,nothing)\ntrue\n\njulia> cg = JosephsonCircuits.CircuitGraph(Dict((1, 2) => 1, (3, 1) => 2, (1, 3) => 2, (2, 1) => 1), JosephsonCircuits.SparseArrays.sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], JosephsonCircuits.Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2);JosephsonCircuits.compare(cg,cg)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.componentdictionaries-Tuple{Vector{Symbol}, Matrix{Int64}, Dict, Vector{String}}","page":"Reference","title":"JosephsonCircuits.componentdictionaries","text":"componentdictionaries(componenttypes::Vector{Symbol},\n    nodeindexarray::Matrix{Int}, componentnamedict::Dict,\n    mutualinductorbranchnames::Vector)\n\nExamples\n\n@variables Ipump Rleft L1 K1 L2 C2 C3\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",K1))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\npush!(circuit,(\"C3\",\"2\",\"0\",C3))\npsc = parsesortcircuit(circuit)\ncountdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)\n\nprintln(countdict)\nprintln(indexdict)\n\n# output\nDict((:L, 1, 3) => 1, (:K, 4, 6) => 1, (:R, 1, 2) => 1, (:I, 1, 2) => 1, (:P, 1, 2) => 1, (:C, 1, 3) => 2, (:L, 1, 2) => 1)\nDict((:C, 1, 3, 1) => 7, (:I, 1, 2, 1) => 2, (:R, 1, 2, 1) => 3, (:L, 1, 3, 1) => 6, (:C, 1, 3, 2) => 8, (:L, 1, 2, 1) => 4, (:P, 1, 2, 1) => 1, (:K, 4, 6, 1) => 5)\n\n@variables Ipump Rleft L1 K1 K2 L2 C2 C3\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",K1))\npush!(circuit,(\"K2\",\"L1\",\"L2\",K2))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\npush!(circuit,(\"C3\",\"2\",\"0\",C3))\npsc = parsesortcircuit(circuit)\ncountdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)\n\nprintln(countdict)\nprintln(indexdict)\n\n# output\nDict((:L, 1, 3) => 1, (:K, 4, 7) => 2, (:R, 1, 2) => 1, (:I, 1, 2) => 1, (:P, 1, 2) => 1, (:C, 1, 3) => 2, (:L, 1, 2) => 1)\nDict((:C, 1, 3, 1) => 8, (:I, 1, 2, 1) => 2, (:R, 1, 2, 1) => 3, (:K, 4, 7, 1) => 5, (:K, 4, 7, 2) => 6, (:L, 1, 2, 1) => 4, (:L, 1, 3, 1) => 7, (:P, 1, 2, 1) => 1, (:C, 1, 3, 2) => 9)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.componentvaluestonumber-Tuple{Vector, Dict}","page":"Reference","title":"JosephsonCircuits.componentvaluestonumber","text":"componentvaluestonumber(componentvalues::Vector,circuitdefs::Dict)\n\nConvert the array of component values to numbers, if defined in circuitdefs.  This function is not type stable by design because we want the output array  to use a concrete type if all of the values are evaluated to numbers. \n\nExamples\n\njulia> JosephsonCircuits.componentvaluestonumber([:Lj1,:Lj2],Dict(:Lj1=>1e-12,:Lj2=>2e-12))\n2-element Vector{Float64}:\n 1.0e-12\n 2.0e-12\n\njulia> @variables Lj1 Lj2;JosephsonCircuits.componentvaluestonumber([Lj1,Lj1+Lj2],Dict(Lj1=>1e-12,Lj2=>2e-12))\n2-element Vector{Float64}:\n 1.0e-12\n 3.0e-12\n\n# define a frequency dependent impedance function\nZfun(w,R) = ifelse(w>10,R,100*R);\n# create symbolic variables including a two argument function\n@variables w R\n@register_symbolic Zfun(w,R)\n# substitute in numerical values and functions for everything but w\nout=JosephsonCircuits.componentvaluestonumber([R,Zfun(w,R)],Dict(R=>50));\nprintln(out)\n# evaluate with w = 2\nprintln(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=>2),)))\n# evaluate with w = 11\nprintln(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=>11),)))\n\n# output\nAny[50, Zfun(w, 50)]\n[50, 5000]\n[50, 50]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.conjnegfreq!-Tuple{SparseArrays.SparseMatrixCSC, Vector}","page":"Reference","title":"JosephsonCircuits.conjnegfreq!","text":"conjnegfreq!(A, wmodes)\n\nTake the complex conjugate of any element of A which would be negative when multipled from the right by a diagonal matrix consisting of wmodes replicated along the diagonal. Overwrite A with the output. \n\nEach axis of A should be an integer multiple of the length of wmodes.\n\nExamples\n\njulia> A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq!(A,[-1,1]);A\n2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:\n 1-1im  1+1im\n 1-1im  1+1im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.conjnegfreq-Tuple{SparseArrays.SparseMatrixCSC, Vector}","page":"Reference","title":"JosephsonCircuits.conjnegfreq","text":"conjnegfreq(A, wmodes)\n\nTake the complex conjugate of any element of A which would be negative when multipled from the right by a diagonal matrix consisting of wmodes replicated along the diagonal.\n\nEach axis of A should be an integer multiple of the length of wmodes.\n\nExamples\n\njulia> A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq(A,[-1,1])\n2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:\n 1-1im  1+1im\n 1-1im  1+1im\n\njulia> A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1im,1im,1im,1im],2,2);all(A*JosephsonCircuits.LinearAlgebra.Diagonal([-1,1]) .== JosephsonCircuits.conjnegfreq(A,[-1,1]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.conjsym-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Reference","title":"JosephsonCircuits.conjsym","text":"conjsym(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})\n\nCalculate the conjugate symmetries in the multi-dimensional frequency domain data.\n\nExamples\n\njulia> JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,)))\nDict{CartesianIndex{1}, CartesianIndex{1}}()\n\njulia> JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,)))\nDict{CartesianIndex{1}, CartesianIndex{1}} with 2 entries:\n  CartesianIndex(2,) => CartesianIndex(5,)\n  CartesianIndex(3,) => CartesianIndex(4,)\n\njulia> JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1)))\nDict{CartesianIndex{2}, CartesianIndex{2}} with 2 entries:\n  CartesianIndex(1, 2) => CartesianIndex(1, 3)\n  CartesianIndex(3, 2) => CartesianIndex(3, 3)\n\njulia> JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,1)))\nDict{CartesianIndex{2}, CartesianIndex{2}} with 7 entries:\n  CartesianIndex(2, 3) => CartesianIndex(5, 2)\n  CartesianIndex(2, 1) => CartesianIndex(5, 1)\n  CartesianIndex(3, 3) => CartesianIndex(4, 2)\n  CartesianIndex(3, 1) => CartesianIndex(4, 1)\n  CartesianIndex(2, 2) => CartesianIndex(5, 3)\n  CartesianIndex(1, 2) => CartesianIndex(1, 3)\n  CartesianIndex(3, 2) => CartesianIndex(4, 3)\n\njulia> JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1,1)))\nDict{CartesianIndex{3}, CartesianIndex{3}} with 8 entries:\n  CartesianIndex(1, 2, 1) => CartesianIndex(1, 3, 1)\n  CartesianIndex(1, 2, 3) => CartesianIndex(1, 3, 2)\n  CartesianIndex(1, 2, 2) => CartesianIndex(1, 3, 3)\n  CartesianIndex(3, 2, 1) => CartesianIndex(3, 3, 1)\n  CartesianIndex(1, 1, 2) => CartesianIndex(1, 1, 3)\n  CartesianIndex(3, 2, 3) => CartesianIndex(3, 3, 2)\n  CartesianIndex(3, 2, 2) => CartesianIndex(3, 3, 3)\n  CartesianIndex(3, 1, 2) => CartesianIndex(3, 1, 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.connectS!-Tuple{Any, Any, Any, Int64, Int64}","page":"Reference","title":"JosephsonCircuits.connectS!","text":"connectS!(Sout,Sx,Sy,k,l)\n\nSee connectS for description.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.connectS!-Tuple{Any, Any, Int64, Int64}","page":"Reference","title":"JosephsonCircuits.connectS!","text":"connectS!(Sout,Sx,k::Int,l::Int)\n\nSee connectS for description.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.connectS-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}, Int64, Int64}} where {T, N}","page":"Reference","title":"JosephsonCircuits.connectS","text":"connectS(Sx::Array{T,N},Sy::Array{T,N},k::Int,l::Int)\n\nConnect port k' on anmport network, represented by the scattering parameter matrixSx, to portlon annport network, represented by the scattering parameter matrixSy, resulting in a single(m-2)` port network, as illustrated below:\n\nInput network:\n\n  m |        | k+1                       | 2\n    |        |                           |\n    |   ...  |                     ...   |\n    |________|                  _________|________\n    |        |                  |        |       1\n    |   Sx   |                  |   Sy   |\n    |  m x m |                  |  n x n |\n____|________|__________________|________|\n1   |   ...     k           l   |   ...  |\n    |                           |        |\n    |                           |        |\n  2 |                       l+1 |        | n\n\nOutput network:\n\nm-1 |        | k      | m+1    \n    |        |        |        \n    |   ...  |   ...  |        \n    |________|________|________\n    |                 |     m  \n    |        S        |        \n    |  m+n-2 x m+n-2  |        \n____|_________________|        \n1   |   ...  |   ...  |        \n    |        |        |        \n    |        |        |        \n  2 |        |        |  m+n-2 \n            m-1+l\n\nArguments\n\nSx::Array: Array of scattering parameters representing the first network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).\nSy::Array: Array of scattering parameters representing the second network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).\nk::Int: Port on first network, with one based indexing.\nl::Int: Port on second network, with one based indexing.\n\nReferences\n\nHaifang Liao and Wayne Wei-Ming Dai, \"Capturing Time-of-flight Delay For Transient Analysis Based On Scattering Parameter Macromodel,\" IEEE/ACM International Conference on Computer-Aided Design, San Jose, CA, USA, 1994, pp. 412-417, doi: 10.1109/ICCAD.1994.629836.\n\nR. C. Compton, \"Perspectives in microwave circuit analysis,\" Proceedings of the 32nd Midwest Symposium on Circuits and Systems, Champaign, IL, USA, 1989, pp. 716-718 vol.2, doi: 10.1109/MWSCAS.1989.101955.\n\nG. Filipsson, \"A New General Computer Algorithm for S-Matrix Calculation of Interconnected Multiports,\" 1981 11th European Microwave Conference, Amsterdam, Netherlands, 1981, pp. 700-704, doi: 10.1109/EUMA.1981.332972.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.connectS-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Int64, Int64}} where {T, N}","page":"Reference","title":"JosephsonCircuits.connectS","text":"connectS(Sx::Array{T,N},k::Int,l::Int)\n\nConnect ports k' andlon the samemport microwave network represented by the scattering parameter matrixSx, resulting in an(m-2)` port scattering parameter matrix, as illustrated below:\n\nInput network:\n\n  m |         | l+1    \n    |   ...   |         l\n    |_________|__________ \n    |         |          |\n    |   Sx    |  ...     |\n    |  m x m  |          |\n____|_________|_____ k+1 |\n1   |   ...   |          |\n    |         | k        |\n  2 |         |__________|\n\nOutput network:\n\nm-2 |         | l-1     \n    |         |         \n    |   ...   |         \n    |_________|         \n    |         |         \n    |    S    |  ...    \n    |m-2 x m-2|         \n____|_________|_________\n1   |   ...         k   \n    |                   \n    |                   \n  2 |\n\nArguments\n\nSx::Array: Array of scattering parameters representing the network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).\nk::Int: First port to connect, with one based indexing.\nl::Int: Second port to connect, with one based indexing.\n\nReferences\n\nHaifang Liao and Wayne Wei-Ming Dai, \"Capturing Time-of-flight Delay For Transient Analysis Based On Scattering Parameter Macromodel,\" IEEE/ACM International Conference on Computer-Aided Design, San Jose, CA, USA, 1994, pp. 412-417, doi: 10.1109/ICCAD.1994.629836.\n\nR. C. Compton, \"Perspectives in microwave circuit analysis,\" Proceedings of the 32nd Midwest Symposium on Circuits and Systems, Champaign, IL, USA, 1989, pp. 716-718 vol.2, doi: 10.1109/MWSCAS.1989.101955.\n\nG. Filipsson, \"A New General Computer Algorithm for S-Matrix Calculation of Interconnected Multiports,\" 1981 11th European Microwave Conference, Amsterdam, Netherlands, 1981, pp. 700-704, doi: 10.1109/EUMA.1981.332972.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.diagrepeat!-Tuple{Any, Any, Integer}","page":"Reference","title":"JosephsonCircuits.diagrepeat!","text":"diagrepeat!(out, A, counts::Integer)\n\nOverwrite out with the elements of A duplicated counts times along the diagonal.\n\nExamples\n\njulia> A = [1 2;3 4];out = zeros(eltype(A),4,4);JosephsonCircuits.diagrepeat!(out,A,2);out\n4×4 Matrix{Int64}:\n 1  0  2  0\n 0  1  0  2\n 3  0  4  0\n 0  3  0  4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.diagrepeat-Tuple{AbstractArray, Integer}","page":"Reference","title":"JosephsonCircuits.diagrepeat","text":"diagrepeat(A::Matrix, counts::Integer)\n\nReturn a matrix with each element of A duplicated along the diagonal counts times.\n\nExamples\n\njulia> JosephsonCircuits.diagrepeat([1 2;3 4],2)\n4×4 Matrix{Int64}:\n 1  0  2  0\n 0  1  0  2\n 3  0  4  0\n 0  3  0  4\n\njulia> JosephsonCircuits.diagrepeat([1,2],2)\n4-element Vector{Int64}:\n 1\n 1\n 2\n 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.diagrepeat-Tuple{LinearAlgebra.Diagonal, Integer}","page":"Reference","title":"JosephsonCircuits.diagrepeat","text":"diagrepeat(A::Diagonal, counts::Integer)\n\nReturn a diagonal matrix with each element of A duplicated along the diagonal counts times.\n\nExamples\n\njulia> JosephsonCircuits.diagrepeat(JosephsonCircuits.LinearAlgebra.Diagonal([1,2]),2)\n4×4 LinearAlgebra.Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  2  ⋅\n ⋅  ⋅  ⋅  2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseMatrixCSC, Integer}","page":"Reference","title":"JosephsonCircuits.diagrepeat","text":"diagrepeat(A::SparseMatrixCSC, counts::Integer)\n\nReturn a sparse matrix with each element of A duplicated along the diagonal  counts times.\n\nExamples\n\njulia> JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,1,2,2], [1,2,1,2], [1,2,3,4],2,2),2)\n4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n 1  ⋅  2  ⋅\n ⋅  1  ⋅  2\n 3  ⋅  4  ⋅\n ⋅  3  ⋅  4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseVector, Integer}","page":"Reference","title":"JosephsonCircuits.diagrepeat","text":"diagrepeat(A::SparseVector, counts::Integer)\n\nReturn a sparse vector with each element of A duplicated along the diagonal  counts times.\n\nExamples\n\njulia> JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparsevec([1,2],[1,2]),2)\n4-element SparseArrays.SparseVector{Int64, Int64} with 4 stored entries:\n  [1]  =  1\n  [2]  =  1\n  [3]  =  2\n  [4]  =  2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.edge2index-Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}}","page":"Reference","title":"JosephsonCircuits.edge2index","text":"edge2index(graph::Graphs.SimpleDiGraph{Int})\n\nGenerate a dictionary where the tuple of nodes defining an edge of a graph is the key and the value is an index. The index gives the order the edge is found when iterating over the edges of the graph. The same index is used for both orderings of source and destination nodes on the edge. We don't care about the ordering of the indices as long as they are sequential and unique.\n\nExamples\n\njulia> JosephsonCircuits.edge2index(JosephsonCircuits.Graphs.path_digraph(4))\nDict{Tuple{Int64, Int64}, Int64} with 6 entries:\n  (3, 2) => 2\n  (1, 2) => 1\n  (2, 1) => 1\n  (3, 4) => 3\n  (4, 3) => 3\n  (2, 3) => 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.exportnetlist-Tuple{Vector, Dict}","page":"Reference","title":"JosephsonCircuits.exportnetlist","text":"exportnetlist(circuit::Vector,circuitdefs::Dict,port::Int = true,\n    jj::Bool = true)\n\nExamples\n\n@variables R Cc Lj Cj I\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",R),\n    (\"C1\",\"1\",\"2\",Cc),\n    (\"Lj1\",\"2\",\"0\",Lj),\n    (\"C2\",\"2\",\"0\",Cj)]\n\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    R => 50.0)\n\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)\nprintln(\"\")\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)\n\n# output\n* SPICE Simulation\nR1 1 0 50.0\nC1 1 2 100.0f\nB1 2 0 3 jjk ics=0.32910597599999997u\nC2 2 0 674.18508376f\n.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9\n\n* SPICE Simulation\nR1 1 0 50.0\nC1 1 2 100.0f\nLj1 2 0 1000.0000000000001p\nC2 2 0 1000.0f\n\n@variables R Cc L1 L2 Cj1 Cj2 I1 V1\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",R),\n    (\"C1\",\"1\",\"2\",Cc),\n    (\"L1\",\"2\",\"0\",L1),\n    (\"L2\",\"2\",\"0\",L2),\n    (\"C2\",\"2\",\"0\",Cj1),\n    (\"C3\",\"2\",\"0\",Cj2),\n    (\"I1\",\"2\",\"0\",I1)]\n\ncircuitdefs = Dict(\n    L1 =>2000.0e-12,\n    L2 =>2000.0e-12,\n    Cc => 100.0e-15,\n    Cj1 => 500.0e-15,\n    Cj2 => 500.0e-15,\n    R => 50.0,\n    I1 =>0.1)\n\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)\nprintln(\"\")\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)\n\n# output\n* SPICE Simulation\nR1 1 0 50.0\nC1 1 2 100.0f\nL1 2 0 1000.0000000000001p\nC2 2 0 1000.0f\n\n* SPICE Simulation\nR1 1 0 50.0\nC1 1 2 100.0f\nL1 2 0 1000.0000000000001p\nC2 2 0 1000.0f\n\n@variables Rleft L1 K1 L2 C2 C3 Lj1\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",K1))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\npush!(circuit,(\"C3\",\"2\",\"0\",C3))\ncircuitdefs = Dict(\n    Rleft => 50.0,\n    L1 => 1000.0e-12,\n    Lj1 => 1000.0e-12,\n    K1 => 0.1,\n    L2 => 1000.0e-12,\n    C2 => 1000.0e-15,\n    C3 => 1000.0e-15)\n\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)\nprintln(\"\")\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)\n\n# output\n* SPICE Simulation\nR1 1 0 50.0\nL1 1 0 1000.0000000000001p\nB1 2 0 3 jjk ics=0.32910597599999997u\nC2 2 0 1674.18508376f\nK1 L1 L2 0.1\nL2 2 0 1000.0000000000001p\n.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9\n\n* SPICE Simulation\nR1 1 0 50.0\nL1 1 0 1000.0000000000001p\nLj1 2 0 1000.0000000000001p\nK1 L1 L2 0.1\nL2 2 0 1000.0000000000001p\nC2 2 0 2000.0f\n\n@variables Rleft L1 K1 L2 C2 C3 Lj1\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj1))\npush!(circuit,(\"K1\",\"L2\",\"L1\",K1))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\npush!(circuit,(\"C3\",\"2\",\"0\",C3))\ncircuitdefs = Dict(\n    Rleft => 50.0,\n    L1 => 1000.0e-12,\n    Lj1 => 1000.0e-12,\n    K1 => 0.1,\n    L2 => 1000.0e-12,\n    C2 => 1000.0e-15,\n    C3 => 1000.0e-15)\n\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)\nprintln(\"\")\nprintln(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)\n\n# output\n* SPICE Simulation\nR1 1 0 50.0\nL1 1 0 1000.0000000000001p\nB1 2 0 3 jjk ics=0.32910597599999997u\nC2 2 0 1674.18508376f\nK1 L2 L1 0.1\nL2 2 0 1000.0000000000001p\n.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9\n\n* SPICE Simulation\nR1 1 0 50.0\nL1 1 0 1000.0000000000001p\nLj1 2 0 1000.0000000000001p\nK1 L2 L1 0.1\nL2 2 0 1000.0000000000001p\nC2 2 0 2000.0f\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.extractbranches!-Tuple{Vector, Vector{Symbol}, Matrix{Int64}}","page":"Reference","title":"JosephsonCircuits.extractbranches!","text":"extractbranches!(branchvector::Vector,componenttypes::Vector{Symbol},\n    nodeindexarray::Matrix{Int})\n\nAppend tuples consisting of a pair of node indices (branches) which we will use to calculate the incidence matrix.  Appends the tuples to branchvector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}","page":"Reference","title":"JosephsonCircuits.extractbranches","text":"extractbranches(componenttypes::Vector{Symbol},nodeindexarray::Matrix{Int})\n\nReturn an array of tuples of pairs of node indices (branches) which we will use to calculate the incidence matrix.  \n\nThis will contain duplicates if multiple components are on the same branch. All checking for duplicate branches will occur in the graph procesing code.\n\nNOTE: the list of component types considered to lie on branches is hardcoded.\n\nExamples\n\njulia> JosephsonCircuits.extractbranches([:P,:I,:R,:C,:Lj,:C],[2 2 2 2 3 3; 1 1 1 3 1 1])\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 1)\n (2, 1)\n (3, 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.factorklu!-Tuple{JosephsonCircuits.FactorizationCache, SparseArrays.SparseMatrixCSC}","page":"Reference","title":"JosephsonCircuits.factorklu!","text":"factorklu!(cache::FactorizationCache, A::SparseMatrixCSC)\n\nFactor the sparse matrix A using KLU and place the result in cache. Attempt to reuse the symbolic factorization. Redo the symbolic factorization if we get a SingularException.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.findgroundnodeindex-Tuple{Vector{String}}","page":"Reference","title":"JosephsonCircuits.findgroundnodeindex","text":"findgroundnodeindex(uniquenodevector::Vector{String})\n\nFind the index of the ground node.\n\nExamples\n\njulia> JosephsonCircuits.findgroundnodeindex([\"1\",\"0\",\"2\"])\n2\n\njulia> JosephsonCircuits.findgroundnodeindex([\"1\",\"2\"])\n0\n\njulia> JosephsonCircuits.findgroundnodeindex(String[])\n0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}","page":"Reference","title":"JosephsonCircuits.fourierindices","text":"fourierindices(freq::Frequencies)\n\nGenerate the indices used in the RDFT or DFT and inverse RDFT or DFT and converting between a node flux vector for solving system and the matrices for the Fourier analysis. See also FourierIndices, Frequencies, calcfreqsrdft and calcfreqsdft.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.freqsubst-Tuple{SparseArrays.SparseMatrixCSC, Vector, Any}","page":"Reference","title":"JosephsonCircuits.freqsubst","text":"freqsubst(A::SparseMatrixCSC, wmodes::Vector, symfreqvar)\n\nSubstitute the frequency dependent elements of A using the vector of mode frequencies wmodes and the symbolic frequency variable symfreqvar. Returns a sparse matrix with type Complex{Float64}.\n\nExamples\n\n@variables w\nwmodes = [-1,2];\nA = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,2*w,3*w],2,2),2);\nJosephsonCircuits.freqsubst(A,wmodes,w)\n\n# output\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:\n -1.0+0.0im      ⋅      -3.0+0.0im      ⋅    \n      ⋅      2.0+0.0im       ⋅      6.0+0.0im\n      ⋅          ⋅      -2.0+0.0im      ⋅    \n      ⋅          ⋅           ⋅      4.0+0.0im\n\nwmodes = [-1,2];\nA = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,3],2,2),2);\nJosephsonCircuits.freqsubst(A,wmodes,nothing)\n\n# output\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:\n 1.0+0.0im      ⋅      3.0+0.0im      ⋅    \n     ⋅      1.0+0.0im      ⋅      3.0+0.0im\n     ⋅          ⋅      2.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅      2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.frequencyscale-Tuple{String}","page":"Reference","title":"JosephsonCircuits.frequencyscale","text":"frequencyscale(frequencyunit::String)\n\nExamples\n\njulia> JosephsonCircuits.frequencyscale(\"MHz\")\n1.0e6\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K","page":"Reference","title":"JosephsonCircuits.hblinsolve","text":"hblinsolve(w, circuit,circuitdefs; Nmodulationharmonics = (0,),\n    nonlinear=nothing, symfreqvar=nothing, threewavemixing=false,\n    fourwavemixing=true, maxintermodorder=Inf,\n    nbatches::Integer = Base.Threads.nthreads(), returnS = true,\n    returnSnoise = false, returnQE = true, returnCM = true,\n    returnnodeflux = false, returnnodefluxadjoint = false,\n    returnvoltage = false,\n    )\n\nHarmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around pump, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones).\n\nArguments\n\nw:\ncircuit:\ncircuitdefs:\n\nKeywords\n\nNmodulationharmonics = (0,):\nnonlinear=nothing:\nsymfreqvar=nothing:\nthreewavemixing=false:\nfourwavemixing=true:\nmaxintermodorder=Inf:\nnbatches::Integer = Base.Threads.nthreads():\nreturnS = true:\nreturnSnoise = false:\nreturnQE = true:\nreturnCM = true:\nreturnnodeflux = false:\nreturnnodefluxadjoint = false:\nreturnvoltage = false:\n\nReturns\n\nLinearizedHB: A simple structure to hold the harmonic balance solutions.   See LinearizedHB.\n\nExamples\n\ncircuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",:Lm)) \npush!(circuit,(\"K1\",\"L1\",\"L2\",:K1))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc)) \npush!(circuit,(\"L2\",\"2\",\"3\",:Lm)) \npush!(circuit,(\"Lj3\",\"3\",\"0\",:Lj)) \npush!(circuit,(\"Lj4\",\"2\",\"0\",:Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\ncircuitdefs = Dict{Symbol,Complex{Float64}}(\n    :Lj =>2000e-12,\n    :Lm =>10e-12,\n    :Cc => 200.0e-15,\n    :Cj => 900e-15,\n    :Rleft => 50.0,\n    :Rright => 50.0,\n    :K1 => 0.9,\n)\n\nIdc = 1e-6*0\nIp=5.0e-6\nwp=2*pi*5e9\nws=2*pi*5.2e9\nsymfreqvar = nothing\n\n# modulation settings\nNpumpharmonics = (16,)\nNmodulationharmonics = (2,)\nthreewavemixing=false\nfourwavemixing=true\n\nnonlinear=hbnlsolve(\n    (wp,),\n    Npumpharmonics,\n    [\n        (mode=(0,),port=1,current=Idc),\n        (mode=(1,),port=1,current=Ip),\n    ],\n    circuit,circuitdefs;dc=true,odd=fourwavemixing,even=threewavemixing)\n\nlinearized = JosephsonCircuits.hblinsolve(ws,\n    circuit, circuitdefs; Nmodulationharmonics = Nmodulationharmonics,\n    nonlinear = nonlinear, symfreqvar=nothing, threewavemixing=false,\n    fourwavemixing=true, returnnodeflux=true, keyedarrays = Val(false))\nisapprox(linearized.nodeflux,\n    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],\n    atol = 1e-6)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{N}, Tuple{Any, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, Any, JosephsonCircuits.Frequencies{N}}} where {N, K}","page":"Reference","title":"JosephsonCircuits.hblinsolve","text":"hblinsolve(w, psc::ParsedSortedCircuit,\n    cg::CircuitGraph, circuitdefs, signalfreq::Frequencies{N};\n    nonlinear=nothing, symfreqvar=nothing,\n    nbatches::Integer = Base.Threads.nthreads(), returnS = true,\n    returnSnoise = false, returnQE = true, returnCM = true,\n    returnnodeflux = false, returnnodefluxadjoint = false,\n    returnvoltage = false,\n    )\n\nHarmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around pump, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones).\n\nExamples\n\ncircuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",:Lm)) \npush!(circuit,(\"K1\",\"L1\",\"L2\",:K1))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc)) \npush!(circuit,(\"L2\",\"2\",\"3\",:Lm)) \npush!(circuit,(\"Lj3\",\"3\",\"0\",:Lj)) \npush!(circuit,(\"Lj4\",\"2\",\"0\",:Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\ncircuitdefs = Dict{Symbol,Complex{Float64}}(\n    :Lj =>2000e-12,\n    :Lm =>10e-12,\n    :Cc => 200.0e-15,\n    :Cj => 900e-15,\n    :Rleft => 50.0,\n    :Rright => 50.0,\n    :K1 => 0.9,\n)\n\nIdc = 1e-6*0\nIp = 5.0e-6\nwp = 2*pi*5e9\nws = 2*pi*5.2e9\nNpumpharmonics = (2,)\nNmodulationharmonics = (2,)\nthreewavemixing = false\nfourwavemixing = true\n\nfrequencies = JosephsonCircuits.removeconjfreqs(\n    JosephsonCircuits.truncfreqs(\n        JosephsonCircuits.calcfreqsrdft(Npumpharmonics),\n        dc = true, odd = true, even = false, maxintermodorder = Inf,\n    )\n)\nfi = JosephsonCircuits.fourierindices(frequencies)\nNmodes = length(frequencies.modes)\npsc = JosephsonCircuits.parsesortcircuit(circuit)\ncg = JosephsonCircuits.calccircuitgraph(psc)\nnm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)\nnonlinear = hbnlsolve(\n    (wp,),\n    [\n        (mode=(0,),port=1,current=Idc),\n        (mode=(1,),port=1,current=Ip),\n    ],\n    frequencies, fi, psc, cg, nm)\nsignalfreq =JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsdft(Nmodulationharmonics),\n    dc = true, odd = threewavemixing, even = fourwavemixing,\n    maxintermodorder = Inf,\n)\nlinearized = JosephsonCircuits.hblinsolve(ws, psc, cg, circuitdefs,\n    signalfreq;nonlinear = nonlinear, returnnodeflux=true, keyedarrays = Val(false))\nisapprox(linearized.nodeflux,\n    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],\n    atol = 1e-6)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hblinsolve_inner!-NTuple{40, Any}","page":"Reference","title":"JosephsonCircuits.hblinsolve_inner!","text":"hblinsolve_inner!(S, Snoise, QE, CM, nodeflux, voltage, Asparse,\n    AoLjnm, invLnm, Cnm, Gnm, bnm,\n    AoLjnmindexmap, invLnmindexmap, Cnmindexmap, Gnmindexmap,\n    Cnmfreqsubstindices, Gnmfreqsubstindices, invLnmfreqsubstindices,\n    portindices, portimpedanceindices, noiseportimpedanceindices,\n    portimpedances, noiseportimpedances, nodeindices, componenttypes,\n    w, indices, wp, Nmodes, Nnodes, symfreqvar, wi)\n\nSolve the linearized harmonic balance problem for a subset of the frequencies given by wi. This function is thread safe in that different frequencies can be computed in parallel on separate threads.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K","page":"Reference","title":"JosephsonCircuits.hblinsolveold","text":"hblinsolveold(w, circuit, circuitdefs; wp = 0.0, Nmodes = 1,\n    Am = zeros(Complex{Float64},0,0), symfreqvar = nothing,\n    nbatches = Base.Threads.nthreads(), sorting = :number, returnS = true,\n    returnSnoise = false, returnQE = true, returnCM = true,\n    returnnodeflux = false, returnvoltage = false)\n\nLinearized harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.\n\nReturns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.\n\nArguments\n\nw: signal frequency or vector of signal frequencies in radians/second.\ncircuit: vector of tuples containing component names, nodes, and values. \ncircuitdefs: dictionary defining the numerical values of circuit components.\n\nKeywords\n\nwp = 0.0: pump frequency in radians/second. This function only supports a   single pump frequency.\nNmodes = 1: number of signal and idler modes.\nAm = zeros(Complex{Float64},0,0): \nsymfreqvar = nothing: symbolic frequency variable which is set to nothing   by default but should be set equal to the frequency variable like w if    there is frequency dependence.\nnbatches = Base.Threads.nthreads(): for the linearized harmonic balance   solution, split the solutions for different frequencies into this many   batches. Set equal to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. \nsorting = :number: sort the ports by turning them into integers and   sorting those integers. See sortnodes for other options if this   fails.\nreturnS = true: if true, return the scattering parameters for each set   of ports and signal and idler frequencies.\nreturnSnoise = false: if true, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. \nreturnQE = true: if true, return the quantum efficiency for each signal   and idler at each combinaton of ports.\nreturnCM = true: if true, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).\nreturnnodeflux = false: if true, return the node fluxes for each signal   and idler at each node. Set to false by default to reduce memory usage.\nreturnnodefluxadjoint = false: if true, return the node fluxes adjoint   for each signal and idler at each node. Set to false by default to   reduce memory usage.\nreturnvoltage = false: if true, return the node voltages for each signal   and idler at each node. Set to false by default to reduce memory usage. \n\nExamples\n\n@variables Rleft Cc Lj Cj w L1\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    Rleft => 50.0,\n)\nw = 2*pi*(4.5:0.01:5.0)*1e9\nresult=JosephsonCircuits.hblinsolveold(w, circuit, circuitdefs)\nusing Plots;plot(w/(2*pi*1e9),angle.(result.S[:]))\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbmatind-Union{Tuple{JosephsonCircuits.Frequencies{N}}, Tuple{N}} where N","page":"Reference","title":"JosephsonCircuits.hbmatind","text":"hbmatind(truncfrequencies::Frequencies{N})\n\nReturns a matrix describing which indices of the frequency domain matrix (from the RFFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.\n\nExamples\n\njulia> freq = JosephsonCircuits.calcfreqsrdft((5,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=2)))[2]\n3×3 Matrix{Int64}:\n 1  -3  -5\n 3   1  -3\n 5   3   1\n\njulia> freq = JosephsonCircuits.calcfreqsrdft((3,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]\n4×4 Matrix{Int64}:\n 1  -2  -3  -4\n 2   1  -2  -3\n 3   2   1  -2\n 4   3   2   1\n\njulia> freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[1]\n7×7 Matrix{Tuple{Int64, Int64}}:\n (0, 0)   (-1, 0)  (-2, 0)   (0, -1)  (-1, -1)  (0, -2)  (-1, 1)\n (1, 0)   (0, 0)   (-1, 0)   (1, -1)  (0, -1)   (1, -2)  (0, 1)\n (2, 0)   (1, 0)   (0, 0)    (2, -1)  (1, -1)   (2, -2)  (1, 1)\n (0, 1)   (-1, 1)  (-2, 1)   (0, 0)   (-1, 0)   (0, -1)  (-1, 2)\n (1, 1)   (0, 1)   (-1, 1)   (1, 0)   (0, 0)    (1, -1)  (0, 2)\n (0, 2)   (-1, 2)  (-2, 2)   (0, 1)   (-1, 1)   (0, 0)   (-1, 3)\n (1, -1)  (0, -1)  (-1, -1)  (1, -2)  (0, -2)   (1, -3)  (0, 0)\n\njulia> freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]\n7×7 Matrix{Int64}:\n  1   -2   -3  13   -5  10  -14\n  2    1   -2  14   13  11    4\n  3    2    1  15   14  12    5\n  4  -14  -15   1   -2  13  -11\n  5    4  -14   2    1  14    7\n  7  -11  -12   4  -14   1    0\n 14   13   -5  11   10   0    1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbmatind-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, JosephsonCircuits.Frequencies{N}}} where N","page":"Reference","title":"JosephsonCircuits.hbmatind","text":"hbmatind(frequencies::Frequencies{N},\n    truncfrequencies::Frequencies{N})\n\nReturns a matrix describing which indices of the frequency domain matrix (from the RFFT or FFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.\n\nExamples\n\npumpfreq = JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsrdft((4,)))\nsignalfreq = JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsdft((4,));\n    dc=false,odd=true,even=false,maxintermodorder=2,\n)\nJosephsonCircuits.hbmatind(pumpfreq, signalfreq)[2]\n\n# output\n4×4 Matrix{Int64}:\n  1  -3  5   3\n  3   1  0   5\n -5   0  1  -3\n -3  -5  3   1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}","page":"Reference","title":"JosephsonCircuits.hbnlsolve","text":"hbnlsolve(w::NTuple{N,Any}, sources, frequencies::Frequencies{N},\n    indices::FourierIndices{N}, psc::ParsedSortedCircuit, cg::CircuitGraph,\n    nm::CircuitMatrices; iterations = 1000, x0 = nothing,\n    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,\n    symfreqvar = nothing)\n\nNew version of the nonlinear harmonic balance solver suitable for arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor.\n\nExamples\n\ncircuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",:Lm)) \npush!(circuit,(\"K1\",\"L1\",\"L2\",:K1))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc)) \npush!(circuit,(\"L2\",\"2\",\"3\",:Lm)) \npush!(circuit,(\"Lj3\",\"3\",\"0\",:Lj)) \npush!(circuit,(\"Lj4\",\"2\",\"0\",:Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\ncircuitdefs = Dict{Symbol,Complex{Float64}}(\n    :Lj =>2000e-12,\n    :Lm =>10e-12,\n    :Cc => 200.0e-15,\n    :Cj => 900e-15,\n    :Rleft => 50.0,\n    :Rright => 50.0,\n    :K1 => 0.9,\n)\n\nIdc = 50e-5\nIp=0.0001e-6\nwp=2*pi*5e9\nNharmonics = (2,)\nfrequencies = JosephsonCircuits.removeconjfreqs(\n    JosephsonCircuits.truncfreqs(\n        JosephsonCircuits.calcfreqsrdft(Nharmonics),\n        dc=true, odd=true, even=false, maxintermodorder=Inf,\n    )\n)\nfi = JosephsonCircuits.fourierindices(frequencies)\nNmodes = length(frequencies.modes)\npsc = JosephsonCircuits.parsesortcircuit(circuit)\ncg = JosephsonCircuits.calccircuitgraph(psc)\nnm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)\n\nout=hbnlsolve(\n    (wp,),\n    [\n        (mode=(0,),port=1,current=Idc),\n        (mode=(1,),port=1,current=Ip),\n    ],\n    frequencies, fi, psc, cg, nm)\nisapprox(out.nodeflux[:],\n    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],\n    atol = 1e-6)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Tuple{Vararg{Int64, N}}, Any, Any, Any}} where {N, K}","page":"Reference","title":"JosephsonCircuits.hbnlsolve","text":"hbnlsolve(w::NTuple{N,Any}, Nharmonics::NTuple{N,Int}, sources,\n    circuit, circuitdefs; iterations = 1000,\n    maxintermodorder = Inf, dc = false, odd = true, even = false,\n    x0 = nothing, ftol = 1e-8, switchofflinesearchtol = 1e-5,\n    alphamin = 1e-4, symfreqvar = nothing, sorting= :number)\n\nNew version of the nonlinear harmonic balance solver suitable for arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor.\n\nArguments\n\nw::NTuple{N,Any}:\nNharmonics::NTuple{N,Int}:\nsources:\ncircuit:\ncircuitdefs:\n\nKeywords\n\niterations = 1000:\nmaxintermodorder = Inf:\ndc = false:\nodd = true:\neven = false:\nx0 = nothing:\nftol = 1e-8:\nswitchofflinesearchtol = 1e-5:\nalphamin = 1e-4:\nsymfreqvar = nothing:\nsorting= :number:\n\nReturns\n\nNonlinearHB: A simple structure to hold the harmonic balance solutions.   See NonlinearHB.\n\nExamples\n\ncircuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",:Lm)) \npush!(circuit,(\"K1\",\"L1\",\"L2\",:K1))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc)) \npush!(circuit,(\"L2\",\"2\",\"3\",:Lm)) \npush!(circuit,(\"Lj3\",\"3\",\"0\",:Lj)) \npush!(circuit,(\"Lj4\",\"2\",\"0\",:Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\ncircuitdefs = Dict{Symbol,Complex{Float64}}(\n    :Lj =>2000e-12,\n    :Lm =>10e-12,\n    :Cc => 200.0e-15,\n    :Cj => 900e-15,\n    :Rleft => 50.0,\n    :Rright => 50.0,\n    :K1 => 0.9,\n)\n\nIdc = 50e-5\nIp=0.0001e-6\nwp=2*pi*5e9\nNpumpmodes = 2\nout=hbnlsolve(\n    (wp,),\n    (Npumpmodes,),\n    [\n        (mode=(0,),port=1,current=Idc),\n        (mode=(1,),port=1,current=Ip),\n    ],\n    circuit,circuitdefs;dc=true,odd=true,even=false)\nisapprox(out.nodeflux[:],\n    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],\n    atol = 1e-6)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbnlsolveold-Union{Tuple{K}, NTuple{5, Any}} where K","page":"Reference","title":"JosephsonCircuits.hbnlsolveold","text":"hbnlsolveold(wp, Ip, Nmodes, circuit, circuitdefs; ports = [1],\n    iterations = 1000, ftol = 1e-8, symfreqvar = nothing,\n    sorting = :number)\n\nNonlinear harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.\n\nArguments\n\nwp: pump frequency in radians/second. This function only supports a single   pump frequency.\nIp: pump current or vector of pump currents in amps. Length of Ip must   be equal to length of ports.\nNmodes: number of modes (harmonics).\ncircuit: vector of tuples containing component names, nodes, and values.\ncircuitdefs: dictionary defining the numerical values of circuit components.\n\nKeywords\n\nports = [1]: vector of drive port numbers. Default is a single drive at port 1.\niterations = 1000: number of iterations at which the nonlinear solver stops   even if convergence criteria not reached.\nftol = 1e-8: relative or absolute tolerance at which nonlinear solver stops   (whichever is reached first).\nsymfreqvar = nothing: symbolic frequency variable which is set to nothing   by default but should be set equal to the frequency variable like w if   there is frequency dependence.\nsorting = :number: sort the ports by turning them into integers and sorting   those integers. See sortnodes for other options if this fails.\n\nExamples\n\n@variables Rleft Cc Lj Cj w L1\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    Rleft => 50.0,\n)\nwp = 2*pi*4.75001*1e9\nIp = 0.00565e-6\nNmodes = 8\nhbnlsolve(wp, Ip, Nmodes, circuit, circuitdefs, ports=[1])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{Any, Any, Any, Int64, Int64, Any, Any}} where K","page":"Reference","title":"JosephsonCircuits.hbsolve","text":"hbsolve(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs;\n    pumpports = [1], iterations = 1000, ftol = 1e-8,\n    switchofflinesearchtol = 1e-5, alphamin = 1e-4,\n    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),\n    sorting = :number, returnS = true, returnSnoise = false,\n    returnQE = true, returnCM = true, returnnodeflux = false,\n    returnvoltage = false, returnnodefluxadjoint = false,\n    )\n\nCalls the new harmonic balance solvers, hbnlsolve and hblinsolve, which work for an arbitrary number of modes and ports), using an identical syntax to hbsolveold, which only supports four wave mixing processes involving single strong tone and an arbitrary number of tone in the linearized solver. This function is primarily for testing the new solvers and will eventually be deprecated.\n\nThis function attempts to mimic hbsolveold, but with the difference: The outputs of the linearized harmonic balance solver hblinsolve may not have the same ordering of signal modes as in hblinsolveold. In hblinsolve the signal mode is always at index 1 and the location of the other modes can be found by inspecting the contents of modes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{M}, Tuple{N}, Tuple{Any, Tuple{Vararg{Any, N}}, Vector, Tuple{Vararg{Any, M}}, Tuple{Vararg{Any, N}}, Any, Any}} where {N, M, K}","page":"Reference","title":"JosephsonCircuits.hbsolve","text":"hbsolve(ws, wp::NTuple{N,Any}, sources::Vector,\n    Nmodulationharmonics::NTuple{M,Any}, Npumpharmonics::NTuple{N,Any},\n    circuit, circuitdefs; dc = false, threewavemixing = false,\n    fourwavemixing = true, maxintermodorder=Inf, iterations = 1000,\n    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,\n    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),\n    sorting = :number, returnS = true, returnSnoise = false,\n    returnQE = true, returnCM = true, returnnodeflux = false,\n    returnvoltage = false, returnnodefluxadjoint = false,\n    returnvoltageadjoint = false, keyedarrays::Val{K} = Val(true),\n    sensitivitynames = String[], returnSsensitivity = false,\n    returnZ = false, returnZadjoint = false,\n    returnZsensitivity = false, returnZsensitivityadjoint = false)\n\nArguments\n\nws:\nwp::NTuple{N,Any}:\nsources::Vector:\nNmodulationharmonics::NTuple{M,Any}:\nNpumpharmonics::NTuple{N,Any}:\ncircuit:\ncircuitdefs:\n\nKeywords\n\ndc = false:\nthreewavemixing = false:\nfourwavemixing = true:\nmaxintermodorder=Inf:\niterations = 1000:\nftol = 1e-8:\nswitchofflinesearchtol = 1e-5:\nalphamin = 1e-4:\nsymfreqvar = nothing:\nnbatches = Base.Threads.nthreads():\nsorting = :number:\nreturnS = true:\nreturnSnoise = false:\nreturnQE = true:\nreturnCM = true:\nreturnnodeflux = false:\nreturnvoltage = false:\nreturnnodefluxadjoint = false:\nreturnvoltageadjoint = false:\nkeyedarrays::Val{K} = Val(true):\nsensitivitynames = String[]:\nreturnSsensitivity = false:\nreturnZ = false:\nreturnZadjoint = false:\nreturnZsensitivity = false:\nreturnZsensitivityadjoint = false:\n\nReturns\n\nHB: A simple structure to hold the harmonic balance solutions. See   HB.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K","page":"Reference","title":"JosephsonCircuits.hbsolveold","text":"hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs;\n    pumpports = [1], iterations = 1000, ftol = 1e-8,\n    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),\n    sorting = :number, returnS = true, returnSnoise = false,\n    returnQE = true, returnCM = true, returnnodeflux = false,\n    returnvoltage = false)\n\nHarmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.\n\nReturns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.\n\nArguments\n\nws: signal frequency or vector of signal frequencies in radians/second.\nwp: pump frequency in radians/second. This function only supports a single   pump frequency.\nIp: pump current or vector of pump currents in amps. Length of Ip must   be equal to length of pumpports.\nNsignalmodes: number of signal and idler modes.\nNpumpmodes: number of pump modes (pump harmonics).\ncircuit: vector of tuples containing component names, nodes, and values.\ncircuitdefs: dictionary defining the numerical values of circuit components.\n\nKeywords\n\npumpports = [1]: vector of pump port numbers. Default is a single pump at   port 1.\niterations = 1000: number of iterations at which the nonlinear solver   stops even if convergence criteria not reached. \nftol = 1e-8: relative or absolute tolerance at which nonlinear solver   stops (whichever is reached first).\nsymfreqvar = nothing: symbolic frequency variable which is set to   nothing by default but should be set equal to the frequency variable   like w if there is frequency dependence.\nnbatches = Base.Threads.nthreads(): for the linearized harmonic balance   solution,split the solutions for different frequencies into this many   batches. Set equalt to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. \nsorting = :number: sort the ports by turning them into integers and   sorting those integers. See sortnodes for other options if this   fails.\nreturnS = true: if true, return the scattering parameters for each set   of ports and signal and idler frequencies.\nreturnSnoise = false: if true, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. \nreturnQE = true: if true, return the quantum efficiency for each signal   and idler at each combinaton of ports.\nreturnCM = true: if true, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).\nreturnnodeflux = false: if true, return the node fluxes for each signal   and idler at each node. Set to false by default to reduce memory usage.\nreturnnodefluxadjoint = false: if true, return the node fluxes adjoint   for each signal and idler at each node. Set to false by default to   reduce memory usage.\nreturnvoltage = false: if true, return the node voltages for each signal   and idler at each node. Set to false by default to reduce memory usage.\n\nExamples\n\n@variables Rleft Cc Lj Cj w L1\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    Rleft => 50.0,\n)\nws = 2*pi*(4.5:0.01:5.0)*1e9\nwp = 2*pi*4.75001*1e9\nIp = 0.00565e-6\nNsignalmodes = 8\nNpumpmodes = 8\nresult=JosephsonCircuits.hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs,pumpports=[1])\nusing Plots;plot(ws/(2*pi*1e9),10*log10.(abs2.(result.signal.S[result.signal.signalindex,result.signal.signalindex,:])))\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isbegininformation-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isbegininformation","text":"isbegininformation(line::String)\n\nReturn true if the string line is the [begin information] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isbegininformation(\"[begin information]\")\ntrue\n\njulia> JosephsonCircuits.isbegininformation(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isend-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isend","text":"isend(line::String)\n\nReturn true if the string line is the [end] line of a Touchstone file. \n\nExamples\n\njulia> JosephsonCircuits.isend(\"[end]\")\ntrue\n\njulia> JosephsonCircuits.isend(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isendinformation-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isendinformation","text":"isendinformation(line::String)\n\nReturn true if the string line is the [end information] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isendinformation(\"[end information]\")\ntrue\n\njulia> JosephsonCircuits.isendinformation(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.ismatrixformat-Tuple{String}","page":"Reference","title":"JosephsonCircuits.ismatrixformat","text":"ismatrixformat(line::String)\n\nReturn true if the string line is the [matrix format] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.ismatrixformat(\"[matrix format] full\")\ntrue\n\njulia> JosephsonCircuits.ismatrixformat(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.ismixedmodeorder-Tuple{String}","page":"Reference","title":"JosephsonCircuits.ismixedmodeorder","text":"ismixedmodeorder(line::String)\n\nReturn true if the string line is the [mixed-mode order] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.ismixedmodeorder(\"[mixed-mode order] full\")\ntrue\n\njulia> JosephsonCircuits.ismixedmodeorder(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isnetworkdata-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isnetworkdata","text":"isnetworkdata(line::String)\n\nReturn true if the string line is the [network data] line of a Touchstone file. \n\nExamples\n\njulia> JosephsonCircuits.isnetworkdata(\"[network data]\")\ntrue\n\njulia> JosephsonCircuits.isnetworkdata(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isnoisedata-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isnoisedata","text":"isnoisedata(line::String)\n\nReturn true if the string line is the [noise data] line of a Touchstone file. \n\nExamples\n\njulia> JosephsonCircuits.isnoisedata(\"[noise data]\")\ntrue\n\njulia> JosephsonCircuits.isnoisedata(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isnumberoffrequencies-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isnumberoffrequencies","text":"isnumberoffrequencies(line::String)\n\nReturn true if the string line is the [number of frequencies] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isnumberoffrequencies(\"[number of frequencies]\")\ntrue\n\njulia> JosephsonCircuits.isnumberoffrequencies(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isnumberofnoisefrequencies-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isnumberofnoisefrequencies","text":"isnumberofnoisefrequencies(line::String)\n\nReturn true if the string line is the [number of noise frequencies] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isnumberofnoisefrequencies(\"[number of noise frequencies]\")\ntrue\n\njulia> JosephsonCircuits.isnumberofnoisefrequencies(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isnumberofports-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isnumberofports","text":"isnumberofports(line::String)\n\nReturn true if the string line is the [number of ports] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isnumberofports(\"[number of ports] 1\")\ntrue\n\njulia> JosephsonCircuits.isnumberofports(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isoptionline-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isoptionline","text":"isoptionline(line::String)\n\nReturn true if the string line is the option line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isoptionline(\"# MHz Z MA R 75\")\ntrue\n\njulia> JosephsonCircuits.isoptionline(\"[number of ports] 1\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isreference-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isreference","text":"isreference(line::String)\n\nReturn true if the string line is the [reference] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isreference(\"[reference]\")\ntrue\n\njulia> JosephsonCircuits.isreference(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.istwoportdataorder-Tuple{String}","page":"Reference","title":"JosephsonCircuits.istwoportdataorder","text":"istwoportdataorder(line::String)\n\nReturn true if the string line is the [two-port data order] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.istwoportdataorder(\"[two-port data order] 12_21\")\ntrue\n\njulia> JosephsonCircuits.istwoportdataorder(\"[version] 1.0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.isversion-Tuple{String}","page":"Reference","title":"JosephsonCircuits.isversion","text":"isversion(line::String)\n\nReturn true if the string line is the [version] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.isversion(\"[version] 1.0\")\ntrue\n\njulia> JosephsonCircuits.isversion(\"[number of ports] 1\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N","page":"Reference","title":"JosephsonCircuits.keepfreqs","text":"keepfreqs(frequencies::Frequencies{N},\n    keepcoords::AbstractVector{CartesianIndex{N}})\n\nReturn a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.\n\nExamples\n\njulia> JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])\n\njulia> JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,)], [(0,)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N","page":"Reference","title":"JosephsonCircuits.keepfreqs","text":"keepfreqs(frequencies::Frequencies{N},\n    keepmodes::AbstractVector{NTuple{N,Int}})\n\nReturn a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.\n\nExamples\n\njulia> JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),[(0,0),(1,0),(0,1),(1,1)])\nJosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(1, 2), CartesianIndex(2, 2)], [(0, 0), (1, 0), (0, 1), (1, 1)])\n\njulia> JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),Tuple{Int64,Int64}[])\nJosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[], Tuple{Int64, Int64}[])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.linesearch-NTuple{4, Any}","page":"Reference","title":"JosephsonCircuits.linesearch","text":"linesearch(f, fp, dfdalpha, alphamin)\n\nQuadratic linesearch based on Nocedal and Wright, chapter 3 section 5. f is the value at the first point alpha=0.0, fp is the value at the second point, alpha=1.0, dfdalpha is the derivative at the first point, and alphamin is the minimum value of dfdalpha below which we will take a full step. The linesearch will return the fitted minimum of the function with respect to alpha as (alpha at which minimum occurs, minimum value of function).\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.matrixindices-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.matrixindices","text":"matrixindices(nports, format, twoportdataorder)\n\nReturn the cartesian indices of the elements of a scattering matrix given the number of ports nports and the format format which can be \"Full\", \"Upper\", or \"Lower\". The two port data order twoportdataorder can be \"12_21\" or \"21_12\" for 2 ports but must be \"12_21\" for other numbers of ports.\n\nExamples\n\njulia> JosephsonCircuits.matrixindices(2,\"Full\",\"12_21\")\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 1)\n CartesianIndex(2, 2)\n\njulia> JosephsonCircuits.matrixindices(2,\"Full\",\"21_12\")\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.matrixindices-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.matrixindices","text":"matrixindices(nports, format)\n\nReturn the cartesian indices of the elements of a scattering matrix given the number of ports nports and the format format which can be \"Full\", \"Upper\", or \"Lower\". \n\nExamples\n\njulia> JosephsonCircuits.matrixindices(2,\"Full\",printflag=true)\n11 12 \n21 22 \n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 1)\n CartesianIndex(2, 2)\n\njulia> JosephsonCircuits.matrixindices(2,\"Upper\",printflag=true)\n11 12 \n   22 \n      3-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\njulia> JosephsonCircuits.matrixindices(2,\"Lower\",printflag=true)\n11 \n21 22 \n3-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.networkdatatoarray-NTuple{10, Any}","page":"Reference","title":"JosephsonCircuits.networkdatatoarray","text":"networkdatatoarray(networkdata, numberofports, numberoffrequencies,\n    matrixformat, twoportdataorder, parameter, frequencyunit, format, R,\n    version)\n\nExamples\n\nnetworkdata = [4.0, 0.9995813511383583, -17.248815971093425, 4.5, 0.9958480363660398, -26.451285931791276, 5.0, 0.9868361175866559, 2.711906450972103, 5.5, 0.9985678550072272, -12.21545548845392, 6.0, 0.9993761539770525, -16.045248853866596]\nnumberofports = 1\nnumberoffrequencies = 5\nmatrixformat = \"Full\"\ntwoportdataorder = \"12_21\"\nparameter = \"s\"\nfrequencyunit = \"ghz\"\nformat = \"ma\"\nR = 50.0\nversion = 2.0\nfrequencies, N = JosephsonCircuits.networkdatatoarray(networkdata,\n    numberofports, numberoffrequencies, matrixformat, twoportdataorder,\n    parameter, frequencyunit, format, R, version)\nprintln(frequencies)\nprintln(N[1,1,:])\n\n# output\n[4.0e9, 4.5e9, 5.0e9, 5.5e9, 6.0e9]\nComplexF64[0.9546262517670427 - 0.296397700700921im, 0.8915960960938982 - 0.44358732281729774im, 0.9857309246425359 + 0.04669118949947016im, 0.9759591344506418 - 0.21128542054786678im, 0.9604441706426364 - 0.2762239892126382im]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.nlsolve!-Union{Tuple{T}, Tuple{Function, Vector{T}, SparseArrays.SparseMatrixCSC{T, Int64}, Vector{T}}} where T","page":"Reference","title":"JosephsonCircuits.nlsolve!","text":"nlsolve!(fj!, F, J::SparseMatrixCSC, x; iterations=1000, ftol=1e-8,\n    switchofflinesearchtol = 1e-5)\n\nA simple nonlinear solver for sparse matrices using Newton's method with linesearch based on Nocedal and Wright, chapter 3 section 5. A few points to note: (1) It uses KLU factorization, so only works on sparse matrices. (2) The Jacobian J cannot change sparsity structure. (3) This function attempts to reuse the symbolic factorization which can     sometimes result in a SingularException, which we catch, then create a     new factorization object.\n\nExamples\n\nfunction fj!(F, J, x)\n    if !isnothing(F)\n        F[1] = (x[1]+3)*(x[2]^3-7)+18\n        F[2] = sin(x[2]*exp(x[1])-1)\n    end\n    if !isnothing(J)\n        J[1, 1] = x[2]^3-7\n        J[1, 2] = 3*x[2]^2*(x[1]+3)\n        u = exp(x[1])*cos(x[2]*exp(x[1])-1)\n        J[2, 1] = x[2]*u\n        J[2, 2] = u\n    end\n    return nothing\nend\nx = [ 0.1, 1.2]\nF = [0.0, 0.0]\nJ = JosephsonCircuits.sparse([1, 1, 2, 2],[1, 2, 1, 2],[1.3, 0.5, 0.1, 1.2])\nJosephsonCircuits.nlsolve!(fj!, F, J, x)\nisapprox([0.0,1.0],x)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.nodevariabletokeyed-NTuple{6, Any}","page":"Reference","title":"JosephsonCircuits.nodevariabletokeyed","text":"nodevariabletokeyed(nodevariable, outputmodes, nodenames, inputmodes,\n    inputportnumbers, w)\n\nConvert a node variable array nodevariable (such as node flux or node voltage) vs frequency w to a keyed array. Return the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.nodevariabletokeyed([1 2;3 4;;;],[(0,),(1,)],[\"0\",\"1\"],[(0,),(1,)],[1],[1.0])\n5-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   outputmode ∈ 2-element Vector{Tuple{Int64}}\n→   node ∈ 1-element Vector{String}\n◪   inputmode ∈ 2-element Vector{Tuple{Int64}}\n▨   inputport ∈ 1-element Vector{Int64}\n▨   freqindex ∈ 1-element UnitRange{Int64}\nAnd data, 2×1×2×1×1 Array{Int64, 5}:\n[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):\n          (\"1\")\n   (0,)    1\n   (1,)    3\n\n[:, :, 2, 1, 1] ~ (:, :, (1,), 1, 1):\n          (\"1\")\n   (0,)    2\n   (1,)    4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.nodevariabletokeyed-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.nodevariabletokeyed","text":"nodevariabletokeyed(nodevariable, outputmodes, nodenames)\n\nConvert a node variable array nodevariable (such as node flux or node voltage) to a keyed array. Return the keyed array.\n\nExamples\n\njulia> JosephsonCircuits.nodevariabletokeyed([1 2;3 4],[(0,),(1,)],[\"0\",\"1\",\"2\"])\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n↓   outputmode ∈ 2-element Vector{Tuple{Int64}}\n→   node ∈ 2-element Vector{String}\nAnd data, 2×2 Matrix{Int64}:\n          (\"1\")  (\"2\")\n   (0,)    1      2\n   (1,)    3      4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.numericmatrices-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.numericmatrices","text":"numericmatrices(circuit, circuitdefs; Nmodes = 1, sorting = :number)\n\nReturn the numeric matrices describing the circuit properties.\n\nSee also CircuitMatrices, numericmatrices, calcCn, calcGn, calcLb,calcLjb, calcMb, calcinvLn, calcLmean, calcportindicesnumbers, calcportimpedanceindices, and calcnoiseportimpedanceindices.\n\nExamples\n\n@variables Ipump Rleft Cc Lj Cj\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\ncircuitdefs = Dict(Lj =>1000.0e-12,Cc => 100.0e-15,Cj => 1000.0e-15,Rleft => 50.0,Ipump => 1.0e-8)\nJosephsonCircuits.testshow(stdout,numericmatrices(circuit,circuitdefs))\n\n# output\nJosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])\n\n@variables Ipump Rleft Cc Lj Cj\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\ncircuitdefs = Dict(Lj =>1000.0e-12,Cc => 100.0e-15,Cj => 1000.0e-15,Rleft => 50.0,Ipump => 1.0e-8)\npsc = JosephsonCircuits.parsesortcircuit(circuit)\ncg = JosephsonCircuits.calccircuitgraph(psc)\nJosephsonCircuits.testshow(stdout,numericmatrices(psc, cg, circuitdefs))\n\n# output\nJosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsecircuit-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.parsecircuit","text":"parsecircuit(circuit)\n\nParse circuit which is a vector where each element contains a tuple with the component name, the first node, the second node, and the component value. Component values can be numbers, symbols, or symbolic variables (including symbolic functions).\n\nThe nodes can be arbitrary strings for SPICE compatibility. Integers are also supported but are converted internally to strings. The ground node is \"0\" and is required. Specifying the type of the vector circuit is optional; although, typically a vector with a type union is preferable to an array of type Any.\n\nArguments\n\ncircuit: vector of tuples each of which contain the component name, the   first node, the second node, and the component value.\n\nExamples\n\n@variables Ipump Rleft L1 K1 L2 C2\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",K1))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\n@variables Ipump Rleft L1 L2 C2\nKfun(L) = sin(L);@register_symbolic Kfun(L1)\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",Kfun(L1)))\npush!(circuit,(\"L2\",\"2\",\"0\",L2))\npush!(circuit,(\"C2\",\"2\",\"0\",C2))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\ncircuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",:Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc))\npush!(circuit,(\"Lj1\",\"2\",\"0\",:Lj))\npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], String[], [\"P1\", \"I1\", \"R1\", \"C1\", \"Lj1\", \"C2\"], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(\"I1\" => 2, \"C1\" => 4, \"C2\" => 6, \"R1\" => 3, \"P1\" => 1, \"Lj1\" => 5), 3)\n\ncircuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)\npush!(circuit,(\"P1\",\"One\",\"0\",1))\npush!(circuit,(\"I1\",\"One\",\"0\",:Ipump))\npush!(circuit,(\"R1\",\"One\",\"0\",:Rleft))\npush!(circuit,(\"C1\",\"One\",\"Two\",:Cc))\npush!(circuit,(\"Lj1\",\"Two\",\"0\",:Lj))\npush!(circuit,(\"C2\",\"Two\",\"0\",:Cj))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [\"One\", \"0\", \"Two\"], String[], [\"P1\", \"I1\", \"R1\", \"C1\", \"Lj1\", \"C2\"], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(\"I1\" => 2, \"C1\" => 4, \"C2\" => 6, \"R1\" => 3, \"P1\" => 1, \"Lj1\" => 5), 3)\n\ncircuit = []\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",:Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",:Cc))\npush!(circuit,(\"Lj1\",\"2\",\"0\",:Lj))\npush!(circuit,(\"C2\",\"2\",\"0\",:Cj))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], String[], [\"P1\", \"I1\", \"R1\", \"C1\", \"Lj1\", \"C2\"], [:P, :I, :R, :C, :Lj, :C], Any[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(\"I1\" => 2, \"C1\" => 4, \"C2\" => 6, \"R1\" => 3, \"P1\" => 1, \"Lj1\" => 5), 3)\n\ncircuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",:Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",:Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",:L1))\npush!(circuit,(\"K1\",\"L1\",\"L2\",:K1))\npush!(circuit,(\"L2\",\"2\",\"0\",:L2))\npush!(circuit,(\"C2\",\"2\",\"0\",:C2))\nparsecircuit(circuit)\n\n# output\nJosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [\"1\", \"0\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :L1, :K1, :L2, :C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsecomponenttype-Tuple{String, Vector{String}}","page":"Reference","title":"JosephsonCircuits.parsecomponenttype","text":"parsecomponenttype(name::String,allowedcomponents::Vector{String})\n\nThe first one or two characters of the component name in the string name should match one of the strings in the vector allowedcomponents. Return the  index first of the match found.\n\nNOTE: if a two letter component appears in allowedcomponents after a one  letter component with the same starting letter this function will match on the first value.\n\nExamples\n\njulia> JosephsonCircuits.parsecomponenttype(\"L10\",[\"Lj\",\"L\",\"C\",\"K\",\"I\",\"R\",\"P\"])\n2\n\njulia> [JosephsonCircuits.parsecomponenttype(c,[\"Lj\",\"L\",\"C\",\"K\",\"I\",\"R\",\"P\"]) for c in [\"Lj\",\"L\",\"C\",\"K\",\"I\",\"R\",\"P\"]]\n7-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\njulia> JosephsonCircuits.parsecomponenttype(\"L10\",[\"Lj\",\"L\",\"C\",\"K\",\"I\",\"R\",\"P\"])\n2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parseinformation!-Tuple{Vector{String}, Vector{String}, IO}","page":"Reference","title":"JosephsonCircuits.parseinformation!","text":"parseinformation!(information::Vector{String},io::IO)\n\nAppend the contents of the information section of a Touchstone file from the IOBuffer or IOStream io to the vector information.\n\nExamples\n\ninformation = String[]\ncomments = String[]\nio = IOBuffer(\"This is an information section.\n[End Information]\")\nJosephsonCircuits.parseinformation!(information,comments,io)\nprintln(information)\n\n# output\n[\"this is an information section.\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsematrixformat-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsematrixformat","text":"parsematrixformat(line::String)\n\nReturn the two-port data order string parsed from the [two-port data order] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parsematrixformat(\"[matrix format] lower\")\n\"Lower\"\n\njulia> JosephsonCircuits.parsematrixformat(\"[matrix format] upper\")\n\"Upper\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsemixedmodeorder!-Tuple{Vector{Tuple{Char, Vector{Int64}}}, String}","page":"Reference","title":"JosephsonCircuits.parsemixedmodeorder!","text":"parsemixedmodeorder!(mixedmodeorder::Vector{Tuple{Char, Vector{Int}}}, line::String)\n\nAppend the contents of the [mixed-mode order] line of a Touchstone file from the to the vector mixedmodeorder.\n\nExamples\n\njulia> mixedmodeorder = Tuple{Char, Vector{Int}}[];JosephsonCircuits.parsemixedmodeorder!(mixedmodeorder,\"[Mixed-Mode Order] D2,3 D6,5 C2,3 C6,5 S4 S1\");mixedmodeorder\n6-element Vector{Tuple{Char, Vector{Int64}}}:\n ('D', [2, 3])\n ('D', [6, 5])\n ('C', [2, 3])\n ('C', [6, 5])\n ('S', [4])\n ('S', [1])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsenetworkdata!-Tuple{Vector{Float64}, Vector{String}, IO}","page":"Reference","title":"JosephsonCircuits.parsenetworkdata!","text":"parsenetworkdata!(networkdata::Vector{Float64}, comments::Vector{String}, io::IO)\n\nAppend the contents of the networkdata section of a Touchstone file from the IOBuffer or IOStream io to the vector networkdata.\n\nExamples\n\nnetworkdata = Float64[]\ncomments = String[]\nio = IOBuffer(\"1.0000 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211\n2.0000 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054\n10.000 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nprintln(networkdata)\n\n# output\n[1.0, 0.3926, -0.1211, -0.0003, -0.0021, -0.0003, -0.0021, 0.3926, -0.1211, 2.0, 0.3517, -0.3054, -0.0096, -0.0298, -0.0096, -0.0298, 0.3517, -0.3054, 10.0, 0.3419, 0.3336, -0.0134, 0.0379, -0.0134, 0.0379, 0.3419, 0.3336]\n\nnetworkdata = Float64[]\ncomments = String[]\nio = IOBuffer(\"2 .95 -26 3.57 157 .04 76 .66 -14\n22 .60 -144 1.30 40 .14 40 .56 -85\n! NOISE PARAMETERS\n4 .7 .64 69 .38\n18 2.7 .46 -33 .40\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nprintln(networkdata)\n\n# output\n[2.0, 0.95, -26.0, 3.57, 157.0, 0.04, 76.0, 0.66, -14.0, 22.0, 0.6, -144.0, 1.3, 40.0, 0.14, 40.0, 0.56, -85.0]\n\nnetworkdata = Float64[]\ncomments = String[]\nio = IOBuffer(\"2 .95 -26 3.57 157 .04 76 .66 -14\n22 .60 -144 1.30 40 .14 40 .56 -85\n[Noise Data]\n4 .7 .64 69 19\n18 2.7 .46 -33 20\n[End]\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nprintln(networkdata)\n\n# output\n[2.0, 0.95, -26.0, 3.57, 157.0, 0.04, 76.0, 0.66, -14.0, 22.0, 0.6, -144.0, 1.3, 40.0, 0.14, 40.0, 0.56, -85.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsenoisedata!-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.parsenoisedata!","text":"parsenoisedata!(noisedata::Vector{Float64}, comments::Vector{String},\n    io::IO)\n\nAppend the contents of the networkdata section of a Touchstone file from the IOBuffer or IOStream io to the vector networkdata.\n\nExamples\n\nnetworkdata = Float64[]\nnoisedata = Float64[]\ncomments = String[]\nio = IOBuffer(\"1.0000 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211\n2.0000 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054\n10.000 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nJosephsonCircuits.parsenoisedata!(noisedata,comments,io)\nprintln(noisedata)\n\n# output\nFloat64[]\n\nnetworkdata = Float64[]\nnoisedata = Float64[]\ncomments = String[]\nio = IOBuffer(\"2 .95 -26 3.57 157 .04 76 .66 -14\n22 .60 -144 1.30 40 .14 40 .56 -85\n! NOISE PARAMETERS\n4 .7 .64 69 .38\n18 2.7 .46 -33 .40\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nJosephsonCircuits.parsenoisedata!(noisedata,comments,io)\nprintln(noisedata)\n\n# output\n[4.0, 0.7, 0.64, 69.0, 0.38, 18.0, 2.7, 0.46, -33.0, 0.4]\n\nnetworkdata = Float64[]\nnoisedata = Float64[]\ncomments = String[]\nio = IOBuffer(\"2 .95 -26 3.57 157 .04 76 .66 -14\n22 .60 -144 1.30 40 .14 40 .56 -85\n[Noise Data]\n4 .7 .64 69 19\n18 2.7 .46 -33 20\n[End]\")\nJosephsonCircuits.parsenetworkdata!(networkdata,comments,io)\nJosephsonCircuits.parsenoisedata!(noisedata,comments,io)\nprintln(noisedata)\n\n# output\n[4.0, 0.7, 0.64, 69.0, 19.0, 18.0, 2.7, 0.46, -33.0, 20.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsenumberoffrequencies-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsenumberoffrequencies","text":"parsenumberoffrequencies(line::String)\n\nReturn the number of frequencies parsed from the [number of frequencies] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parsenumberoffrequencies(\"[number of frequencies] 10\")\n10\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsenumberofnoisefrequencies-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsenumberofnoisefrequencies","text":"parsenumberofnoisefrequencies(line::String)\n\nReturn the number of noise frequencies parsed from the [number of noise frequencies] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parsenumberofnoisefrequencies(\"[number of noise frequencies] 10\")\n10\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsenumberofports-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsenumberofports","text":"parsenumberofports(line::String)\n\nReturn the number of ports parsed from the [number of ports] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parsenumberofports(\"[number of ports] 1\")\n1\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parseoptionline-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parseoptionline","text":"parseoptionline(line::String)\n\nReturn a struct TouchstoneOptionLine which contains the option line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parseoptionline(\"# MHz Z MA R 75\")\nJosephsonCircuits.TouchstoneOptionLine(\"MHz\", \"Z\", \"MA\", 75.0)\n\njulia> JosephsonCircuits.parseoptionline(\"# MHz H RI R 75\")\nJosephsonCircuits.TouchstoneOptionLine(\"MHz\", \"H\", \"RI\", 75.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsereference!-Tuple{Vector{Float64}, Vector{String}, String, Int64, IO}","page":"Reference","title":"JosephsonCircuits.parsereference!","text":"parsereference!(reference::Vector{Float64}, comments::Vector{String},\n    line::String, numberofports::Int, io::IO)\n\nAppend the contents of the [reference] section of a Touchstone file from the IOBuffer or IOStream io to the vector reference. The reference impedance values can be spread across multiple lines. \n\nExamples\n\nio = IOBuffer(\"[Reference] 50.0 60.0 75.0\")\nnumberofports = 3\ncomments = String[]\nreference = Float64[]\nline = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))\nJosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)\nprintln(reference)\n\n# output\n[50.0, 60.0, 75.0]\n\nio = IOBuffer(\"[Reference] 50.0 \n60.0 75.0\")\nnumberofports = 3\ncomments = String[]\nreference = Float64[]\nline = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))\nJosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)\nprintln(reference)\n\n# output\n[50.0, 60.0, 75.0]\n\nio = IOBuffer(\"[Reference] 50.0 \n60.0 75.0\n[Number of Frequencies] 1\")\nnumberofports = 3\ncomments = String[]\nreference = Float64[]\nline = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))\nJosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)\nprintln(reference)\n\n# output\n[50.0, 60.0, 75.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsesortcircuit-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.parsesortcircuit","text":"parsesortcircuit(circuit; sorting = :name)\n\nParse and sort the circuit. See parsecircuit, sortnodes for more explanation.\n\nArguments\n\ncircuit: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.\n\nKeywords\n\nsorting = :name: Sort the vector of strings. This always works but leads   to results like \"101\" comes before \"11\".\nsorting = :number: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).\nsorting = :none: Don't perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   circuit.\n\nExamples\n\n@variables Ipump Rleft Cc Lj Cj\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc))\npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj))\npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\nprintln(parsesortcircuit(circuit))\n\n# output\nJosephsonCircuits.ParsedSortedCircuit([2 2 2 2 3 3; 1 1 1 3 1 1], [\"0\", \"1\", \"2\"], String[], [\"P1\", \"I1\", \"R1\", \"C1\", \"Lj1\", \"C2\"], [:P, :I, :R, :C, :Lj, :C], Num[1, Ipump, Rleft, Cc, Lj, Cj], Dict(\"I1\" => 2, \"C1\" => 4, \"C2\" => 6, \"R1\" => 3, \"P1\" => 1, \"Lj1\" => 5), 3)\n\n@variables Ipump Rleft L1 L2 C2\nKfun(L) = sin(L);@register_symbolic Kfun(L1)\ncircuit = Tuple{String,String,String,Num}[]\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"L1\",\"1\",\"0\",L1)) \npush!(circuit,(\"K1\",\"L1\",\"L2\",Kfun(L1)))\npush!(circuit,(\"L2\",\"2\",\"0\",L2)) \npush!(circuit,(\"C2\",\"2\",\"0\",C2))\nprintln(parsesortcircuit(circuit))\n\n# output\nJosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [\"0\", \"1\", \"2\"], [\"L1\", \"L2\"], [\"P1\", \"I1\", \"R1\", \"L1\", \"K1\", \"L2\", \"C2\"], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(\"L1\" => 4, \"I1\" => 2, \"L2\" => 6, \"C2\" => 7, \"R1\" => 3, \"P1\" => 1, \"K1\" => 5), 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsespicevariable-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsespicevariable","text":"parsespicevariable(variable::String)\n\nParse a variable name string into the variable name and node number. Will this work with arbitrary node strings?\n\nExamples\n\njulia> JosephsonCircuits.parsespicevariable(\"V1(5)\")\n(\"V1\", 5)\n\njulia> JosephsonCircuits.parsespicevariable(\"V1\")\n(\"V\", 1)\n\njulia> JosephsonCircuits.parsespicevariable(\"V-1\")\n(\"V\", 1)\n\njulia> JosephsonCircuits.parsespicevariable(\"frequency\")\n(\"frequency\", \"frequency\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parsetwoportdataorder-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parsetwoportdataorder","text":"parsetwoportdataorder(line::String)\n\nReturn the two-port data order string parsed from the [two-port data order] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parsetwoportdataorder(\"[two-port data order] 12_21\")\n\"12_21\"\n\njulia> JosephsonCircuits.parsetwoportdataorder(\"[two-port data order] 21_12\")\n\"21_12\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.parseversion-Tuple{String}","page":"Reference","title":"JosephsonCircuits.parseversion","text":"parseversion(line::String)\n\nReturn the version parsed from the [version] line of a Touchstone file.\n\nExamples\n\njulia> JosephsonCircuits.parseversion(\"[version] 1.0\")\n1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.phimatrixtovector!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}","page":"Reference","title":"JosephsonCircuits.phimatrixtovector!","text":"phimatrixtovector!(phivector::Vector, phimatrix::Array,\n    indexmap::Vector{Int}, conjsourceindices::Vector{Int},\n    conjtargetindices::Vector{Int}, Nbranches::Int)\n\nThe harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts an array to a vector with the above properties.\n\nExamples\n\nfreqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]\nconjsourceindices = [16, 6]\nconjtargetindices = [21, 31]\nNbranches = 1\n\nphivector = zeros(Complex{Float64}, Nbranches*length(freqindexmap))\nphimatrix = [0.0 + 0.0im 0.0 + 3.0im 0.0 + 0.0im 0.0 + 6.0im 0.0 - 6.0im 0.0 + 0.0im 0.0 - 3.0im; 0.0 + 1.0im 0.0 + 0.0im 0.0 + 5.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 7.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 4.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 8.0im; 0.0 + 2.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;]\n\nJosephsonCircuits.phimatrixtovector!(phivector,\n    phimatrix,\n    freqindexmap,\n    conjsourceindices,\n    conjtargetindices,\n    Nbranches,\n)\nphivector\n\n# output\n8-element Vector{ComplexF64}:\n 0.0 + 1.0im\n 0.0 + 2.0im\n 0.0 + 3.0im\n 0.0 + 4.0im\n 0.0 + 5.0im\n 0.0 + 6.0im\n 0.0 + 7.0im\n 0.0 + 8.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.phivectortomatrix!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}","page":"Reference","title":"JosephsonCircuits.phivectortomatrix!","text":"phivectortomatrix!(phivector::AbstractVector,phimatrix::AbstractArray,\n    indexmap::Vector{Int},conjsourceindices::Vector{Int},\n    conjtargetindices::Vector{Int},Nbranches::Int)\n\nThe harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts a vector to an array with the above properties.\n\nExamples\n\nfreqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]\nconjsourceindices = [16, 6]\nconjtargetindices = [21, 31]\nNbranches = 1\n\nphivector = 1im.*Complex.(1:Nbranches*length(freqindexmap));\nphimatrix=zeros(Complex{Float64},5,7,1)\n\nJosephsonCircuits.phivectortomatrix!(phivector,\n    phimatrix,\n    freqindexmap,\n    conjsourceindices,\n    conjtargetindices,\n    Nbranches,\n)\nphimatrix\n\n# output\n5×7×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n 0.0+0.0im  0.0+3.0im  0.0+0.0im  0.0+6.0im  0.0-6.0im  0.0+0.0im  0.0-3.0im\n 0.0+1.0im  0.0+0.0im  0.0+5.0im  0.0+0.0im  0.0+0.0im  0.0+7.0im  0.0+0.0im\n 0.0+0.0im  0.0+4.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+8.0im\n 0.0+2.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T","page":"Reference","title":"JosephsonCircuits.plan_applynl","text":"plan_applynl(fd::Array{Complex{T}})\n\nCreates an empty time domain data array and the inverse and forward plans for the RFFT of an array of frequency domain data. See also applynl!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}","page":"Reference","title":"JosephsonCircuits.printsymmetries","text":"printsymmetries(freq::Frequencies)\n\nSee  printsymmetries.\n\nExamples\n\njulia> JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,)))\n3-element Vector{Int64}:\n 0\n 0\n 0\n\njulia> JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsdft((2,)))\n5-element Vector{Int64}:\n  0\n  1\n  2\n -2\n -1\n\njulia> JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,2)))\n3×5 Matrix{Int64}:\n 0  1  3  -3  -1\n 0  0  0   0   0\n 0  2  4  -4  -2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.printsymmetries-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Reference","title":"JosephsonCircuits.printsymmetries","text":"printsymmetries(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})\n\nPrint the conjugate symmetries in the multi-dimensional DFT or RDFT from the dimensions of the signal in the frequency domain and the time domain. Negative numbers indicate that element is the complex conjugate of the corresponding positive number. A zero indicates that element has no corresponding complex conjugate.\n\nExamples\n\njulia> JosephsonCircuits.printsymmetries((3,),(4,))\n3-element Vector{Int64}:\n 0\n 0\n 0\n\njulia> JosephsonCircuits.printsymmetries((4,),(4,))\n4-element Vector{Int64}:\n  0\n  1\n  0\n -1\n\njulia> JosephsonCircuits.printsymmetries((3,3),(4,3))\n3×3 Matrix{Int64}:\n 0  1  -1\n 0  0   0\n 0  2  -2\n\njulia> JosephsonCircuits.printsymmetries((4,3),(4,3))\n4×3 Matrix{Int64}:\n  0   2  -2\n  1   3   5\n  0   4  -4\n -1  -5  -3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, Any}","page":"Reference","title":"JosephsonCircuits.processnode","text":"processnode(uniquenodedict::Dict{String, Int},\n    uniquenodevector::Vector{String},node)\n\nReturn the node index when given a node. Add the node string to the vector uniquenodevector and the dictionary uniquenodedict with the node string as the key and the node index (index at which it appears in  uniquenodevector) as the value. If \"node\" is not a string, make it a string.\n\nExamples\n\nuniquenodedict = Dict(\"10\" =>1)\nuniquenodevector = [\"10\"]\nprintln(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,15))\nprintln(uniquenodevector)\nprintln(uniquenodedict)\n\n# output\n2\n[\"10\", \"15\"]\nDict(\"10\" => 1, \"15\" => 2)\n\nuniquenodedict = Dict(\"10\" =>1)\nuniquenodevector = [\"10\"]\nprintln(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,:A))\nprintln(uniquenodevector)\nprintln(uniquenodedict)\n\n# output\n2\n[\"10\", \"A\"]\nDict(\"A\" => 2, \"10\" => 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, String}","page":"Reference","title":"JosephsonCircuits.processnode","text":"processnode(uniquenodedict::Dict{String, Int},\n    uniquenodevector::Vector{String},node::String)\n\nReturn the node index when given a node. Add the node string to the vector uniquenodevector and the dictionary uniquenodedict with the node string as the key and the node index (index at which it appears in uniquenodevector) as the value.\n\nExamples\n\nuniquenodedict = Dict(\"10\" =>1)\nuniquenodevector = [\"10\"]\nprintln(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,\"15\"))\nprintln(uniquenodevector)\nprintln(uniquenodedict)\n\n# output\n2\n[\"10\", \"15\"]\nDict(\"10\" => 1, \"15\" => 2)\n\nuniquenodedict = Dict(\"10\" =>1)\nuniquenodevector = [\"10\"]\nprintln(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,\"10\"))\nprintln(uniquenodevector)\nprintln(uniquenodedict)\n\n# output\n1\n[\"10\"]\nDict(\"10\" => 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.pushval!-Tuple{Vector, Any, Any, Bool}","page":"Reference","title":"JosephsonCircuits.pushval!","text":"pushval!(V::Vector, val, c, invert::Bool)\n\nAppend the value val of capacitance or conductance to the vector V. Scale the value by c. If invert = true, append c/val otherwise append c*val.\n\nExamples\n\njulia> V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,false);V\n1-element Vector{Float64}:\n -2.0\n\njulia> V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,true);V\n1-element Vector{Float64}:\n -0.5\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.removeconjfreqs-Tuple{JosephsonCircuits.Frequencies}","page":"Reference","title":"JosephsonCircuits.removeconjfreqs","text":"removeconjfreqs(frequencies::Frequencies{N})\n\nReturn a new Frequencies struct with the conjugate symmetric terms in the DFT or RDFT removed.\n\nExamples\n\njulia> JosephsonCircuits.removeconjfreqs(JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)]))\nJosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])\n\njulia> frequencies = JosephsonCircuits.Frequencies{2}((2,2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3), CartesianIndex(1, 4), CartesianIndex(2, 4), CartesianIndex(3, 4), CartesianIndex(1, 5), CartesianIndex(2, 5), CartesianIndex(3, 5)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2), (0, -2), (1, -2), (2, -2), (0, -1), (1, -1), (2, -1)]);JosephsonCircuits.removeconjfreqs(frequencies).modes\n11-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (1, 0)\n (2, 0)\n (0, 1)\n (1, 1)\n (2, 1)\n (0, 2)\n (1, 2)\n (2, 2)\n (1, -2)\n (1, -1)\n\njulia> JosephsonCircuits.removeconjfreqs(JosephsonCircuits.calcfreqsrdft((2,2))).modes\n11-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (1, 0)\n (2, 0)\n (0, 1)\n (1, 1)\n (2, 1)\n (0, 2)\n (1, 2)\n (2, 2)\n (1, -2)\n (1, -1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N","page":"Reference","title":"JosephsonCircuits.removefreqs","text":"removefreqs(frequencies::Frequencies{N},\n    removecoords::AbstractVector{CartesianIndex{N}})\n\nReturn a new Frequency struct with the coordinates and modes for the modes in removemodes removed.\n\nExamples\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(2,), CartesianIndex(3,)], [(1,), (2,)])\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,),CartesianIndex(2,),CartesianIndex(3,),CartesianIndex(4,)])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N","page":"Reference","title":"JosephsonCircuits.removefreqs","text":"removefreqs(frequencies::Frequencies{N},\n    removemodes::AbstractVector{NTuple{N,Int}})\n\nReturn a new Frequency struct with the coordinates and modes for the modes in removemodes removed.\n\nExamples\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(2,)])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(0,),(1,),(2,),(3,)])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])\n\njulia> JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[])\nJosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.showstruct-Tuple{IO, Any}","page":"Reference","title":"JosephsonCircuits.showstruct","text":"showstruct(io::IO,out)\n\nExamples\n\njulia> JosephsonCircuits.testshow(stdout,JosephsonCircuits.warmupnumericmatrices())\nJosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [2], Int64[], 1.0e-9, Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])\n\njulia> JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.warmupsymsold())\n\njulia> JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.warmupsyms())\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sincosnl-Tuple{Matrix{ComplexF64}}","page":"Reference","title":"JosephsonCircuits.sincosnl","text":"sincosnl(am::Array{Complex{Float64},2})\n\nApplies the junction nonlinearity to a vector of Fourier coefficients of the phases across the junction of size 2*m by (Nnodes-1) where m is the number of pump harmonics (0w, 1w, 2w, 3w, etc). To save time, this calculates both the sine and cosine nonlinearities at the same time. If the input is odd harmonics, the sine terms will also be odd harmonics the cosine terms will be even harmonics.\n\nExamples\n\njulia> isapprox(JosephsonCircuits.sincosnl([0 0.001+0im;0 0]),ComplexF64[1.0 + 0.0im 1.000999499833375 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im])\ntrue\n\njulia> isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0;0 0;0 0; 0 0]), ComplexF64[0.99999900000025 + 0.0im 1.0 + 0.0im; 0.0009999995000000916 + 0.0im 0.0 + 0.0im; -4.999998333421463e-7 + 0.0im 0.0 + 0.0im; -1.6666664597909941e-10 + 0.0im 0.0 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0 + 0.0im])\ntrue\n\njulia> isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0.25+0im;0 0;0 0; 0 0]),ComplexF64[0.99999900000025 + 0.0im 0.9384698079924576 + 0.0im; 0.0009999995000000916 + 0.0im 0.24226844566945333 + 0.0im; -4.999998333421463e-7 + 0.0im -0.03060435952740681 + 0.0im; -1.6666664597909941e-10 + 0.0im -0.0025556763673518224 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0003214729527288296 + 0.0im])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sincosnloddtoboth-Tuple{Vector{ComplexF64}, Int64, Int64}","page":"Reference","title":"JosephsonCircuits.sincosnloddtoboth","text":"sincosnloddtoboth(amodd::Array{Complex{Float64},1},Nbranches::Int,m::Int)\n\nApplies the junction nonlinearity to a vector of branch fluxes of length Nbranches*m where m is the number of odd pump harmonics (1w, 3w, 5w, etc). The ordering is (mode 1, node 1), (mode 2, node 1) ... (mode 1, node 2) ... Returns even AND odd terms in a 2d array with dimensions 2*m by Nbranches.\n\nExamples\n\njulia> isapprox(JosephsonCircuits.sincosnloddtoboth([0.5+0.0im,0,0,0],1,4),ComplexF64[0.765197686557965 + 0.0im; 0.44005058574495276 + 0.0im; -0.11490348493140057 + 0.0im; -0.019563353994648498 + 0.0im; 0.0024766387010484486 + 0.0im; 0.0002497629794614272 + 0.0im; -2.084411456066653e-5 + 0.0im; -3.0046516347986037e-6 + 0.0im;;])\ntrue\n\njulia> isapprox(JosephsonCircuits.sincosnloddtoboth([0.02+0.0im,0,0.01+0.0im,0],2,2),ComplexF64[0.9996000399980445 + 0.0im 0.9999000024999694 + 0.0im; 0.019996000293322436 + 0.0im 0.009999500009166587 + 0.0im; -0.00019996666853328016 + 0.0im -4.999791669583568e-5 + 0.0im; -2.6664000106757513e-6 + 0.0im -3.3332500006440685e-7 + 0.0im])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}","page":"Reference","title":"JosephsonCircuits.sortnodes","text":"sortnodes(uniquenodevector::Vector{String},\n    nodeindexvector::Vector{Int};sorting=:name)\n\nSort the unique node names in uniquenodevector according to the specified sorting scheme, always placing the ground node at the beginning.\n\nReturn the sorted uniquenodevector and nodeindexvector (with the vector reshaped from a vector of length 2*Nnodes into a matrix with dimensions 2 by Nnodes).\n\nKeywords\n\nsorting = :name: Sort the vector of strings. This always works but leads   to results like \"101\" comes before \"11\".\nsorting = :number: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).\nsorting = :none: Don't perform any sorting except to place the ground node   first.\n\nExamples\n\njulia> nodenames,nodeindexarray=JosephsonCircuits.sortnodes([\"101\",\"0\",\"111\",\"11\"],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:none);println(nodenames);println(nodeindexarray);\n[\"0\", \"101\", \"111\", \"11\"]\n[2 2 2 2 3 3 4; 1 1 1 3 1 1 2]\n\njulia> nodenames,nodeindexarray=JosephsonCircuits.sortnodes([\"101\",\"0\",\"111\",\"11\"],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:name);println(nodenames);println(nodeindexarray);\n[\"0\", \"101\", \"11\", \"111\"]\n[2 2 2 2 4 4 3; 1 1 1 4 1 1 2]\n\njulia> nodenames,nodeindexarray=JosephsonCircuits.sortnodes([\"101\",\"0\",\"111\",\"11\"],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:number);println(nodenames);println(nodeindexarray);\n[\"0\", \"11\", \"101\", \"111\"]\n[3 3 3 3 4 4 2; 1 1 1 4 1 1 3]\n\njulia> nodenames,nodeindexarray=JosephsonCircuits.sortnodes([\"1\", \"0\", \"2\"],[1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],sorting=:number);println(nodenames);println(nodeindexarray);\n[\"0\", \"1\", \"2\"]\n[2 2 2 2 0 3 3; 1 1 1 1 0 1 1]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spaddkeepzeros-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Reference","title":"JosephsonCircuits.spaddkeepzeros","text":"spaddkeepzeros(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nAdd sparse matrices A and B and return the result, keeping any structural zeros, unlike the default Julia sparse matrix addition functions. \n\nExamples\n\njulia> A = JosephsonCircuits.SparseArrays.sprand(10,10,0.2); B = JosephsonCircuits.SparseArrays.sprand(10,10,0.2);JosephsonCircuits.spaddkeepzeros(A,B) == A+B\ntrue\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,0],2,2);\nB = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1],2,2);\nJosephsonCircuits.spaddkeepzeros(A,B)\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 2  0\n ⋅  3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, LinearAlgebra.Diagonal, SparseArrays.SparseMatrixCSC, Vector}","page":"Reference","title":"JosephsonCircuits.sparseadd!","text":"sparseadd!(A::SparseMatrixCSC, c::Number, Ad::Diagonal, As::SparseMatrixCSC,     indexmap::Vector)\n\nAdd sparse matrices A and c*Ad*As and return the result in A. The sparse matrix As must have nonzero entries only in a subset of the positions in A which have nonzero (structural zeros are ok) entries.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAd = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])\nAs = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)\nindexmap = JosephsonCircuits.sparseaddmap(A,As)\nJosephsonCircuits.sparseadd!(A,2,Ad,As,indexmap)\nA\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 7  5\n ⋅  2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Vector}","page":"Reference","title":"JosephsonCircuits.sparseadd!","text":"sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC, Ad::Diagonal,     indexmap)\n\nAdd sparse matrices A and c*As*Ad and return the result in A. The sparse matrix As must have nonzero entries only in a subset of the positions in A which have nonzero (structural zeros are ok) entries.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAs = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)\nAd = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])\nindexmap = JosephsonCircuits.sparseaddmap(A,As)\nJosephsonCircuits.sparseadd!(A,2,As,Ad,indexmap)\nA\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 7  -19\n ⋅    2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, Vector}","page":"Reference","title":"JosephsonCircuits.sparseadd!","text":"sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC, indexmap)\n\nAdd sparse matrices A and c*As and return the result in A. The sparse matrix As must have nonzero entries only in a subset of the positions in A which have nonzero (structural zeros are ok) entries.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAs = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)\nindexmap = JosephsonCircuits.sparseaddmap(A,As)\nJosephsonCircuits.sparseadd!(A,2,As,indexmap)\nA\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 7  5\n ⋅  2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}","page":"Reference","title":"JosephsonCircuits.sparseadd!","text":"sparseadd!(A::SparseMatrixCSC, As::SparseMatrixCSC, indexmap)\n\nAdd sparse matrices A and As and return the result in A without performing any allocations. This is only possible if the positions of elements in As are a subset of the positions of elements in A. The indexmap can be generated with sparseaddmap.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAs = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)\nindexmap = JosephsonCircuits.sparseaddmap(A,As)\nJosephsonCircuits.sparseadd!(A,As,indexmap)\nA\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 4  1\n ⋅  2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseaddconjsubst!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Any, LinearAlgebra.Diagonal, LinearAlgebra.Diagonal, Vector, Any}","page":"Reference","title":"JosephsonCircuits.sparseaddconjsubst!","text":"sparseaddconjsubst!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC,     Ad::Diagonal, indexmap, conjflag::Diagonal, wmodesm::Diagonal,     freqsubstindices::Vector, symfreqvar)\n\nPerform the operation A+c*As*Ad and return the result in A. Take the complex conjugate of As for any column where conjflag = true.\n\nThe sparse matrix As must have nonzero elements only in a subset of the  positions in A which has nonzero lements.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1.0+1.0im,2.0+1.0im,-3.0+0.0im],2,2)\nAd = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])\nAs = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3.0+2.0im,4.0+3.0im],2,2)\nwmodesm = JosephsonCircuits.LinearAlgebra.Diagonal([-1,1])\nindexmap = JosephsonCircuits.sparseaddmap(A,As)\nfreqsubstindices  = JosephsonCircuits.symbolicindices(As)\nJosephsonCircuits.sparseaddconjsubst!(A,2,As,Ad,indexmap,wmodesm .< 0,wmodesm,freqsubstindices,nothing)\nA\n\n# output\n2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 3 stored entries:\n 7.0-3.0im  -19.0-12.0im\n     ⋅        2.0+1.0im\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Reference","title":"JosephsonCircuits.sparseaddmap","text":"sparseaddmap(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturn a vector of length nnz(B) which maps the indices of elements of B in B.nzval to the corresponding indices in A.nzval. The sparse matrix B must have elements in a subset of the positions in A which have nonzero entries (structural zeros are elements).\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAs = JosephsonCircuits.SparseArrays.sparse([1], [2], [4],2,2)\nJosephsonCircuits.sparseaddmap(A,As)\n\n# output\n1-element Vector{Int64}:\n 2\n\nA = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)\nAs = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [4,2],2,2)\nJosephsonCircuits.sparseaddmap(A,As)\n\n# output\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spice_hb_load-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.spice_hb_load","text":"spice_hb_load(filename)\n\nLoad a Xyce harmonic balance simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spice_raw_load-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.spice_raw_load","text":"spice_raw_load(filename)\n\nParse the binary raw output file from WRSPICE or Xyce. Tested for transient analysis and frequency domain analysis. The file format is documented in the WRSPICE manual in Appendix 1, File Formats, A.1 Rawfile Format http://www.srware.com/xictools/docs/wrsmanual-4.3.13.pdf\n\nThe Xyce rawfile format is very similar and described in: https://xyce.sandia.gov/files/xyce/Reference_Guide.pdf#section.8.2\n\nThe function outputs a header, the times/frequencies, the currents, and the voltages. The voltage and current arrays have dimensions nVoltages by nPoints and nCurrents by nPoints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spice_run-Tuple{AbstractVector, Any}","page":"Reference","title":"JosephsonCircuits.spice_run","text":"spice_run(input::AbstractArray{String,1})\n\nIf the input to wrspice_run() is an array of strings, then call multiple processes in parallel. The number of parallel processes is decided from Threads.nthreads(). It can be changed manually.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spice_run-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.spice_run","text":"spice_run(input, spicecmd::String)\n\nArgument is a string or command containing the input commands for wrspice.  This function saves the string to disk, runs spice, parses the results with wrsplice_load(), then returns those parsed results.\n\nThe input should not should have a file name listed after the write command in the .control block so that we can specify the raw output file with a command line argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.spmatmul!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{Bool}}","page":"Reference","title":"JosephsonCircuits.spmatmul!","text":"spmatmul!(C::SparseMatrixCSC, A::SparseMatrixCSC, B::SparseMatrixCSC,\n    xb::Vector{Bool})\n\nNon-allocating sparse matrix multiplication of A and B when sparsity pattern of product C is known. Based on spmatmul from SparseArrays.jl https://github.com/JuliaSparse/SparseArrays.jl/blob/main/src/linalg.jl\n\nExamples\n\njulia> a = JosephsonCircuits.sprand(100,100,0.1);b = JosephsonCircuits.sprand(100,100,0.1);c = a*b; d = copy(c);xb = fill(false, size(a,1));JosephsonCircuits.spmatmul!(c,a,b,xb);c == d\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sprandsubset","page":"Reference","title":"JosephsonCircuits.sprandsubset","text":"sprandsubset(A::SparseMatrixCSC, p::AbstractFloat, dropzeros = true)\n\nGiven a sparse matrix A, return a sparse matrix with random values in some fraction of the non-zero elements with probability p. If dropzeros = false, then the zeros will be retained as structural zeros otherwise they are dropped.\n\nThis is used for testing non-allocating sparse matrix addition.\n\nExamples\n\nA = JosephsonCircuits.SparseArrays.sprand(2,2,0.5)\nB = JosephsonCircuits.sprandsubset(A, 0.1)\nlength(A.nzval) >= length(B.nzval)\n\n# output\ntrue\n\nA = JosephsonCircuits.SparseArrays.sprand(100,100,0.5)\nB = JosephsonCircuits.sprandsubset(A, 0.1)\nlength(A.nzval) >= length(B.nzval)\n\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#JosephsonCircuits.storeuniqueloops!-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.storeuniqueloops!","text":"storeuniqueloops!(lvarray, vmap, ul)\n\nExamples\n\njulia> lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],[[1,2,3]]);lvarray\n1-element Vector{Vector{Int64}}:\n [1, 2, 3]\n\njulia> lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],Vector{Int64}[]);lvarray\n1-element Vector{Vector{Int64}}:\n []\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.stripcommentslowercase!-Tuple{Vector{String}, String}","page":"Reference","title":"JosephsonCircuits.stripcommentslowercase!","text":"stripcommentslowercase!(comments::Vector{String},line::String)\n\nAppend the comment portion of a line line of a Touchstone file to the vector comments. Return the line with the comments removed and made lowercase. \n\nExamples\n\njulia> comments=String[];println(JosephsonCircuits.stripcommentslowercase!(comments,\"! This is a comment\"));println(comments)\n\n[\" This is a comment\"]\n\njulia> comments=String[];println(JosephsonCircuits.stripcommentslowercase!(comments,\"This is a !comment\"));println(comments)\nthis is a \n[\"comment\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sumbranchvalues!-Tuple{Symbol, Int64, Int64, Vector, Dict, Dict}","page":"Reference","title":"JosephsonCircuits.sumbranchvalues!","text":"sumbranchvalues!(type::Symbol, node1::Int, node2::Int,componentvalues::Vector,\n    countdict, indexdict)\n\nGiven a branch and a type, return the sum of all of the values of the same type and branch. The sum will behave differently depending on the type.\n\nExamples\n\nvvn = Real[1, 50.0, 1.0e-13, 2.0e-9, 2.0e-9, 5.0e-13, 5.0e-13, 0.1]\ncountdict = Dict((:L, 1, 3) => 2, (:R, 1, 2) => 1, (:P, 1, 2) => 1, (:C, 1, 3) => 2, (:C, 2, 3) => 1, (:I, 1, 3) => 1)\nindexdict = Dict((:C, 2, 3, 1) => 3, (:C, 1, 3, 1) => 6, (:R, 1, 2, 1) => 2, (:L, 1, 3, 1) => 4, (:C, 1, 3, 2) => 7, (:L, 1, 3, 2) => 5, (:P, 1, 2, 1) => 1, (:I, 1, 3, 1) => 8)\nprintln(JosephsonCircuits.sumbranchvalues!(:C, 1, 3, vvn, countdict, indexdict))\n\n# output\n(true, 1.0e-12, 6)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.sumvalues-Tuple{Symbol, Any, Any}","page":"Reference","title":"JosephsonCircuits.sumvalues","text":"sumvalues(type::Symbol, value1, value2)\n\nSum together two values in different ways depending on the circuit component type.\n\nExamples\n\njulia> JosephsonCircuits.sumvalues(:L, 1.0, 4.0)\n0.8\n\njulia> JosephsonCircuits.sumvalues(:Lj, 1.0, 4.0)\n0.8\n\njulia> JosephsonCircuits.sumvalues(:C, 1.0, 4.0)\n5.0\n\njulia> JosephsonCircuits.sumvalues(:K, 1.0, 4.0)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.symbolicindices-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.symbolicindices","text":"symbolicindices(A)\n\nReturn the indices in A.nzval where the elements of the matrix A are symbolic variables.\n\nExamples\n\njulia> @syms w;A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,1.0,3*w+1]);println(A.nzval);JosephsonCircuits.symbolicindices(A)\nAny[w, 1 + 3w, 1.0]\n2-element Vector{Int64}:\n 1\n 2\n\njulia> @variables w;A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,1.0,3*w+1]);println(A.nzval);JosephsonCircuits.symbolicindices(A)\nNum[w, 1 + 3w, 1.0]\n2-element Vector{Int64}:\n 1\n 2\n\njulia> A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,1.0,2+3im]);JosephsonCircuits.symbolicindices(A)\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.symbolicmatrices-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.symbolicmatrices","text":"symbolicmatrices(circuit; Nmodes = 1, sorting = :number)\n\nReturn the symbolic matrices describing the circuit properties.\n\nSee also  CircuitMatrices, numericmatrices, calcCn, calcGn, calcLb,calcLjb, calcMb, calcinvLn, calcLmean, calcportindicesnumbers, calcportimpedanceindices, and calcnoiseportimpedanceindices.\n\nExamples\n\n@variables Ipump Rleft Cc Lj Cj\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\nJosephsonCircuits.testshow(stdout,symbolicmatrices(circuit))\n\n# output\nJosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolic{Real}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolic{Real}[1 / Rleft], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], SymbolicUtils.BasicSymbolic{Real}[Lj], 2), sparsevec([2], SymbolicUtils.BasicSymbolic{Real}[Lj], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])\n\n@variables Ipump Rleft Cc Lj Cj\ncircuit = Vector{Tuple{String,String,String,Num}}(undef,0)\npush!(circuit,(\"P1\",\"1\",\"0\",1))\npush!(circuit,(\"I1\",\"1\",\"0\",Ipump))\npush!(circuit,(\"R1\",\"1\",\"0\",Rleft))\npush!(circuit,(\"C1\",\"1\",\"2\",Cc)) \npush!(circuit,(\"Lj1\",\"2\",\"0\",Lj)) \npush!(circuit,(\"C2\",\"2\",\"0\",Cj))\npsc = JosephsonCircuits.parsesortcircuit(circuit)\ncg = JosephsonCircuits.calccircuitgraph(psc)\nJosephsonCircuits.testshow(stdout,symbolicmatrices(psc, cg))\n\n# output\nJosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolic{Real}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolic{Real}[1 / Rleft], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], SymbolicUtils.BasicSymbolic{Real}[Lj], 2), sparsevec([2], SymbolicUtils.BasicSymbolic{Real}[Lj], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.testshow-Tuple{IO, SparseArrays.AbstractSparseVector}","page":"Reference","title":"JosephsonCircuits.testshow","text":"testshow(io::IO,S)\n\nPrint S to the IOStream or IOBuffer io. This is used to generate the inputs for testing purposes. The default show function doesn't always produce an output which can be evaluated as the input. For example, for sparse vectors.\n\nExamples\n\njulia> JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([1],[2],3))\nsparsevec([1], [2], 3)\n\njulia> JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([],Nothing[],3))\nsparsevec(Int64[], Nothing[], 3)\n\njulia> JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.AxisKeys.KeyedArray(rand(Int8, 2,10), ([:a, :b], 10:10:100)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_file-Tuple{AbstractVector{Float64}, Array{ComplexF64, 3}}","page":"Reference","title":"JosephsonCircuits.touchstone_file","text":"touchstone_file(f::Vector{Float64}, N::Array{Complex{Float64}};\n    frequencyunit::String = \"GHz\",\n    parameter::String = \"S\",\n    format::String = \"MA\",\n    R::Float64 = 50.0, \n    version::Float64 = 2.0,\n    twoportdataorder::String = \"\",\n    numberofnoisefrequencies::Int = 0,\n    reference::Vector{Float64} = Float64[],\n    information::Vector{String} = String[],\n    matrixformat::String = \"Full\",\n    mixedmodeorder::Vector{Tuple{Char, Vector{Int}}} = Tuple{Char, Vector{Int}}[],\n    comments::Vector{String} = String[],\n    noisedata::Vector{Float64} = Float64[])\n\nGenerate a TouchstoneFile struct from the frequency vector f in units of Hz and the complex network data array N where the frequency axis is the last dimension. All other arguments are optional.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_load-Tuple{Any}","page":"Reference","title":"JosephsonCircuits.touchstone_load","text":"touchstone_load(filename)\n\nRead a file in the Touchstone format. Standard compliant.\n\nThis is the 1.1 spec: https://ibis.org/connector/touchstonespec11.pdf and the 2.0 spec: https://ibis.org/touchstonever2.0/touchstonever20.pdf\n\nOutputs un-normalized network parameters with frequency units of Hz. Don't enforce any particular file extension or try to infer the number of ports from the extension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_parse-Tuple{IO}","page":"Reference","title":"JosephsonCircuits.touchstone_parse","text":"touchstone_parse(io::IO)\n\nParse the Touchstone file described by the IOBuffer or IOStream io.\n\nThis is the 1.1 spec: https://ibis.org/connector/touchstonespec11.pdf and the 2.0 spec: https://ibis.org/touchstonever2.0/touchstonever20.pdf\n\nExamples\n\nstr=\"!Example 1:\n!1-port S-parameter file, single frequency point\n# MHz S MA R 50\n!freq magS11 angS11\n2.000 0.894 -12.136\";\nprintln(str);\nJosephsonCircuits.touchstone_parse(IOBuffer(str))\n\n# output\n!Example 1:\n!1-port S-parameter file, single frequency point\n# MHz S MA R 50\n!freq magS11 angS11\n2.000 0.894 -12.136\nJosephsonCircuits.TouchstoneFile([2.0e6], ComplexF64[0.874020294860635 - 0.18794819544685323im;;;], \"mhz\", \"s\", \"ma\", 50.0, 1.0, 1, \"12_21\", 1, 0, [50.0], String[], \"Full\", Tuple{Char, Vector{Int64}}[], [\"Example 1:\", \"1-port S-parameter file, single frequency point\", \"freq magS11 angS11\"], [2.0, 0.894, -12.136], Float64[])\n\nstr=\"!Example 4 (Version 2.0):\n! 4-port S-parameter data\n! Default impedance is overridden by [Reference]\n! Data cannot be represented using 1.0 syntax\n! Note that the [Reference] keyword arguments appear on a separate line\n[Version] 2.0\n# GHz S MA R 50\n[Number of Ports] 4\n[Reference]\n50 75 0.01 0.01\n[Number of Frequencies] 1\n[Network Data]\n5.00000 0.60 161.24 0.40 -42.20 0.42 -66.58 0.53 -79.34 !row 1\n0.40 -42.20 0.60 161.20 0.53 -79.34 0.42 -66.58 !row 2\n0.42 -66.58 0.53 -79.34 0.60 161.24 0.40 -42.20 !row 3\n0.53 -79.34 0.42 -66.58 0.40 -42.20 0.60 161.24 !row 4\";\nprintln(str);\nJosephsonCircuits.touchstone_parse(IOBuffer(str))\n\n# output\n!Example 4 (Version 2.0):\n! 4-port S-parameter data\n! Default impedance is overridden by [Reference]\n! Data cannot be represented using 1.0 syntax\n! Note that the [Reference] keyword arguments appear on a separate line\n[Version] 2.0\n# GHz S MA R 50\n[Number of Ports] 4\n[Reference]\n50 75 0.01 0.01\n[Number of Frequencies] 1\n[Network Data]\n5.00000 0.60 161.24 0.40 -42.20 0.42 -66.58 0.53 -79.34 !row 1\n0.40 -42.20 0.60 161.20 0.53 -79.34 0.42 -66.58 !row 2\n0.42 -66.58 0.53 -79.34 0.60 161.24 0.40 -42.20 !row 3\n0.53 -79.34 0.42 -66.58 0.40 -42.20 0.60 161.24 !row 4\nJosephsonCircuits.TouchstoneFile([5.0e9], ComplexF64[-0.5681244079815996 + 0.1929628385351877im 0.29632183851470006 - 0.2686882357291961im 0.16693665375723588 - 0.38539869438327984im 0.09803970583787712 - 0.5208533537179372im; 0.29632183851470006 - 0.2686882357291961im -0.5679895560694177 + 0.1933594171383067im 0.09803970583787712 - 0.5208533537179372im 0.16693665375723588 - 0.38539869438327984im; 0.16693665375723588 - 0.38539869438327984im 0.09803970583787712 - 0.5208533537179372im -0.5681244079815996 + 0.1929628385351877im 0.29632183851470006 - 0.2686882357291961im; 0.09803970583787712 - 0.5208533537179372im 0.16693665375723588 - 0.38539869438327984im 0.29632183851470006 - 0.2686882357291961im -0.5681244079815996 + 0.1929628385351877im;;;], \"ghz\", \"s\", \"ma\", 50.0, 2.0, 4, \"12_21\", 1, 0, [50.0, 75.0, 0.01, 0.01], String[], \"Full\", Tuple{Char, Vector{Int64}}[], [\"Example 4 (Version 2.0):\", \" 4-port S-parameter data\", \" Default impedance is overridden by [Reference]\", \" Data cannot be represented using 1.0 syntax\", \" Note that the [Reference] keyword arguments appear on a separate line\", \"row 1\", \"row 2\", \"row 3\", \"row 4\"], [5.0, 0.6, 161.24, 0.4, -42.2, 0.42, -66.58, 0.53, -79.34, 0.4  …  0.4, -42.2, 0.53, -79.34, 0.42, -66.58, 0.4, -42.2, 0.6, 161.24], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_save-Tuple{String, AbstractVector, AbstractArray}","page":"Reference","title":"JosephsonCircuits.touchstone_save","text":"touchstone_save(filename::String,frequencies::AbstractArray,\n    N::AbstractArray;version=1.0,reference=[50.0,50.0],R = 50.0,format=\"RI\",\n    comments=[\"\"],twoportdataorder=\"12_21\",matrixformat=\"Full\",frequencyunit=\"Hz\")\n\nWrite a file in the Touchstone format. Standards compliant except does not support writing noise data.\n\nThis is the 1.1 spec: https://ibis.org/connector/touchstonespec11.pdf and the 2.0 spec: https://ibis.org/touchstonever2.0/touchstonever20.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_write-Tuple{IO, AbstractVector{Float64}, Array{ComplexF64, 3}}","page":"Reference","title":"JosephsonCircuits.touchstone_write","text":"touchstone_write(io::IO, frequencies::AbstractVector, N::AbstractArray;\n    version=1.0, reference=[50.0,50.0], R = 50.0, format=\"RI\",\n    parameter = \"S\", comments=[\"\"], twoportdataorder=\"12_21\",\n    matrixformat=\"Full\", frequencyunit=\"Hz\")\n\nWrite a Touchstone file to the IOStream or IOBuffer io.\n\nExamples\n\njulia> io = IOBuffer();JosephsonCircuits.touchstone_write(io, [1.0e9, 2.0e9, 10.0e9], [0.3926 - 0.1211im -0.0003 - 0.0021im; -0.0003 - 0.0021im 0.3926 - 0.1211im;;; 0.3517 - 0.3054im -0.0096 - 0.0298im; -0.0096 - 0.0298im 0.3517 - 0.3054im;;; 0.3419 + 0.3336im -0.0134 + 0.0379im; -0.0134 + 0.0379im 0.3419 + 0.3336im];version=1.0,R=50.0,format=\"RI\",frequencyunit=\"Hz\",comments=[\"Example 4:\",\"2-port S-parameter file, three frequency points\"]);println(String(take!(io)))\n!Example 4:\n!2-port S-parameter file, three frequency points\n# Hz S RI R 50.0\n! freq ReS11 ImS11 ReS21 ImS21 ReS12 ImS12 ReS22 ImS22 \n1.0e9 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211\n2.0e9 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054\n1.0e10 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336\n\n\njulia> io = IOBuffer();JosephsonCircuits.touchstone_write(io, [1.0e9, 2.0e9, 10.0e9], [0.3926 - 0.1211im -0.0003 - 0.0021im; -0.0003 - 0.0021im 0.3926 - 0.1211im;;; 0.3517 - 0.3054im -0.0096 - 0.0298im; -0.0096 - 0.0298im 0.3517 - 0.3054im;;; 0.3419 + 0.3336im -0.0134 + 0.0379im; -0.0134 + 0.0379im 0.3419 + 0.3336im];version=2.0,R=50.0,format=\"RI\",frequencyunit=\"Hz\",comments=[\"Example 4:\",\"2-port S-parameter file, three frequency points\"]);println(String(take!(io)))\n!Example 4:\n!2-port S-parameter file, three frequency points\n[Version] 2.0\n# Hz S RI R 50.0\n[Number of Ports] 2\n[Two-Port Data Order] 12_21\n[Number of Frequencies] 3\n[Reference] 50.0 50.0\n[Network Data]\n! freq ReS11 ImS11 ReS12 ImS12 ReS21 ImS21 ReS22 ImS22 \n1.0e9 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211\n2.0e9 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054\n1.0e10 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336\n[End]\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.touchstone_write-Tuple{IO, JosephsonCircuits.TouchstoneFile}","page":"Reference","title":"JosephsonCircuits.touchstone_write","text":"touchstone_write(io::IO, ts::TouchstoneFile)\n\nWrite a Touchstone file specified by the TouchstoneFile object ts to the IOStream or IOBuffer io.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.truncfreqs-Tuple{JosephsonCircuits.Frequencies}","page":"Reference","title":"JosephsonCircuits.truncfreqs","text":"truncfreqs(frequencies::Frequencies;\n    dc = false, odd = true, even = false, maxintermodorder = Inf)\n\nReturn a new Frequencies struct with the coordinates and modes truncated according to the user specified criteria.\n\nExamples\n\njulia> JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2).modes\n12-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (1, 0)\n (2, 0)\n (3, 0)\n (0, 1)\n (1, 1)\n (0, 2)\n (0, 3)\n (0, -3)\n (0, -2)\n (0, -1)\n (1, -1)\n\njulia> JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));dc=false,even=false,maxintermodorder=3).modes\n10-element Vector{Tuple{Int64, Int64}}:\n (1, 0)\n (3, 0)\n (0, 1)\n (2, 1)\n (1, 2)\n (0, 3)\n (0, -3)\n (1, -2)\n (0, -1)\n (2, -1)\n\njulia> JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2)\nJosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(1, 3), CartesianIndex(1, 4), CartesianIndex(1, 5), CartesianIndex(1, 6), CartesianIndex(1, 7), CartesianIndex(2, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (0, 2), (0, 3), (0, -3), (0, -2), (0, -1), (1, -1)])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.tuple2edge-Tuple{Vector{NTuple{4, Int64}}}","page":"Reference","title":"JosephsonCircuits.tuple2edge","text":"tuple2edge(tuplevector::Vector{Tuple{Int, Int, Int, Int}})\n\nConverts a vector of edges specified with tuples of integers to a vector of Graphs edges.\n\nExamples\n\njulia> JosephsonCircuits.tuple2edge([(1,2,3,4),(5,6,7,8)])\n2-element Vector{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}}:\n (Edge 1 => 2, Edge 3 => 4)\n (Edge 5 => 6, Edge 7 => 8)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.tuple2edge-Tuple{Vector{Tuple{Int64, Int64}}}","page":"Reference","title":"JosephsonCircuits.tuple2edge","text":"tuple2edge(tuplevector::Vector{Tuple{Int, Int}})\n\nConverts a vector of edges specified with tuples of integers to a vector of Graphs edges.\n\nExamples\n\njulia> JosephsonCircuits.tuple2edge([(1,2),(3,4)])\n2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{NTuple{4, Int64}, T}}, Tuple{T}} where T","page":"Reference","title":"JosephsonCircuits.tuple2edge","text":"tuple2edge(tupledict::Dict{Tuple{Int, Int, Int, Int},T})\n\nConverts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.\n\nExamples\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Int}((1, 2, 3, 4) => 1, (5, 6, 7, 8) => 3))\nDict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Int64} with 2 entries:\n  (Edge 1 => 2, Edge 3 => 4) => 1\n  (Edge 5 => 6, Edge 7 => 8) => 3\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Float64}((1, 2, 3, 4) => 1, (5, 6, 7, 8) => 3))\nDict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Float64} with 2 entries:\n  (Edge 1 => 2, Edge 3 => 4) => 1.0\n  (Edge 5 => 6, Edge 7 => 8) => 3.0\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Complex{Float64}}((1, 2, 3, 4) => 1, (5, 6, 7, 8) => 3))\nDict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, ComplexF64} with 2 entries:\n  (Edge 1 => 2, Edge 3 => 4) => 1.0+0.0im\n  (Edge 5 => 6, Edge 7 => 8) => 3.0+0.0im\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Any}((1, 2, 3, 4) => 1, (5, 6, 7, 8) => 3))\nDict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Any} with 2 entries:\n  (Edge 1 => 2, Edge 3 => 4) => 1\n  (Edge 5 => 6, Edge 7 => 8) => 3\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{Tuple{Int64, Int64}, T}}, Tuple{T}} where T","page":"Reference","title":"JosephsonCircuits.tuple2edge","text":"tuple2edge(tupledict::Dict{Tuple{Int, Int},T})\n\nConverts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.\n\nExamples\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Int}((1, 2) => 1, (3, 4) => 3, (2, 3) => 2))\nDict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Int64} with 3 entries:\n  Edge 1 => 2 => 1\n  Edge 3 => 4 => 3\n  Edge 2 => 3 => 2\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Float64}((1, 2) => 1, (3, 4) => 3, (2, 3) => 2))\nDict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Float64} with 3 entries:\n  Edge 1 => 2 => 1.0\n  Edge 3 => 4 => 3.0\n  Edge 2 => 3 => 2.0\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Complex{Float64}}((1, 2) => 1, (3, 4) => 3, (2, 3) => 2))\nDict{Graphs.SimpleGraphs.SimpleEdge{Int64}, ComplexF64} with 3 entries:\n  Edge 1 => 2 => 1.0+0.0im\n  Edge 3 => 4 => 3.0+0.0im\n  Edge 2 => 3 => 2.0+0.0im\n\njulia> JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Any}((1, 2) => 1, (3, 4) => 3, (2, 3) => 2))\nDict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Any} with 3 entries:\n  Edge 1 => 2 => 1\n  Edge 3 => 4 => 3\n  Edge 2 => 3 => 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.updateAoLjbm!-Tuple{SparseArrays.SparseMatrixCSC, Any, SparseArrays.SparseVector, Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.updateAoLjbm!","text":"updateAoLjbm!(AoLjbm::SparseMatrixCSC, Am, Ljb::SparseVector, Lmean, Nmodes,\n    Nbranches)\n\nExamples\n\n@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;\nAoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2);\nAoLjbmcopy = copy(AoLjbm);\nAoLjbmcopy.nzval .= 0;\nJosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)\nall(AoLjbmcopy.nzval .- AoLjbm.nzval .== 0)\n\n# output\ntrue\n\n@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;\nAoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2);\nAoLjbmcopy = copy(AoLjbm);\nAoLjbmcopy.nzval .= 0;\nJosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2)\nall(AoLjbmcopy.nzval .- AoLjbm.nzval .== 0)\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.updateAoLjbm2!-Tuple{SparseArrays.SparseMatrixCSC, Array, Any, Any, SparseArrays.SparseVector, Any}","page":"Reference","title":"JosephsonCircuits.updateAoLjbm2!","text":"updateAoLjbm2!(AoLjbm::SparseMatrixCSC, Am::Array, AoLjbmindices,\n    conjindicessorted, Ljb::SparseVector, Lmean)\n\nUpdate the values in the sparse AoLjbm matrix in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{Any, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value, circuitdefs)\n\nIf the component value value is a number (or a type we haven't considered, return it as is.\n\nExamples\n\njulia> JosephsonCircuits.valuetonumber(1.0,Dict(:Lj1=>1e-12,:Lj2=>2e-12))\n1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{Complex{Num}, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value::Complex{Symbolics.Num},circuitdefs)\n\nIf the component value is Complex{Symbolics.Num}, then try substituting in the definition from circuitdefs. \n\nNOTE: Below fails because Symbolics.jl doesn't have good support for complex  numbers.  @variables Lj1::Complex Lj2::Complex;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=>3.0e-12,Lj2=>1.0e-12)) 4.0e-12\n\nExamples\n\njulia> @variables Lj1::Complex;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=>3.0e-12))\n3.0e-12\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{Num, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value::Symbolics.Num,circuitdefs)\n\nIf the component value is Symbolics.Num, then try substituting in the definition from circuitdefs. \n\nExamples\n\njulia> @variables Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=>3.0e-12))\n3.0e-12\n\njulia> @variables Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=>3.0e-12,Lj2=>1.0e-12))\n4.0e-12\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{String, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value::String,circuitdefs)\n\nIf the component value is a string, assume it is a dictionary key.\n\nExamples\n\njulia> JosephsonCircuits.valuetonumber(\"Lj1\",Dict(\"Lj1\"=>1e-12,\"Lj2\"=>2e-12))\n1.0e-12\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{Symbol, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value::Symbol,circuitdefs)\n\nIf the component value is a symbol, assume it is a dictionary key.\n\nExamples\n\njulia> JosephsonCircuits.valuetonumber(:Lj1,Dict(:Lj1=>1e-12,:Lj2=>2e-12))\n1.0e-12\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.valuetonumber-Tuple{SymbolicUtils.Symbolic, Any}","page":"Reference","title":"JosephsonCircuits.valuetonumber","text":"valuetonumber(value::Symbolics.Symbol, circuitdefs)\n\nIf the component value value has a type Complex{Symbolics.Num}, then try substituting in the definition from circuitdefs. \n\nExamples\n\njulia> @syms Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=>3.0e-12))\n3.0e-12\n\njulia> @syms Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=>3.0e-12,Lj2=>1.0e-12))\n4.0e-12\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.visualizefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, JosephsonCircuits.Frequencies{N}}} where N","page":"Reference","title":"JosephsonCircuits.visualizefreqs","text":"visualizefreqs(w::NTuple{N,Any}, freq::Frequencies{N})\n\nCreate a vector or array containing the mixing products for visualization  purposes.\n\nExamples\n\n@variables wp1\nw = (wp1,)\nfreq = JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsrdft((3,)),\n        dc=true, odd=true, even=true, maxintermodorder=Inf,\n)\nJosephsonCircuits.visualizefreqs(w,freq)\n\n# output\n4-element Vector{Num}:\n    0\n  wp1\n 2wp1\n 3wp1\n\n@variables wp1,wp2\nw = (wp1,wp2)\nfreq = JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsrdft((3,3)),\n        dc=true, odd=true, even=true, maxintermodorder=3,\n)\nJosephsonCircuits.visualizefreqs(w,freq)\n\n# output\n4×7 Matrix{Num}:\n    0         wp2        2wp2  3wp2  -3wp2       -2wp2        -wp2\n  wp1   wp1 + wp2  wp1 + 2wp2     0      0  wp1 - 2wp2   wp1 - wp2\n 2wp1  2wp1 + wp2           0     0      0           0  2wp1 - wp2\n 3wp1           0           0     0      0           0           0\n\nw = (1.1,1.2)\nfreq = JosephsonCircuits.truncfreqs(\n    JosephsonCircuits.calcfreqsrdft((3,3)),\n        dc=true, odd=true, even=true, maxintermodorder=3,\n)\nJosephsonCircuits.visualizefreqs(w,freq)\n\n# output\n4×7 Matrix{Float64}:\n 0.0  1.2  2.4  3.6  -3.6  -2.4  -1.2\n 1.1  2.3  3.5  0.0   0.0  -1.3  -0.1\n 2.2  3.4  0.0  0.0   0.0   0.0   1.0\n 3.3  0.0  0.0  0.0   0.0   0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.wrspice_calcS_paramp-Tuple{Any, Any, Any}","page":"Reference","title":"JosephsonCircuits.wrspice_calcS_paramp","text":"wrspice_calcS_paramp(out, wswrspice, Nnodes, stepsperperiod = 80,\n    Is = 1e-13)\n\nThis function assume the first node is the input port and the last node is the output port. Nnodes is the number of nodes including the ground node.\n\nExamples\n\nNnodes = 2\nws = 2*pi*5e9\nwp = 2*pi*6e9\nstepsperperiod = 80\nt = LinRange(0,2*pi/wp,stepsperperiod)\nIs = 1e-13\nVpump = zeros(1,length(t))\nVsignalsin = zeros(1,length(t))\nVsignalcos = zeros(1,length(t))\nVpump[1,:] .= sin.(2*pi*wp*t)\nVsignalsin[1,:] .= sin.(2*pi*wp*t)+Is/50*sin.(2*pi*ws*t)\nVsignalcos[1,:] .= sin.(2*pi*wp*t)+Is/50*cos.(2*pi*ws*t)\n\nout = [(values=Dict(\"S\"=>t,\"V\"=>Vpump),),\n        (values=Dict(\"S\"=>t,\"V\"=>Vsignalsin),),\n        (values=Dict(\"S\"=>t,\"V\"=>Vsignalcos),),\n        ];\nout[1].values[\"V\"];\nout[2].values[\"V\"];\nout[3].values[\"V\"];\nJosephsonCircuits.wrspice_calcS_paramp(out, 2*pi, Nnodes;\n    stepsperperiod = stepsperperiod, Is = Is)\n\n# output\n(S11 = ComplexF64[-0.9999710828404902 + 2.7521387922213123e-5im], S21 = ComplexF64[2.8917159509832197e-5 + 2.7521387922213123e-5im])\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.wrspice_cmd-Tuple{}","page":"Reference","title":"JosephsonCircuits.wrspice_cmd","text":"wrspice_cmd()\n\nThis returns the path of the WRSPICE executable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.wrspice_input_ac-Tuple{String, AbstractVector{Float64}, Any, Any}","page":"Reference","title":"JosephsonCircuits.wrspice_input_ac","text":"wrspice_input_ac(netlist,nsteps,fstart,fstop)\n\nGenerate the WRSPICE input file for an AC small signal simulation using circuit parameters from the given netlist, and the specified frequency range. Example usage:\n\nExamples\n\njulia> println(JosephsonCircuits.wrspice_input_ac(\"* SPICE Simulation\",100,4e9,5e9,[1,2],1e-6))\n* SPICE Simulation\n* AC current source with magnitude 1 and phase 0\nisrc 1 0 ac 1.0e-6 0.0\n\n* Set up the AC small signal simulation\n.ac lin 100 4.0g 5.0g\n\n* The control block\n.control\n\n* Maximum size of data to export in kilobytes from 1e3 to 2e9 with \n* default 2.56e5. This has to come before the run command\nset maxdata=2.0e9\n\n* Run the simulation\nrun\n\n* Binary files are faster to save and load. \nset filetype=binary\n\n* Leave filename empty so we can add that as a command line argument.\n* Don't specify any variables so it saves everything.    \nwrite\n\n.endc\n\n\njulia> println(JosephsonCircuits.wrspice_input_ac(\"* SPICE Simulation\",(4:0.01:5)*1e9,[1,2],1e-6))\n* SPICE Simulation\n* AC current source with magnitude 1 and phase 0\nisrc 1 0 ac 1.0e-6 0.0\n\n* Set up the AC small signal simulation\n.ac lin 99 4.0g 5.0g\n\n* The control block\n.control\n\n* Maximum size of data to export in kilobytes from 1e3 to 2e9 with \n* default 2.56e5. This has to come before the run command\nset maxdata=2.0e9\n\n* Run the simulation\nrun\n\n* Binary files are faster to save and load. \nset filetype=binary\n\n* Leave filename empty so we can add that as a command line argument.\n* Don't specify any variables so it saves everything.    \nwrite\n\n.endc\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.wrspice_input_paramp-NTuple{6, Any}","page":"Reference","title":"JosephsonCircuits.wrspice_input_paramp","text":"wrspice_input_paramp(netlist, ws, wp, Ip; stepsperperiod = 80, Is = 1e-13,\n    tstop = 200e-9, trise = 10e-9)\n\nGenerate the WRSPICE input files for a time domain domain simulation in which the signal angular frequency is swept over ws with pump angular frequency wp and pump current Ip. \n\nExamples\n\nusing JosephsonCircuits\nusing Plots\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",:R),\n    (\"C1\",\"1\",\"2\",:Cc),\n    (\"Lj1\",\"2\",\"0\",:Lj),\n    (\"C2\",\"2\",\"0\",:Cj)]\ncircuitdefs = Dict(\n    :Lj =>1000.0e-12,\n    :Cc => 100.0e-15,\n    :Cj => 1000.0e-15,\n    :R => 50.0)\nws = 2*pi*(4.5:0.001:5.0)*1e9\nwp = (2*pi*4.75001*1e9,)\nIp = 0.00565e-6\nsources = [(mode=(1,),port=1,current=Ip)]\nNpumpharmonics = (16,)\nNmodulationharmonics = (8,)\n@time jpa = hbsolve(ws, wp, sources, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs)\nwswrspice=2*pi*(4.5:0.01:5.0)*1e9\nn = JosephsonCircuits.exportnetlist(circuit,circuitdefs);\ninput = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,wp[1],2*Ip);\n@time output = JosephsonCircuits.spice_run(input,JosephsonCircuits.wrspice_cmd());\nS11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes);\nplot(ws/(2*pi*1e9),\n    10*log10.(abs2.(jpa.linearized.S((0,),1,(0,),1,:))),\n    label=\"JosephsonCircuits.jl\",\n    xlabel=\"Frequency (GHz)\",\n    ylabel=\"S11 (dB)\")\nplot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),\n    label=\"WRSPICE\",\n    seriestype=:scatter)\n\n\n\n\n\n","category":"method"},{"location":"reference/#JosephsonCircuits.wrspice_input_transient-Tuple{String, Vararg{Any, 7}}","page":"Reference","title":"JosephsonCircuits.wrspice_input_transient","text":"wrspice_input_transient(netlist::String, current, frequency, phase, tstep,\n    tstop, trise; maxdata = 2e9, jjaccel = 1, dphimax = 0.01,\n    filetype = \"binary\")\n\nGenerate the WRSPICE input file for a transient simulation using circuit  parameters from the given netlist, the source current, frequency phase, and nodes for the sources, and the time step and stop time. Leave filename empty so we can add that as a command line argument. Don't specify any variables so it saves everything.\n\nArguments\n\nnetlist: String containing the circuit netlist, excluding sources.\ncurrent: Vector of current source amplitudes in Ampere.\nfrequency: Vector of current source frequencies in Hz.\nphase: Vector of current source phases in radians.\nsourcenodes: Vector of tuples of nodes (src,dst) at which to place the current   source(s).\ntstep: Time step in seconds.\ntstop: Time for which to run the simulation in seconds.\ntrise: The simulation ramps up the current source amplitude with a   1-sech(t/trise) envelope which reaches 35 percent of the peak in one   trise.\n\nKeywords\n\nmaxdata = 2e9: Maximum size of data to export in kilobytes from 1e3 to   2e9 with WRspice default 2.56e5. This has to come before the run command.\njjaccel = 1: Causes a faster convergence testing and iteration control   algorithm to be used, rather than the standard more comprehensive   algorithm suitable for all devices.\ndphimax = 0.01: The maximum allowed phase change per time step. Decreasing   dphimax from the default of pi/5 to a smaller value is critical for   matching the accuracy of the harmonic balance method simulations. This   increases simulation time by pi/5/(dphimax).\nfiletype = \"binary\" or \"ascii\": Binary files are faster to save and load.\n\nExamples\n\njulia> println(JosephsonCircuits.wrspice_input_transient(\"* SPICE Simulation\",[1e-6,1e-3],[5e9,6e9],[3.14,6.28],[(1,0),(1,0)],1e-9,100e-9,10e-9))\n* SPICE Simulation\n* Current source\n* 1-hyperbolic secant rise\nisrc1 1 0 1.0u*cos(31.41592653589793g*x+3.14)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))\nisrc2 1 0 1000.0u*cos(37.69911184307752g*x+6.28)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))\n* Set up the transient simulation\n* .tran 5p 10n\n.tran 1000.0000000000001p 100.0n uic\n\n* The control block\n.control\nset maxdata=2.0e9\nset jjaccel=1\nset dphimax=0.01\nrun\nset filetype=binary\nwrite\n.endc\n\n\n\n\n\n\n","category":"method"},{"location":"#JosephsonCircuits.jl","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: Code coverage) (Image: Build Status) (Image: PkgEval) (Image: Stable docs)  (Image: Dev docs)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"JosephsonCircuits.jl is a high-performance frequency domain simulator for nonlinear circuits containing Josephson junctions, capacitors, inductors, mutual inductors, and resistors. JosephsonCircuits.jl simulates the frequency domain behavior using a variant [1] of nodal analysis [2] and the harmonic balance method [3-5] with an analytic Jacobian. Noise performance, quantified by quantum efficiency, is efficiently simulated through an adjoint method.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Frequency dependent circuit parameters are supported to model realistic impedance environments or dissipative components. Dissipation can be modeled by capacitors with an imaginary capacitance or frequency dependent resistors. ","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"JosephsonCircuits.jl supports the following:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Nonlinear simulations in which the user defines a circuit, the drive current, frequency, and number of harmonics and the code calculates the node flux or node voltage at each harmonic.\nLinearized simulations about the nonlinear operating point calculated above. This simulates the small signal response of a periodically time varying linear circuit and is useful for simulating parametric amplification and frequency conversion in the undepleted (strong) pump limit. Calculation of node fluxes (or node voltages) and scattering parameters of the linearized circuit [4-5].\nLinear simulations of linear circuits. Calculation of node fluxes (or node voltages) and scattering parameters.\nCalculation of symbolic capacitance and inverse inductance matrices.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"As detailed in [6], we find excellent agreement with Keysight ADS simulations and Fourier analysis of time domain simulation performed by WRSPICE.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Warning: this package is under heavy development and there will be breaking changes. We will keep the examples updated to ease the burden of any breaking changes.","category":"page"},{"location":"#Installation:","page":"JosephsonCircuits.jl","title":"Installation:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"To install the latest release of the package, install Julia using Juliaup, start Julia, and enter the following command:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using Pkg\nPkg.add(\"JosephsonCircuits\")","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"To install the development version, start Julia and enter the command:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using Pkg\nPkg.add(name=\"JosephsonCircuits\",rev=\"main\")","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"To run the examples below, you will need to install Plots.jl using the command:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Pkg.add(\"Plots\")","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"If you get errors when running the examples, please try installing the latest version of Julia and updating to the latest version of JosephsonCircuits.jl by running:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Pkg.update()","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Then check that you are running the latest version of the package with:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Pkg.status()","category":"page"},{"location":"#Usage:","page":"JosephsonCircuits.jl","title":"Usage:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Generate a netlist using circuit components including capacitors C, inductors L, Josephson junctions described by the Josephson inductance Lj, mutual inductors described by the mutual coupling coefficient K, and resistors R. See the SPICE netlist format, docstrings, and examples below for usage. Run the harmonic balance analysis using hbnlsolve to solve a nonlinear system at one operating point, hblinsolve to solve a linear (or linearized) system at one or more frequencies, or hbsolve to run both analyses. Add a question mark ? in front of a function to access the docstring.","category":"page"},{"location":"#Examples:","page":"JosephsonCircuits.jl","title":"Examples:","text":"","category":"section"},{"location":"#Josephson-parametric-amplifier-(JPA)","page":"JosephsonCircuits.jl","title":"Josephson parametric amplifier (JPA)","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"A driven nonlinear LC resonator.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using JosephsonCircuits\nusing Plots\n\n@variables R Cc Lj Cj\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",R),\n    (\"C1\",\"1\",\"2\",Cc),\n    (\"Lj1\",\"2\",\"0\",Lj),\n    (\"C2\",\"2\",\"0\",Cj)]\n\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    R => 50.0)\n\nws = 2*pi*(4.5:0.001:5.0)*1e9\nwp = (2*pi*4.75001*1e9,)\nIp = 0.00565e-6\nsources = [(mode=(1,),port=1,current=Ip)]\nNpumpharmonics = (16,)\nNmodulationharmonics = (8,)\n\n@time jpa = hbsolve(ws, wp, sources, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs)\n\nplot(\n    jpa.linearized.w/(2*pi*1e9),\n    10*log10.(abs2.(\n        jpa.linearized.S(\n            outputmode=(0,),\n            outputport=1,\n            inputmode=(0,),\n            inputport=1,\n            freqindex=:\n        ),\n    )),\n    label=\"JosephsonCircuits.jl\",\n    xlabel=\"Frequency (GHz)\",\n    ylabel=\"Gain (dB)\",\n)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  0.001817 seconds (12.99 k allocations: 4.361 MiB)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: JPA simulation with JosephsonCircuits.jl)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Compare with WRspice. Please note that on Linux you can install the XicTools_jll package which provides WRspice for x8664. For other operating systems and platforms, you can install WRspice yourself and substitute `XicToolsjll.wrspice()withJosephsonCircuits.wrspice_cmd()` which will attempt to provide the path to your WRspice executable. ","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using XicTools_jll\n\nwswrspice=2*pi*(4.5:0.01:5.0)*1e9\nn = JosephsonCircuits.exportnetlist(circuit,circuitdefs);\ninput = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,wp[1],2*Ip,(0,1),(0,1));\n\n@time output = JosephsonCircuits.spice_run(input,XicTools_jll.wrspice());\nS11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes);\n\nplot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),\n    label=\"WRspice\",\n    seriestype=:scatter)\n","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":" 12.743245 seconds (32.66 k allocations: 499.263 MiB, 0.41% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: JPA simulation with JosephsonCircuits.jl and WRspice)","category":"page"},{"location":"#Double-pumped-Josephson-parametric-amplifier-(JPA)","page":"JosephsonCircuits.jl","title":"Double-pumped Josephson parametric amplifier (JPA)","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using JosephsonCircuits\nusing Plots\n\n@variables R Cc Lj Cj\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",R),\n    (\"C1\",\"1\",\"2\",Cc),\n    (\"Lj1\",\"2\",\"0\",Lj),\n    (\"C2\",\"2\",\"0\",Cj)]\n\ncircuitdefs = Dict(\n    Lj =>1000.0e-12,\n    Cc => 100.0e-15,\n    Cj => 1000.0e-15,\n    R => 50.0)\n\nws = 2*pi*(4.5:0.001:5.0)*1e9\nwp = (2*pi*4.65001*1e9,2*pi*4.85001*1e9)\n\nIp = 0.00565e-6*1.7\nsources = [(mode=(1,0),port=1,current=Ip),(mode=(0,1),port=1,current=Ip)]\nNpumpharmonics = (8,8)\nNmodulationharmonics = (8,8)\n\n@time jpa = hbsolve(ws, wp, sources, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs);\n\nplot(\n    jpa.linearized.w/(2*pi*1e9),\n    10*log10.(abs2.(\n        jpa.linearized.S(\n            outputmode=(0,0),\n            outputport=1,\n            inputmode=(0,0),\n            inputport=1,\n            freqindex=:\n        ),\n    )),\n    label=\"JosephsonCircuits.jl\",\n    xlabel=\"Frequency (GHz)\",\n    ylabel=\"S11 (dB)\",\n)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  0.182720 seconds (12.70 k allocations: 713.087 MiB)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"and compare with WRspice","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using XicTools_jll\n\nwswrspice=2*pi*(4.5:0.01:5.0)*1e9\nn = JosephsonCircuits.exportnetlist(circuit,circuitdefs);\ninput = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,[wp[1],wp[2]],[2*Ip,2*Ip],(0,1),[(0,1),(0,1)]);\n\n@time output = JosephsonCircuits.spice_run(input,XicTools_jll.wrspice());\nS11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes,stepsperperiod = 50000);\n\nplot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),\n    label=\"WRspice\",\n    seriestype=:scatter)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":" 15.782862 seconds (32.80 k allocations: 509.192 MiB, 0.39% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: Double pumped JPA simulation with JosephsonCircuits.jl and WRspice)","category":"page"},{"location":"#Flux-pumped-Josephson-parametric-amplifier-(JPA)","page":"JosephsonCircuits.jl","title":"Flux-pumped Josephson parametric amplifier (JPA)","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Circuit and parameters from here. Please note that three wave mixing (3WM) and flux-biasing are relatively untested, so you may encounter bugs. Please file issues or PRs.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using JosephsonCircuits\nusing Plots\n\n@variables R Cc Cj Lj Cr Lr Ll Ldc K Lg\ncircuit = [\n    (\"P1\",\"1\",\"0\",1),\n    (\"R1\",\"1\",\"0\",R),\n    # a very large inductor so the DC node flux of this node isn't floating\n    (\"L0\",\"1\",\"0\",Lg), \n    (\"C1\",\"1\",\"2\",Cc),\n    (\"L1\",\"2\",\"3\",Lr),\n    (\"C2\",\"2\",\"0\",Cr),\n    (\"Lj1\",\"3\",\"0\",Lj),\n    (\"Cj1\",\"3\",\"0\",Cj),\n    (\"L2\",\"3\",\"4\",Ll),\n    (\"Lj2\",\"4\",\"0\",Lj),\n    (\"Cj2\",\"4\",\"0\",Cj),\n    (\"L3\",\"5\",\"0\",Ldc), \n    (\"K1\",\"L2\",\"L3\",K),\n    # a port with a very large resistor so we can apply the bias across the port\n    (\"P2\",\"5\",\"0\",2),\n    (\"R2\",\"5\",\"0\",1000.0),\n] \n\ncircuitdefs = Dict(\n    Lj =>219.63e-12,\n    Lr =>0.4264e-9,\n    Lg =>100.0e-9,\n    Cc => 16.0e-15,\n    Cj => 10.0e-15, \n    Cr => 0.4e-12,\n    R => 50.0, \n    Ll => 34e-12, \n    K => 0.999, # the inverse inductance matrix for K=1.0 diverges, so set K<1.0\n    Ldc => 0.74e-12,\n)\n\nws = 2*pi*(9.7:0.0001:9.8)*1e9\nwp = (2*pi*19.50*1e9,)\nIp = 0.7e-6\nIdc = 140.3e-6\n# add the DC bias and pump to port 2\nsourcespumpon = [(mode=(0,),port=2,current=Idc),(mode=(1,),port=2,current=Ip)]\nNpumpharmonics = (16,)\nNmodulationharmonics = (8,)\n@time jpapumpon = hbsolve(ws, wp, sourcespumpon, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs, dc = true, threewavemixing=true,fourwavemixing=true) # enable dc and three wave mixing\n\n\nplot(\n    jpapumpon.linearized.w/(2*pi*1e9),\n    10*log10.(abs2.(\n        jpapumpon.linearized.S(\n            outputmode=(0,),\n            outputport=1,\n            inputmode=(0,),\n            inputport=1,\n            freqindex=:\n        ),\n    )),\n    xlabel=\"Frequency (GHz)\",\n    ylabel=\"Gain (dB)\",\n    label=\"JosephsonCircuits.jl\",\n)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  0.015623 seconds (22.07 k allocations: 80.082 MiB)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"and compare with WRspice","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using XicTools_jll\n\n# simulate the JPA in WRSPICE\nwswrspice=2*pi*(9.7:0.005:9.8)*1e9\nn = JosephsonCircuits.exportnetlist(circuit,circuitdefs);\ninput = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,[0.0,wp[1]],[Idc,2*Ip],[(0,1)],[(0,5),(0,5)];trise=10e-9,tstop=600e-9);\n\n# @time output = JosephsonCircuits.spice_run(input,JosephsonCircuits.wrspice_cmd());\n@time output = JosephsonCircuits.spice_run(input,XicTools_jll.wrspice());\nS11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes);\n\n# plot the output\nplot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),\n    label=\"WRspice\",\n    seriestype=:scatter)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"283.557011 seconds (26.76 k allocations: 7.205 GiB, 0.66% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: Flux pumped JPA simulation with JosephsonCircuits.jl and WRspice)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Simulate the JPA frequency as a function of DC bias current:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"ws = 2*pi*(8.0:0.01:11.0)*1e9\ncurrentvals = (-20:0.1:20)*1e-5\noutvals = zeros(Complex{Float64},length(ws),length(currentvals))\nIp=0.0\n\nNpumpharmonics = (1,)\nNmodulationharmonics = (1,)\n\n@time for (k,Idc) in enumerate(currentvals)\n    sources = [\n          (mode=(0,),port=2,current=Idc),\n          (mode=(1,),port=2,current=Ip),\n      ]\n    sol = hbsolve(ws,wp,sources,Nmodulationharmonics, Npumpharmonics,\n        circuit, circuitdefs;dc=true,threewavemixing=true,fourwavemixing=true)\n    outvals[:,k]=sol.linearized.S((0,),1,(0,),1,:)\nend\n\nplot(\n    currentvals/(1e-3),\n    ws/(2*pi*1e9),\n    10*log10.(abs2.(outvals)),\n    seriestype=:heatmap,\n    xlabel=\"bias current (mA)\",\n    ylabel=\"frequency (GHz)\",\n    title=\"S11 (dB), pump off\",\n)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"0.219279 seconds (3.27 M allocations: 639.981 MiB, 20.84% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: JPA frequency vs DC bias current)","category":"page"},{"location":"#Josephson-traveling-wave-parametric-amplifier-(JTWPA)","page":"JosephsonCircuits.jl","title":"Josephson traveling wave parametric amplifier (JTWPA)","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Circuit parameters from here.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using JosephsonCircuits\nusing Plots\n\n@variables Rleft Rright Cg Lj Cj Cc Cr Lr\ncircuit = Tuple{String,String,String,Num}[]\n\n# port on the input side\npush!(circuit,(\"P$(1)_$(0)\",\"1\",\"0\",1))\npush!(circuit,(\"R$(1)_$(0)\",\"1\",\"0\",Rleft))\nNj=2048\npmrpitch = 4\n#first half cap to ground\npush!(circuit,(\"C$(1)_$(0)\",\"1\",\"0\",Cg/2))\n#middle caps and jj's\npush!(circuit,(\"Lj$(1)_$(2)\",\"1\",\"2\",Lj)) \npush!(circuit,(\"C$(1)_$(2)\",\"1\",\"2\",Cj)) \n\nj=2\nfor i = 2:Nj-1\n    \n    if mod(i,pmrpitch) == pmrpitch÷2\n\n        # make the jj cell with modified capacitance to ground\n        push!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",Cg-Cc))\n        push!(circuit,(\"Lj$(j)_$(j+2)\",\"$(j)\",\"$(j+2)\",Lj))\n\n        push!(circuit,(\"C$(j)_$(j+2)\",\"$(j)\",\"$(j+2)\",Cj))\n        \n        #make the pmr\n        push!(circuit,(\"C$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Cc))\n        push!(circuit,(\"C$(j+1)_$(0)\",\"$(j+1)\",\"$(0)\",Cr))\n        push!(circuit,(\"L$(j+1)_$(0)\",\"$(j+1)\",\"$(0)\",Lr))\n        \n        # increment the index\n        j+=1\n    else\n        push!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",Cg))\n        push!(circuit,(\"Lj$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Lj))\n        push!(circuit,(\"C$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Cj))\n    end\n    \n    # increment the index\n    j+=1\n\nend\n\n#last jj\npush!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",Cg/2))\npush!(circuit,(\"R$(j)_$(0)\",\"$(j)\",\"$(0)\",Rright))\n# port on the output side\npush!(circuit,(\"P$(j)_$(0)\",\"$(j)\",\"$(0)\",2))\n\ncircuitdefs = Dict(\n    Lj => IctoLj(3.4e-6),\n    Cg => 45.0e-15,\n    Cc => 30.0e-15,\n    Cr =>  2.8153e-12,\n    Lr => 1.70e-10,\n    Cj => 55e-15,\n    Rleft => 50.0,\n    Rright => 50.0,\n)\n\nws=2*pi*(1.0:0.1:14)*1e9\nwp=(2*pi*7.12*1e9,)\nIp=1.85e-6\nsources = [(mode=(1,),port=1,current=Ip)]\nNpumpharmonics = (20,)\nNmodulationharmonics = (10,)\n\n@time rpm = hbsolve(ws, wp, sources, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs)\n\np1=plot(ws/(2*pi*1e9),\n    10*log10.(abs2.(rpm.linearized.S(\n            outputmode=(0,),\n            outputport=2,\n            inputmode=(0,),\n            inputport=1,\n            freqindex=:),\n    )),\n    ylim=(-40,30),label=\"S21\",\n    xlabel=\"Signal Frequency (GHz)\",\n    legend=:bottomright,\n    title=\"Scattering Parameters\",\n    ylabel=\"dB\")\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(rpm.linearized.S((0,),1,(0,),2,:))),\n    label=\"S12\",\n    )\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(rpm.linearized.S((0,),1,(0,),1,:))),\n    label=\"S11\",\n    )\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(rpm.linearized.S((0,),2,(0,),2,:))),\n    label=\"S22\",\n    )\n\np2=plot(ws/(2*pi*1e9),\n    rpm.linearized.QE((0,),2,(0,),1,:)./rpm.linearized.QEideal((0,),2,(0,),1,:),    \n    ylim=(0,1.05),\n    title=\"Quantum efficiency\",legend=false,\n    ylabel=\"QE/QE_ideal\",xlabel=\"Signal Frequency (GHz)\");\n\np3=plot(ws/(2*pi*1e9),\n    10*log10.(abs2.(rpm.linearized.S(:,2,(0,),1,:)')),\n    ylim=(-40,30),\n    xlabel=\"Signal Frequency (GHz)\",\n    legend=false,\n    title=\"All idlers\",\n    ylabel=\"dB\")\n\np4=plot(ws/(2*pi*1e9),\n    1 .- rpm.linearized.CM((0,),2,:),    \n    legend=false,title=\"Commutation \\n relation error\",\n    ylabel=\"Commutation \\n relation error\",xlabel=\"Signal Frequency (GHz)\");\n\nplot(p1, p2, p3, p4, layout = (2, 2))","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  2.959010 seconds (257.75 k allocations: 2.392 GiB, 0.21% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: JTWPA simulation)","category":"page"},{"location":"#Floquet-JTWPA","page":"JosephsonCircuits.jl","title":"Floquet JTWPA","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Circuit parameters from here.","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"using JosephsonCircuits\nusing Plots\n\n@variables Rleft Rright Lj Cg Cc Cr Lr Cj\n\nweightwidth = 745\nweight = (n,Nnodes,weightwidth) -> exp(-(n - Nnodes/2)^2/(weightwidth)^2)\nNj=2000\npmrpitch = 8\n\n# define the circuit components\ncircuit = Tuple{String,String,String,Num}[]\n\n# port on the left side\npush!(circuit,(\"P$(1)_$(0)\",\"1\",\"0\",1))\npush!(circuit,(\"R$(1)_$(0)\",\"1\",\"0\",Rleft))\n\n#first half cap to ground\npush!(circuit,(\"C$(1)_$(0)\",\"1\",\"0\",Cg/2*weight(1-0.5,Nj,weightwidth)))\n#middle caps and jj's\npush!(circuit,(\"Lj$(1)_$(2)\",\"1\",\"2\",Lj*weight(1,Nj,weightwidth))) \npush!(circuit,(\"C$(1)_$(2)\",\"1\",\"2\",Cj/weight(1,Nj,weightwidth))) \n    \nj=2\nfor i = 2:Nj-1\n    \n    if mod(i,pmrpitch) == pmrpitch÷2\n\n        # make the jj cell with modified capacitance to ground\n        push!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",(Cg-Cc)*weight(i-0.5,Nj,weightwidth)))\n        push!(circuit,(\"Lj$(j)_$(j+2)\",\"$(j)\",\"$(j+2)\",Lj*weight(i,Nj,weightwidth)))\n\n        push!(circuit,(\"C$(j)_$(j+2)\",\"$(j)\",\"$(j+2)\",Cj/weight(i,Nj,weightwidth)))\n        \n        #make the pmr\n        push!(circuit,(\"C$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Cc*weight(i-0.5,Nj,weightwidth)))\n        push!(circuit,(\"C$(j+1)_$(0)\",\"$(j+1)\",\"$(0)\",Cr))\n        push!(circuit,(\"L$(j+1)_$(0)\",\"$(j+1)\",\"$(0)\",Lr))\n        \n        # increment the index\n        j+=1\n    else\n        push!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",Cg*weight(i-0.5,Nj,weightwidth)))\n        push!(circuit,(\"Lj$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Lj*weight(i,Nj,weightwidth)))\n        push!(circuit,(\"C$(j)_$(j+1)\",\"$(j)\",\"$(j+1)\",Cj/weight(i,Nj,weightwidth)))\n    end\n    \n    # increment the index\n    j+=1\n\nend\n\n#last jj\npush!(circuit,(\"C$(j)_$(0)\",\"$(j)\",\"$(0)\",Cg/2*weight(Nj-0.5,Nj,weightwidth)))\npush!(circuit,(\"R$(j)_$(0)\",\"$(j)\",\"$(0)\",Rright))\npush!(circuit,(\"P$(j)_$(0)\",\"$(j)\",\"$(0)\",2))\n\ncircuitdefs = Dict(\n    Rleft => 50.0,\n    Rright => 50.0,\n    Lj => IctoLj(1.75e-6),\n    Cg => 76.6e-15,\n    Cc => 40.0e-15,\n    Cr =>  1.533e-12,\n    Lr => 2.47e-10,\n    Cj => 40e-15,\n)  \n\nws=2*pi*(1.0:0.1:14)*1e9\nwp=(2*pi*7.9*1e9,)\nIp=1.1e-6\nsources = [(mode=(1,),port=1,current=Ip)]\nNpumpharmonics = (20,)\nNmodulationharmonics = (10,)\n\n@time floquet = hbsolve(ws, wp, sources, Nmodulationharmonics,\n    Npumpharmonics, circuit, circuitdefs)\n\np1=plot(ws/(2*pi*1e9),\n    10*log10.(abs2.(floquet.linearized.S((0,),2,(0,),1,:))),\n    ylim=(-40,30),label=\"S21\",\n    xlabel=\"Signal Frequency (GHz)\",\n    legend=:bottomright,\n    title=\"Scattering Parameters\",\n    ylabel=\"dB\")\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(floquet.linearized.S((0,),1,(0,),2,:))),\n    label=\"S12\",\n    )\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(floquet.linearized.S((0,),1,(0,),1,:))),\n    label=\"S11\",\n    )\n\nplot!(ws/(2*pi*1e9),\n    10*log10.(abs2.(floquet.linearized.S((0,),2,(0,),2,:))),\n    label=\"S22\",\n    )\n\np2=plot(ws/(2*pi*1e9),\n    floquet.linearized.QE((0,),2,(0,),1,:)./floquet.linearized.QEideal((0,),2,(0,),1,:),    \n    ylim=(0.99,1.001),\n    title=\"Quantum efficiency\",legend=false,\n    ylabel=\"QE/QE_ideal\",xlabel=\"Signal Frequency (GHz)\");\n\np3=plot(ws/(2*pi*1e9),\n    10*log10.(abs2.(floquet.linearized.S(:,2,(0,),1,:)')),\n    ylim=(-40,30),label=\"S21\",\n    xlabel=\"Signal Frequency (GHz)\",\n    legend=false,\n    title=\"All idlers\",\n    ylabel=\"dB\")\n\n\np4=plot(ws/(2*pi*1e9),\n    1 .- floquet.linearized.CM((0,),2,:),\n    legend=false,title=\"Commutation \\n relation error\",\n    ylabel=\"Commutation \\n relation error\",xlabel=\"Signal Frequency (GHz)\");\n\nplot(p1, p2, p3,p4,layout = (2, 2))","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  2.079267 seconds (456.63 k allocations: 1.997 GiB, 0.48% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: Floquet JTWPA simulation)","category":"page"},{"location":"#Floquet-JTWPA-with-dissipation","page":"JosephsonCircuits.jl","title":"Floquet JTWPA with dissipation","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Dissipation due to capacitors with dielectric loss, parameterized by a loss tangent. Run the above code block to define the circuit then run the following:","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"results = []\ntandeltas = [1.0e-6,1.0e-3, 2.0e-3, 3.0e-3]\nfor tandelta in tandeltas\n    circuitdefs = Dict(\n        Rleft => 50,\n        Rright => 50,\n        Lj => IctoLj(1.75e-6),\n        Cg => 76.6e-15/(1+im*tandelta),\n        Cc => 40.0e-15/(1+im*tandelta),\n        Cr => 1.533e-12/(1+im*tandelta),\n        Lr => 2.47e-10,\n        Cj => 40e-15,\n    )  \n    wp=(2*pi*7.9*1e9,)\n    ws=2*pi*(1.0:0.1:14)*1e9\n    Ip=1.1e-6*(1+125*tandelta)\n    sources = [(mode=(1,),port=1,current=Ip)]\n    Npumpharmonics = (20,)\n    Nmodulationharmonics = (10,)\n    @time floquet = hbsolve(ws, wp, sources, Nmodulationharmonics,\n        Npumpharmonics, circuit, circuitdefs)\n    push!(results,floquet)\nend\n\np1 = plot(title=\"Gain (S21)\")\nfor i = 1:length(results)\n        plot!(ws/(2*pi*1e9),\n            10*log10.(abs2.(results[i].linearized.S((0,),2,(0,),1,:))),\n            ylim=(-60,30),label=\"tanδ=$(tandeltas[i])\",\n            legend=:bottomleft,\n            xlabel=\"Signal Frequency (GHz)\",ylabel=\"dB\")\nend\n\np2 = plot(title=\"Quantum Efficiency\")\nfor i = 1:length(results)\n        plot!(ws/(2*pi*1e9),\n            results[i].linearized.QE((0,),2,(0,),1,:)./results[i].linearized.QEideal((0,),2,(0,),1,:),\n            ylim=(0.6,1.05),legend=false,\n            title=\"Quantum efficiency\",\n            ylabel=\"QE/QE_ideal\",xlabel=\"Signal Frequency (GHz)\")\nend\n\np3 = plot(title=\"Reverse Gain (S12)\")\nfor i = 1:length(results)\n        plot!(ws/(2*pi*1e9),\n            10*log10.(abs2.(results[i].linearized.S((0,),1,(0,),2,:))),\n            ylim=(-10,1),legend=false,\n            xlabel=\"Signal Frequency (GHz)\",ylabel=\"dB\")\nend\n\np4 = plot(title=\"Commutation \\n relation error\")\nfor i = 1:length(results)\n        plot!(ws/(2*pi*1e9),\n            1 .- results[i].linearized.CM((0,),2,:),\n            legend=false,\n            ylabel=\"Commutation\\n relation error\",xlabel=\"Signal Frequency (GHz)\")\nend\n\nplot(p1, p2, p3,p4,layout = (2, 2))","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"  3.815835 seconds (470.00 k allocations: 2.303 GiB, 0.22% gc time)\n  3.800166 seconds (470.59 k allocations: 2.310 GiB, 0.29% gc time)\n  3.824690 seconds (470.75 k allocations: 2.317 GiB, 0.19% gc time)\n  3.838721 seconds (470.75 k allocations: 2.317 GiB, 0.18% gc time)","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"(Image: Floquet JTWPA simulation with loss)","category":"page"},{"location":"#Performance-tips:","page":"JosephsonCircuits.jl","title":"Performance tips:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Simulations of the linearized system can be effectively parallelized, so we suggest starting Julia with the number of threads equal to the number of physical cores. See the Julia documentation for the procedure. Check how many threads you are using by calling Threads.nthreads(). For context, the simulation times reported for the examples above use 16 threads on an AMD Ryzen 9 7950X system running Linux.","category":"page"},{"location":"#References:","page":"JosephsonCircuits.jl","title":"References:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Andrew J. Kerman \"Efficient numerical simulation of complex Josephson quantum circuits\" arXiv:2010.14929 (2020) \nJi&#345;&#237; Vlach and Kishore Singhal \"Computer Methods for Circuit Analysis and Design\" 2nd edition, Springer New York, NY (1993)\nStephen A. Maas \"Nonlinear Microwave and RF Circuits\" 2nd edition, Artech House (1997)\nJos&#233; Carlos Pedro, David E. Root, Jianjun Xu, and Lu&#237;s C&#243;timos Nunes. \"Nonlinear Circuit Simulation and Modeling: Fundamentals for Microwave Design\" The Cambridge RF and Microwave Engineering Series, Cambridge University Press (2018)\nDavid E. Root, Jan Verspecht, Jason Horn, and Mihai Marcu. \"X-Parameters: Characterization, Modeling, and Design of Nonlinear RF and Microwave Components\" The Cambridge RF and microwave engineering series, Cambridge University Press (2013)\nKaidong Peng, Rick Poore, Philip Krantz, David E. Root, and Kevin P. O'Brien \"X-parameter based design and simulation of Josephson traveling-wave parametric amplifiers for quantum computing applications\" IEEE International Conference on Quantum Computing & Engineering (QCE22) (2022)","category":"page"},{"location":"#Philosophy:","page":"JosephsonCircuits.jl","title":"Philosophy:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"The motivation for developing this package is to simulate the gain and noise performance of ultra low noise amplifiers for quantum computing applications such as the Josephson traveling-wave parametric amplifier, which have thousands of linear and nonlinear circuit elements. ","category":"page"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"We prioritize speed (including compile time and time to first use), simplicity, and scalability.","category":"page"},{"location":"#Future-developments:","page":"JosephsonCircuits.jl","title":"Future developments:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Design optimization.\nMore nonlinear components such as kinetic inductors.\nTime domain simulations.","category":"page"},{"location":"#Related-packages-and-software:","page":"JosephsonCircuits.jl","title":"Related packages and software:","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"Xyce.jl provides a wrapper for Xyce, the open source parallel circuit simulator from Sandia National Laboratories which can perform time domain and harmonic balance method simulations.\nNgSpice.jl and LTspice.jl provide wrappers for NgSpice and LTspice, respectively.  \nModelingToolkit.jl supports time domain circuit simulations from scratch and using their standard library\nACME.jl simulates electrical circuits in the time domain with an emphasis on audio effect circuits.\nCedar EDA is a Julia-based commercial cloud service for circuit simulations.\nKeysight ADS, Cadence AWR, Cadence Spectre RF, and Qucs are capable of time and frequency domain analysis of nonlinear circuits. WRSPICE performs time domain simulations of Josephson junction containing circuits and frequency domain simulations of linear circuits.","category":"page"},{"location":"#Funding","page":"JosephsonCircuits.jl","title":"Funding","text":"","category":"section"},{"location":"","page":"JosephsonCircuits.jl","title":"JosephsonCircuits.jl","text":"We gratefully acknowledge funding from the AWS Center for Quantum Computing and the MIT Center for Quantum Engineering (CQE).","category":"page"}]
}
