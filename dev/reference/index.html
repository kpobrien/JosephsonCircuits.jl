<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · JosephsonCircuits</title><meta name="title" content="Reference · JosephsonCircuits"/><meta property="og:title" content="Reference · JosephsonCircuits"/><meta property="twitter:title" content="Reference · JosephsonCircuits"/><meta name="description" content="Documentation for JosephsonCircuits."/><meta property="og:description" content="Documentation for JosephsonCircuits."/><meta property="twitter:description" content="Documentation for JosephsonCircuits."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JosephsonCircuits</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">JosephsonCircuits.jl</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kpobrien/JosephsonCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.CircuitGraph" href="#JosephsonCircuits.CircuitGraph"><code>JosephsonCircuits.CircuitGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircuitGraph(edge2indexdict, Rbn, searray, cearray, glearray, lvarray,
    isolatednodes, gl, Nbranches)</code></pre><p>A simple structure to hold the circuit graph information.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.CircuitMatrices" href="#JosephsonCircuits.CircuitMatrices"><code>JosephsonCircuits.CircuitMatrices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircuitMatrices(Cnm::SparseMatrixCSC, Gnm::SparseMatrixCSC, Lb::SparseVector
    Lbm::SparseVector, Ljb::SparseVector, Ljbm::SparseVector,
    Mb::SparseMatrixCSC, invLnm::SparseMatrixCSC,
    Rbnm::SparseMatrixCSC{Int, Int}, portindices::Vector{Int},
    portnumbers::Vector{Int}, portimpedanceindices::Vector{Int}
    noiseportimpedanceindices::Vector{Int}, Lmean, vvn)</code></pre><p>A simple structure to hold the circuit matrices including the capacitance matrix, the conductance matrix, the inductance vectors, the Josephson inductance vectors, the mutual inductance matrix, the inverse inductance matrix, the incidence matrix, the dictionary of port and resistor values where the nodes are the keys and the values are the values, and the mean of the inductances. See also <a href="#JosephsonCircuits.numericmatrices-Tuple{Any, Any}"><code>numericmatrices</code></a> and <a href="#JosephsonCircuits.symbolicmatrices-Tuple{Any}"><code>symbolicmatrices</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>Cnm::SparseMatrixCSC</code>: the capacitance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.</li><li><code>Gnm::SparseMatrixCSC</code>: the conductance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.</li><li><code>Lb::SparseVector</code>: vector of branch linear inductances.</li><li><code>Lbm::SparseVector</code>: vector of branch linear inductances with each element   duplicated Nmodes times.</li><li><code>Ljb::SparseVector</code>: vector of branch Josephson junction inductances.</li><li><code>Ljbm::SparseVector</code>: vector of branch Josephson junction inductances with   each element duplicated Nmodes times.</li><li><code>Mb::SparseMatrixCSC</code>: the mutual inductance matrix in the branch basis with   each element duplicated along the diagonal Nmodes times.</li><li><code>invLnm::SparseMatrixCSC</code>: the inverse inductance matrix in the node basis   with each element duplicated along the diagonal Nmodes times.</li><li><code>Rbnm::SparseMatrixCSC{Int, Int}</code>: incidence matrix to convert between the   node and branch bases.</li><li><code>portindices::Vector{Int}</code>: vector of indices at which ports occur.</li><li><code>portnumbers::Vector{Int}</code>: vector of port numbers.</li><li><code>portimpedanceindices::Vector{Int}</code>: vector of indices at which port   impedances occur.</li><li><code>noiseportimpedanceindices::Vector{Int}</code>: vector of indices at which   resistive elements other than port impedances occur, for noise   calculations.</li><li><code>Lmean</code>: the mean of all of the geometric and Josephson inductances.</li><li><code>vvn</code>: the vector of component values with numbers substituted in.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.FactorizationCache" href="#JosephsonCircuits.FactorizationCache"><code>JosephsonCircuits.FactorizationCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FactorizationCache(factorization)</code></pre><p>A cache for the factorization object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.FactorizationCache(JosephsonCircuits.KLU.klu(JosephsonCircuits.sparse([1, 2], [1, 2], [1/2, 1/2], 2, 2)));
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.FourierIndices" href="#JosephsonCircuits.FourierIndices"><code>JosephsonCircuits.FourierIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierIndices(conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}},
    vectomatmap::Vector{Int}, conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int}, hbmatmodes::Matrix{NTuple{N, Int}},
    hbmatindices::Matrix{Int})</code></pre><p>A simple structure to hold time and frequency domain information for the signals, particularly the indices for converting between the node flux vectors and matrices. See also <a href="#JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}"><code>fourierindices</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.Frequencies" href="#JosephsonCircuits.Frequencies"><code>JosephsonCircuits.Frequencies</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Frequencies(Nharmonics::NTuple{N, Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int},
    coords::Vector{CartesianIndex{N}}, modes::Vector{NTuple{N,Int})</code></pre><p>A simple structure to hold time and frequency domain information for the signals. See also <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>Nharmonics::NTuple{N, Int}</code>: The number of harmonics for each frequency.</li><li><code>Nw::NTuple{N,Int}</code>: The dimensions of the frequency domain signal for a   single node.</li><li><code>Nt::NTuple{N,Int}</code>: The dimensions of the time domain signal for a single   node.</li><li><code>coords::Vector{CartesianIndex{N}}</code>: The coordinates of each mixing products.</li><li><code>modes::Vector{NTuple{N,Int}}</code>: The mode indices of each mixing product, eg.    (0,0), (1,0), (2,1).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nharmonics = (2,1)
Nw = (3, 3)
Nt = (4, 3)
coords = CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)]
modes = [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)]
JosephsonCircuits.Frequencies(Nharmonics, Nw,Nt,coords,modes)

# output
JosephsonCircuits.Frequencies{2}((2, 1), (3, 3), (4, 3), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.HB" href="#JosephsonCircuits.HB"><code>JosephsonCircuits.HB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HB(nonlinear, linearized)</code></pre><p>A simple structure to hold the nonlinear and linearized harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>nonlinear</code>: nonlinear harmonic balance solution for pump and pump   harmonics. See <a href="#JosephsonCircuits.NonlinearHB"><code>NonlinearHB</code></a>.</li><li><code>linearized</code>: linearized harmonic balance solution.   See <a href="#JosephsonCircuits.LinearizedHB"><code>LinearizedHB</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.LinearizedHB" href="#JosephsonCircuits.LinearizedHB"><code>JosephsonCircuits.LinearizedHB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizedHB(S, Snoise, QE, QEideal, CM, nodeflux, voltage, Nmodes, Nnodes,
    Nbranches, signalindex, w)</code></pre><p>A simple structure to hold the linearized harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>w</code>: the signal frequencies.</li><li><code>modes</code>: tuple of the signal mode indices where (0,) is the signal.</li><li><code>S</code>: the scattering matrix relating inputs and outputs for each combination   of port and frequency.</li><li><code>Snoise</code>: the scattering matrix relating inputs at the noise ports.   (lossy devices) and outputs at the physical ports for each combination of   port and frequency.</li><li><code>Ssensitivity</code>:</li><li><code>Z</code>:</li><li><code>Zadjoint</code>: </li><li><code>Zsensitivity</code>: </li><li><code>Zsensitivityadjoint</code>: </li><li><code>QE</code>: the quantum efficiency for each combination of port and frequency.</li><li><code>QEideal</code>: the quantum efficiency for an ideal amplifier with the same level   of gain, for each combination of port and frequency.</li><li><code>CM</code>: the commutation relations (equal to ±1), for each combination of port   and frequency.</li><li><code>nodeflux</code>: the node fluxes resulting from inputs at each frequency and port.</li><li><code>nodefluxadjoint</code>: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.</li><li><code>voltage</code>: the node voltages resulting from inputs at each frequency and port.</li><li><code>voltageadjoint</code>: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.</li><li><code>nodenames</code>: the vector of unique node strings.</li><li><code>nodeindices</code>:</li><li><code>componentnames</code>:</li><li><code>componenttypes</code>:</li><li><code>componentnamedict</code>:</li><li><code>mutualinductorbranchnames</code>:</li><li><code>portnumbers</code>: vector of port numbers.</li><li><code>portindices</code>:</li><li><code>portimpedanceindices</code>:</li><li><code>noiseportimpedanceindices</code>:</li><li><code>sensitivitynames</code>:</li><li><code>sensitivityindices</code>:</li><li><code>Nmodes</code>: the number of signal and idler frequencies.</li><li><code>Nnodes</code>: the number of nodes in the circuit (including the ground node).</li><li><code>Nbranches</code>: the number of branches in the circuit.</li><li><code>Nports</code>: the number of ports.</li><li><code>signalindex</code>: the index of the signal mode.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.NonlinearHB" href="#JosephsonCircuits.NonlinearHB"><code>JosephsonCircuits.NonlinearHB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonlinearHB(nodeflux, Rbnm, Ljb, Lb, Ljbm, Nmodes, Nbranches, S)</code></pre><p>A simple structure to hold the nonlinear harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>w</code>: a tuple containing the the angular frequency of the pump in radians/s.</li><li><code>frequencies</code>:</li><li><code>nodeflux</code>: the node fluxes resulting from inputs at each frequency and   port.</li><li><code>Rbnm</code>: incidence matrix to convert between the node and branch basis.</li><li><code>Ljb</code>: sparse vector of Josephson junction inductances.</li><li><code>Lb</code>: sparse vector of linear inductances.</li><li><code>Ljbm</code>: sparse vector of linear inductances with each element duplicated   Nmodes times.</li><li><code>Nmodes</code>: the number of signal and idler frequencies.</li><li><code>Nbranches</code>: the number of branches in the circuit.</li><li><code>nodenames</code>: the vector of unique node name strings.</li><li><code>componentnames</code>: the vector of component name strings</li><li><code>portnumbers</code>: vector of port numbers.</li><li><code>portindices</code>: </li><li><code>modes</code>: tuple of the pump mode indices where (1,) is the pump in the single   pump case.</li><li><code>S</code>: the scattering matrix relating inputs and outputs for each combination   of port and frequency.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.ParsedCircuit" href="#JosephsonCircuits.ParsedCircuit"><code>JosephsonCircuits.ParsedCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsedCircuit(nodeindexvector::Vector{Int},
    uniquenodevector::Vector{String},
    mutualinductorbranchnames::Vector{String},
    componentnames::Vector{String}, componenttypes::Vector{Symbol},
    componentvalues::Vector, componentnamedict::Dict{String, Int},
    Nnodes::Int)</code></pre><p>A simple structure to hold the parsed circuit including a vector of node indices, the unique node names, the inductors coupled by the mutual inductors, the component names, the component types, the values of the components, a dictionary of the names of the components as keys and the index at which the component occurs as the value, and dictionaries for the ports and resistors where the pair of nodes is the key and value is the component value.</p><p>See also <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>nodeindexvector::Vector{Int}</code>: sorted vector of node indices where the   two nodes for each component occur as consecutive elements (pairs).</li><li><code>uniquenodevector::Vector{String}</code>: the unique node names.</li><li><code>mutualinductorbranchnames::Vector{String}</code>: the inductors coupled by the   mutual inductors.</li><li><code>componentnames::Vector{String}</code>: component names.</li><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering)   types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>componentnamedict::Dict{String, Int}</code>: names of the components as keys and   the index at which the component occurs as the value.</li><li><code>Nnodes::Int</code>: number of nodes including the ground node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
println(JosephsonCircuits.ParsedCircuit(
    [1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],
    [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3))

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.ParsedSortedCircuit" href="#JosephsonCircuits.ParsedSortedCircuit"><code>JosephsonCircuits.ParsedSortedCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsedSortedCircuit(nodeindices::Matrix{Int},
    nodenames::Vector{String},
    mutualinductorbranchnames::Vector{String},
    componentnames::Vector{String},
    componenttypes::Vector{Symbol}, componentvalues::Vector,
    componentnamedict::Dict{String, Int}, Nnodes::Int)</code></pre><p>A simple structure to hold the parsed and sorted circuit. See also <a href="#JosephsonCircuits.parsesortcircuit-Tuple{Any}"><code>parsesortcircuit</code></a>, <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>, and <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for more explanation.</p><p><strong>Fields</strong></p><ul><li><code>nodeindices::Matrix{Int}</code>: sorted array of node indices (where the length   of the first axis is 2).</li><li><code>nodenames::Vector{String}</code>: the sorted unique node names.</li><li><code>mutualinductorbranchnames::Vector{String}</code>: the inductors coupled by the   mutual inductors.</li><li><code>componentnames::Vector{String}</code>: component names.</li><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering) types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>componentnamedict::Dict{String, Int}</code>: names of the components as keys and   the index at which the component occurs as the value.</li><li><code>Nnodes::Int</code>: number of nodes including the ground node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
println(JosephsonCircuits.ParsedSortedCircuit(
    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],
    [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
    [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.SpiceRaw" href="#JosephsonCircuits.SpiceRaw"><code>JosephsonCircuits.SpiceRaw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpiceRaw(header::SpiceRawHeader, variables::Dict{String, Vector{String}},
    values::Dict{String,T})</code></pre><p>A simple structure to hold the SPICE raw file contents including the header, variables, and values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;), Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]), Dict{String, Matrix{ComplexF64}}(&quot;V&quot; =&gt; [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], &quot;Hz&quot; =&gt; [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))
JosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;), Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]), Dict{String, Matrix{ComplexF64}}(&quot;V&quot; =&gt; [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], &quot;Hz&quot; =&gt; [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.SpiceRawHeader" href="#JosephsonCircuits.SpiceRawHeader"><code>JosephsonCircuits.SpiceRawHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpiceRawHeader(title::String, date::String, plotname::String,
    flags::String, nvariables::Int, npoints::Int, command::String,
    option::String)</code></pre><p>A simple structure to hold the SPICE raw file header.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;)
JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.TouchstoneFile" href="#JosephsonCircuits.TouchstoneFile"><code>JosephsonCircuits.TouchstoneFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TouchstoneFile(f::Vector{Float64},
    N::Array{Complex{Float64}},
    frequencyunit::String,
    parameter::String,
    format::String,
    R::Float64,
    version::Float64,
    numberofports::Int,
    twoportdataorder::String,
    numberoffrequencies::Int,
    numberofnoisefrequencies::Int,
    reference::Vector{Float64},
    information::Vector{String},
    matrixformat::String,
    mixedmodeorder::Vector{Tuple{Char, Vector{Int}}},
    comments::Vector{String},
    networkdata::Vector{Float64},
    noisedata::Vector{Float64})</code></pre><p>A structure to hold the data contained in a Touchstone file. In most cases, the user will not generate the struct directly. Instead, they will load a Touchstone file with <a href="#JosephsonCircuits.touchstone_load-Tuple{Any}"><code>touchstone_load</code></a>, parse an IOStream or IOBuffer with <a href="#JosephsonCircuits.touchstone_parse-Tuple{IO}"><code>touchstone_parse</code></a>, or generate a TouchstoneFile struct with <a href="#JosephsonCircuits.touchstone_file-Tuple{AbstractVector{Float64}, Array{ComplexF64, 3}}"><code>touchstone_file</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.CMtokeyed-NTuple{4, Any}" href="#JosephsonCircuits.CMtokeyed-NTuple{4, Any}"><code>JosephsonCircuits.CMtokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CMtokeyed(CM, outputmodes, outputportnumbers, w)</code></pre><p>Convert a commutation relation array <code>CM</code> vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.CMtokeyed([1 2;3 4;;;],[(0,)],[1,2],[1.0,1.1])
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   freqindex ∈ 2-element UnitRange{Int64}
And data, 1×2×2 Array{Int64, 3}:
[:, :, 1] ~ (:, :, 1):
          (1)  (2)
   (0,)     1    3

[:, :, 2] ~ (:, :, 2):
          (1)  (2)
   (0,)     2    4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.IctoLj-Tuple{Any}" href="#JosephsonCircuits.IctoLj-Tuple{Any}"><code>JosephsonCircuits.IctoLj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IctoLj(Ic)</code></pre><p>Convert the junction critical current to inductance in SI base units. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; IctoLj(3.29105976e-6)
1.0e-10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.LjtoIc-Tuple{Any}" href="#JosephsonCircuits.LjtoIc-Tuple{Any}"><code>JosephsonCircuits.LjtoIc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LjtoIc(Lj)</code></pre><p>Convert the junction inductance to critical current in SI base units. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LjtoIc(100e-12)
3.29105976e-6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.Snoisetokeyed-NTuple{6, Any}" href="#JosephsonCircuits.Snoisetokeyed-NTuple{6, Any}"><code>JosephsonCircuits.Snoisetokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Snoisetokeyed(Snoise, inputmodes, components, outputmodes,
    outputportnumbers, w)</code></pre><p>Convert a noise scattering parameter array <code>Snoise</code> vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Snoisetokeyed([11 12;21 22;;;],[(0,)],[&quot;C1&quot;,&quot;C2&quot;],[(0,)],[1,2],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   inputmode ∈ 1-element Vector{Tuple{Int64}}
→   component ∈ 2-element Vector{String}
◪   outputmode ∈ 1-element Vector{Tuple{Int64}}
▨   outputport ∈ 2-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 1×2×1×2×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (&quot;C1&quot;)  (&quot;C2&quot;)
   (0,)   11      21

[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):
          (&quot;C1&quot;)  (&quot;C2&quot;)
   (0,)   12      22</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.Stokeyed-NTuple{5, Any}" href="#JosephsonCircuits.Stokeyed-NTuple{5, Any}"><code>JosephsonCircuits.Stokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Stokeyed(S, outputmodes, outputportnumbers, inputmodes, inputportnumbers)</code></pre><p>Convert a scattering parameter array <code>S</code> to a keyed array. Returned the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Stokeyed([11 12;21 22],[(0,)],[1,2],[(0,)],[1,2])
4-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   inputmode ∈ 1-element Vector{Tuple{Int64}}
▨   inputport ∈ 2-element Vector{Int64}
And data, 1×2×1×2 Array{Int64, 4}:
[:, :, 1, 1] ~ (:, :, (0,), 1):
          (1)  (2)
   (0,)    11   21

[:, :, 1, 2] ~ (:, :, (0,), 2):
          (1)  (2)
   (0,)    12   22</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.Stokeyed-NTuple{6, Any}" href="#JosephsonCircuits.Stokeyed-NTuple{6, Any}"><code>JosephsonCircuits.Stokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Stokeyed(S, outputmodes, outputportnumbers, inputmodes, 
    inputportnumbers, w)</code></pre><p>Convert a scattering parameter array <code>S</code> vs frequency <code>w</code> to a keyed array. Returned the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Stokeyed([11 12;21 22;;;],[(0,)],[1,2],[(0,)],[1,2],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   inputmode ∈ 1-element Vector{Tuple{Int64}}
▨   inputport ∈ 2-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 1×2×1×2×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (1)  (2)
   (0,)    11   21

[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):
          (1)  (2)
   (0,)    12   22</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.addsources!-NTuple{11, Any}" href="#JosephsonCircuits.addsources!-NTuple{11, Any}"><code>JosephsonCircuits.addsources!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addsources!(bbm, modes, sources, portindices, portnumbers,
    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)</code></pre><p>Calculate the source terms in the branch basis. Overwrite bbm with the output. See also <a href="#JosephsonCircuits.calcsources-NTuple{10, Any}"><code>calcsources</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T" href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>JosephsonCircuits.applynl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">applynl!(fd::Array{Complex{T}}, td::Array{T}, f::Function, irfftplan,
    rfftplan)</code></pre><p>Apply the nonlinear function f to the frequency domain data by transforming to the time domain, applying the function, then transforming back to the frequency domain, overwriting the contents of fd and td in the process. We use plans for the forward and reverse RFFT prepared by <a href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>plan_applynl</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">fd=ones(Complex{Float64},3,2)
td, irfftplan, rfftplan = JosephsonCircuits.plan_applynl(fd)
JosephsonCircuits.applynl!(fd, td, cos, irfftplan, rfftplan)
fd

# output
3×2 Matrix{ComplexF64}:
  0.586589+0.0im   0.586589+0.0im
 -0.413411+0.0im  -0.413411+0.0im
 -0.413411+0.0im  -0.413411+0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.applynl-Tuple{Array{ComplexF64}, Any}" href="#JosephsonCircuits.applynl-Tuple{Array{ComplexF64}, Any}"><code>JosephsonCircuits.applynl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">applynl(am::Array{Complex{Float64}}, f::Function)</code></pre><p>Perform the inverse discrete Fourier transform on an array <code>am</code> of complex frequency domain data, apply the function <code>f</code> in the time domain, then perform the discrete Fourier transform to return to the frequency domain. Apply the Fourier transform on all but the last dimensions. See also <a href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>applynl!</code></a> and <a href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>plan_applynl</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.applynl([[0, 0.2+0.0im, 0, 0];;],cos)
4×1 Matrix{ComplexF64}:
   0.9603980498951228 + 0.0im
                  0.0 + 0.0im
 -0.01966852794611884 + 0.0im
                  0.0 + 0.0im

julia&gt; JosephsonCircuits.applynl([[0, 0.2+0.0im];;],cos)
2×1 Matrix{ComplexF64}:
   0.9603980498951228 + 0.0im
 -0.01966852794611884 + 0.0im

julia&gt; JosephsonCircuits.applynl([0.0 + 0.0im 0.45 + 0.0im 0.45 + 0.0im; 0.55 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;],sin)
3×3×1 Array{ComplexF64, 3}:
[:, :, 1] =
 -0.0209812+0.0im   0.295151+0.0im   0.295151+0.0im
   0.359826+0.0im  -0.041417+0.0im  -0.041417+0.0im
 0.00788681+0.0im  -0.110947+0.0im  -0.110947+0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.arraytonetworkdata-NTuple{11, Any}" href="#JosephsonCircuits.arraytonetworkdata-NTuple{11, Any}"><code>JosephsonCircuits.arraytonetworkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arraytonetworkdata(frequencies,N, numberofports, numberoffrequencies,
    matrixformat, twoportdataorder, parameter, frequencyunit, format, R,
    version)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">frequencies = 4.0e9:5.0e8:6.0e9
N = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]
numberofports = 1
numberoffrequencies = 5
matrixformat = &quot;Full&quot;
twoportdataorder = &quot;12_21&quot;
parameter = &quot;S&quot;
frequencyunit = &quot;GHz&quot;
format = &quot;MA&quot;
R = 50.0
version = 2.0
JosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports, numberoffrequencies, 
    matrixformat, twoportdataorder, parameter, frequencyunit, format, R, version)

# output
15-element Vector{Float64}:
   4.0
   0.9995813511383583
 -17.248815971093425
   4.5
   0.9958480363660398
 -26.451285931791276
   5.0
   0.9868361175866559
   2.711906450972103
   5.5
   0.9985678550072272
 -12.21545548845392
   6.0
   0.9993761539770525
 -16.045248853866596</code></pre><pre><code class="language-julia hljs">frequencies = 4.0e9:5.0e8:6.0e9
N = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]
numberofports = 1
numberoffrequencies = 5
matrixformat = &quot;Lower&quot;
twoportdataorder = &quot;12_21&quot;
parameter = &quot;Z&quot;
frequencyunit = &quot;GHz&quot;
format = &quot;MA&quot;
R = 50.0
version = 2.0
JosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports,
    numberoffrequencies, matrixformat, twoportdataorder, parameter,
    frequencyunit, format, R, version)

# output
15-element Vector{Float64}:
   4.0
   0.9995813511383583
 -17.248815971093425
   4.5
   0.9958480363660398
 -26.451285931791276
   5.0
   0.9868361175866559
   2.711906450972103
   5.5
   0.9985678550072272
 -12.21545548845392
   6.0
   0.9993761539770525
 -16.045248853866596</code></pre><pre><code class="language-julia hljs">frequencies = 4.0e9:5.0e8:6.0e9
N = [0.9546262517670427 - 0.296397700700921im;;; 0.8915960960938982 - 0.44358732281729774im;;; 0.9857309246425359 + 0.046691189499470154im;;; 0.9759591344506418 - 0.21128542054786678im;;; 0.9604441706426364 - 0.2762239892126382im]
numberofports = 1
numberoffrequencies = 5
matrixformat = &quot;Lower&quot;
twoportdataorder = &quot;12_21&quot;
parameter = &quot;Z&quot;
frequencyunit = &quot;GHz&quot;
format = &quot;MA&quot;
R = 50.0
version = 1.0
JosephsonCircuits.arraytonetworkdata(frequencies,N, numberofports,
    numberoffrequencies, matrixformat, twoportdataorder, parameter,
    frequencyunit, format, R, version)

# output
15-element Vector{Float64}:
   4.0
   0.019991627022767165
 -17.248815971093425
   4.5
   0.019916960727320795
 -26.451285931791276
   5.0
   0.01973672235173312
   2.7119064509721027
   5.5
   0.019971357100144544
 -12.215455488453918
   6.0
   0.019987523079541047
 -16.0452488538666</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcAoLjbm-Tuple{Any, SparseArrays.SparseVector, Any, Any, Any}" href="#JosephsonCircuits.calcAoLjbm-Tuple{Any, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcAoLjbm(Am, Ljb::SparseVector, Lmean, Nmodes, Nbranches)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,2,1)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 A11 / Lj1  A31 / Lj1
 A31 / Lj1  A11 / Lj1

julia&gt; @syms Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,2,1).nzval
4-element Vector{Any}:
 A11 / Lj1
 A31 / Lj1
 conj(A31 / Lj1)
 A11 / Lj1

julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 A11 / Lj1  A31 / Lj1          ⋅          ⋅
 A31 / Lj1  A11 / Lj1          ⋅          ⋅
         ⋅          ⋅  A12 / Lj2  A32 / Lj2
         ⋅          ⋅  A32 / Lj2  A12 / Lj2

julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,3,1)
3×3 SparseArrays.SparseMatrixCSC{Num, Int64} with 9 stored entries:
 A11 / Lj1  A31 / Lj1          0
 A31 / Lj1  A11 / Lj1  A31 / Lj1
         0  A31 / Lj1  A11 / Lj1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcAoLjbm2-Tuple{Array, Matrix, SparseArrays.SparseVector, Any, Any, Any}" href="#JosephsonCircuits.calcAoLjbm2-Tuple{Array, Matrix, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcAoLjbm2(Am::Array, Amatrixindices::Matrix, Ljb::SparseVector, Lmean,
    Nmodes, Nbranches, Nfreq)</code></pre><p>Return the harmonic balance matrix divided by the Josephson inductance.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Amatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]
Amatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 18 stored entries:
 1.0+1.0im  1.0-1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im  0.5-0.5im
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5+0.5im</code></pre><pre><code class="language-julia hljs">Amatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]
Amatrixindices = [1 -2 0; 2 1 -2; 0 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 14 stored entries:
 1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
     ⋅      1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im      ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im
     ⋅          ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im</code></pre><pre><code class="language-julia hljs">@variables A11 A12 A21 A22 A31 A32 Lj1 Lj2
Amatrix = [A11 A12;A21 A22;A31 A32]
Amatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{Num, Int64} with 18 stored entries:
 A11 / Lj1  A21 / Lj1  A31 / Lj1          ⋅          ⋅          ⋅
 A21 / Lj1  A11 / Lj1  A21 / Lj1          ⋅          ⋅          ⋅
 A31 / Lj1  A21 / Lj1  A11 / Lj1          ⋅          ⋅          ⋅
         ⋅          ⋅          ⋅  A12 / Lj2  A22 / Lj2  A32 / Lj2
         ⋅          ⋅          ⋅  A22 / Lj2  A12 / Lj2  A22 / Lj2
         ⋅          ⋅          ⋅  A32 / Lj2  A22 / Lj2  A12 / Lj2</code></pre><pre><code class="language-julia hljs">@syms A11 A12 A21 A22 A31 A32 Lj1 Lj2
Amatrix = [A11 A12;A21 A22;A31 A32]
Amatrixindices = [1 0 0; 0 1 0; 0 0 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches).nzval

# output
6-element Vector{Any}:
 A11 / Lj1
 A11 / Lj1
 A11 / Lj1
 A12 / Lj2
 A12 / Lj2
 A12 / Lj2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcAoLjbmindices-Tuple{Matrix, SparseArrays.SparseVector, Any, Any, Any}" href="#JosephsonCircuits.calcAoLjbmindices-Tuple{Matrix, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbmindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcAoLjbmindices(Amatrixindices, Ljb::SparseVector, Nmodes, Nbranches,
    Nfreq)</code></pre><p>Return the sparse matrix containing the indices from the frequency domain RFFT data as well as the indices of the sparse matrix to conjugate.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
AoLjbmindices

# output
8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:
 1  2  3  4  ⋅  ⋅  ⋅  ⋅
 2  1  2  3  ⋅  ⋅  ⋅  ⋅
 3  2  1  2  ⋅  ⋅  ⋅  ⋅
 4  3  2  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  5  6  7  8
 ⋅  ⋅  ⋅  ⋅  6  5  6  7
 ⋅  ⋅  ⋅  ⋅  7  6  5  6
 ⋅  ⋅  ⋅  ⋅  8  7  6  5</code></pre><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 0; 2 1 -2 -3; 3 2 1 -2; 0 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
AoLjbmindices

# output
8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 28 stored entries:
 1  2  3  ⋅  ⋅  ⋅  ⋅  ⋅
 2  1  2  3  ⋅  ⋅  ⋅  ⋅
 3  2  1  2  ⋅  ⋅  ⋅  ⋅
 ⋅  3  2  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  5  6  7  ⋅
 ⋅  ⋅  ⋅  ⋅  6  5  6  7
 ⋅  ⋅  ⋅  ⋅  7  6  5  6
 ⋅  ⋅  ⋅  ⋅  ⋅  7  6  5</code></pre><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,3],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
for c in conjindicessorted;AoLjbmindices.nzval[c] = -AoLjbmindices.nzval[c];end;AoLjbmindices

# output
12×12 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:
 1  -2  -3  -4  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 2   1  -2  -3  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 3   2   1  -2  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 4   3   2   1  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  5  -6  -7  -8
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  6   5  -6  -7
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  7   6   5  -6
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  8   7   6   5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcCjIcmean-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector{String}, Dict, Dict}" href="#JosephsonCircuits.calcCjIcmean-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector{String}, Dict, Dict}"><code>JosephsonCircuits.calcCjIcmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcCjIcmean(componenttypes::Vector{Symbol}, nodeindexarray::Matrix{Int},
    componentvalues::Vector, componentnamedict::Dict,
    mutualinductorbranchnames::Vector{String}, countdict::Dict,
    indexdict::Dict)</code></pre><p>Calculate the junction properties including the max and min critical currents and ratios of critical current to junction capacitance. This is necessary in order to set the junction properties of the JJ model in WRSPICE.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">componenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]
nodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]
componentvalues = Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]
componentnamedict = Dict(&quot;R1&quot; =&gt; 2, &quot;Cc2&quot; =&gt; 6, &quot;Cj2&quot; =&gt; 8, &quot;Cj1&quot; =&gt; 5, &quot;P1&quot; =&gt; 1, &quot;Cc1&quot; =&gt; 3, &quot;Lj2&quot; =&gt; 7, &quot;Lj1&quot; =&gt; 4)
mutualinductorbranchnames = String[]
countdict = Dict((:Lj, 1, 4) =&gt; 1, (:C, 3, 4) =&gt; 1, (:C, 1, 4) =&gt; 1, (:Lj, 1, 3) =&gt; 1, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 1, (:C, 2, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:Lj, 1, 3, 1) =&gt; 4, (:C, 1, 3, 1) =&gt; 5, (:R, 1, 2, 1) =&gt; 2, (:C, 3, 4, 1) =&gt; 6, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 4, 1) =&gt; 8, (:Lj, 1, 4, 1) =&gt; 7)
Cj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,
    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)

# output
(3.141466134545454e-13, 3.1414661345454545e-7)</code></pre><pre><code class="language-julia hljs">componenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]
nodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]
componentvalues = Real[1, 50.0, 1.0e-13, 2.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]
componentnamedict = Dict(&quot;R1&quot; =&gt; 2, &quot;Cc2&quot; =&gt; 6, &quot;Cj2&quot; =&gt; 8, &quot;Cj1&quot; =&gt; 5, &quot;P1&quot; =&gt; 1, &quot;Cc1&quot; =&gt; 3, &quot;Lj2&quot; =&gt; 7, &quot;Lj1&quot; =&gt; 4)
mutualinductorbranchnames = String[]
countdict = Dict((:Lj, 1, 4) =&gt; 1, (:C, 3, 4) =&gt; 1, (:C, 1, 4) =&gt; 1, (:Lj, 1, 3) =&gt; 1, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 1, (:C, 2, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:Lj, 1, 3, 1) =&gt; 4, (:C, 1, 3, 1) =&gt; 5, (:R, 1, 2, 1) =&gt; 2, (:C, 3, 4, 1) =&gt; 6, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 4, 1) =&gt; 8, (:Lj, 1, 4, 1) =&gt; 7)
Cj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,
    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)

# output
(2.3187011945454545e-13, 2.3187011945454544e-7)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}" href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>JosephsonCircuits.calcCn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcCn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, Nmodes, Nnodes)</code></pre><p>Returns the node capacitance matrix from the capacitance values in <code>componentvalues</code> when <code>componenttypes</code> has the symbol <code>:C</code> with node indices from <code>nodeindices</code>. Other symbols are ignored. Capacitances to ground become diagonal elements. Capacitance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are <code>(Nnodes-1)*Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code> where <code>Nnodes</code> is the number of nodes including ground and <code>Nmodes</code> is the number of different frequencies. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[1.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅ 
  ⋅   2.0

julia&gt; JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.1  -0.1
 -0.1   2.1

julia&gt; JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],2,3)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.1    ⋅   -0.1    ⋅ 
   ⋅    1.1    ⋅   -0.1
 -0.1    ⋅    2.1    ⋅ 
   ⋅   -0.1    ⋅    2.1

julia&gt; @variables Cg1 Cg2;JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[Cg1,Cg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 Cg1    ⋅
   ⋅  Cg2

julia&gt; @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 Cc + Cg1       -Cc
      -Cc  Cc + Cg1

julia&gt; @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],2,3)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 Cc + Cg1         ⋅       -Cc         ⋅
        ⋅  Cc + Cg1         ⋅       -Cc
      -Cc         ⋅  Cc + Cg1         ⋅
        ⋅       -Cc         ⋅  Cc + Cg1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}" href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>JosephsonCircuits.calcGn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcGn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, Nmodes, Nnodes)</code></pre><p>Returns the node conductance matrix from the resistance values in <code>componentvalues</code> when <code>componenttypes</code> has the symbol <code>:R</code>. The node indices are taken from <code>nodeindices</code>. Conductances to ground are diagonal elements. Conductance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are <code>(Nnodes-1)</code> times <code>Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p>We have to calculate the inverse of the individual components so select a type that allows that.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[1.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅ 
  ⋅   0.5

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.01  -0.01
 -0.01   0.51

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[1 3 1;2 2 3],[1.0,100.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.01  -0.01
 -0.01   0.51

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],2,3)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.01    ⋅    -0.01    ⋅ 
   ⋅     1.01    ⋅    -0.01
 -0.01    ⋅     0.51    ⋅ 
   ⋅    -0.01    ⋅     0.51

julia&gt; @variables Rg1 Rg2;JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[Rg1,Rg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 1 / Rg1        ⋅
       ⋅  1 / Rg2

julia&gt; @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 1 / Rc + 1 / Rg1           -1 / Rc
          -1 / Rc  1 / Rc + 1 / Rg2

julia&gt; @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],2,3)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 1 / Rc + 1 / Rg1                 ⋅           -1 / Rc                 ⋅
                ⋅  1 / Rc + 1 / Rg1                 ⋅           -1 / Rc
          -1 / Rc                 ⋅  1 / Rc + 1 / Rg2                 ⋅
                ⋅           -1 / Rc                 ⋅  1 / Rc + 1 / Rg2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcIb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}" href="#JosephsonCircuits.calcIb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcIb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcIb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch current source vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:I,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:I1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ib = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Float64, Int64} with 1 stored entry:
  [1]  =  1.0e-9</code></pre><pre><code class="language-julia hljs">@variables I1 C1 L1 C2
Nmodes = 1
Nbranches = 2
componenttypes = [:I,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [I1, C1, L1, C2]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:I1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ib = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Num, Int64} with 1 stored entry:
  [1]  =  I1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}" href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcLb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch inductance vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Lb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0e-9
  [2]  =  4.0e-9</code></pre><pre><code class="language-julia hljs">@variables L1 K1 L2 C1
Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [L1, K1, L2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Lb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Num, Int64} with 2 stored entries:
  [1]  =  L1
  [2]  =  L2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}" href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcLjb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLjb(componenttypes, nodeindices, componentvalues, edge2indexdict,
    Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch Josephson inductance vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:Lj,:C,:Lj,:C]
nodeindices = [2 3 3 3; 1 2 1 1]
componentvalues = [1e-9, 1e-12, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:Cc =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ljb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0e-9
  [2]  =  4.0e-9</code></pre><pre><code class="language-julia hljs">@variables Lj1 K1 Lj2 C1
Nmodes = 1
Nbranches = 2
componenttypes = [:Lj,:K,:Lj,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [Lj1, K1, Lj2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:Lj2 =&gt; 3,:Lj1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ljb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Num, Int64} with 2 stored entries:
  [1]  =  Lj1
  [2]  =  Lj2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}" href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>JosephsonCircuits.calcLmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLmean(componenttypes::Vector{Symbol}, componentvalues::Vector)</code></pre><p>Return the mean of the linear and Josephson inductors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[10,4,5,1])
2.5

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[R1, L1, C1, Lj1])
(1//2)*(L1 + Lj1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector{Nothing}}" href="#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector{Nothing}}"><code>JosephsonCircuits.calcLmean_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLmean_inner(componenttypes::Vector, componentvalues::Vector,
    valuecomponenttypes::Vector{Nothing})</code></pre><p>Return the mean of the linear and Josephson inductors. Return 0 if the expected return type is Nothing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean_inner([:R,:C,:C,:P],[10,4,5,1],Nothing[])
0

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[R1, L1, C1, Lj1],Nothing[])
0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector}" href="#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector}"><code>JosephsonCircuits.calcLmean_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLmean_inner(componenttypes::Vector, componentvalues::Vector,
    valuecomponenttypes::Vector)</code></pre><p>Return the mean of the linear and Josephson inductors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean_inner([:R,:L,:C,:Lj],[10,4,5,1],Float64[])
2.5

julia&gt; JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[10,4,5,1],Float64[])
0.0

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean_inner([:R,:L,:C,:Lj],[R1, L1, C1, Lj1], Num[])
(1//2)*(L1 + Lj1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}" href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcMb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcMb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, componentnamedict::Dict,
    mutualinductorbranchnames::Vector, edge2indexdict::Dict, Nmodes,
    Nbranches)</code></pre><p>Returns the branch mutual inductance matrix. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 2e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
mutualinductorbranchnames = [ :L1, :L2]
Mb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)

# output
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
  ⋅           2.82843e-10
 2.82843e-10   ⋅ </code></pre><pre><code class="language-julia hljs">@variables L1 L2 K1 C1
Nmodes = 2
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [L1, K1, L2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
mutualinductorbranchnames = [ :L1, :L2]
Mb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)

# output
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
              ⋅               ⋅  K1*sqrt(L1*L2)               ⋅
              ⋅               ⋅               ⋅  K1*sqrt(L1*L2)
 K1*sqrt(L1*L2)               ⋅               ⋅               ⋅
              ⋅  K1*sqrt(L1*L2)               ⋅               ⋅</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcVb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}" href="#JosephsonCircuits.calcVb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcVb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcVb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch voltage source vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:V,:C,:L1,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:V1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Vb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Float64, Int64} with 1 stored entry:
  [1]  =  1.0e-9</code></pre><pre><code class="language-julia hljs">@variables V1 C1 L1 C2
Nmodes = 1
Nbranches = 2
componenttypes = [:V,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [V1, C1, L1, C2]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:V1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Vb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)

# output
2-element SparseArrays.SparseVector{Num, Int64} with 1 stored entry:
  [1]  =  V1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcbranchvector-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Dict, Any, Any, Symbol}" href="#JosephsonCircuits.calcbranchvector-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Dict, Any, Any, Symbol}"><code>JosephsonCircuits.calcbranchvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcbranchvector(componenttypes::Vector{Symbol},
    nodeindices::Matrix{Int}, componentvalues::Vector,
    valuecomponenttypes::Vector, edge2indexdict::Dict, Nmodes, Nbranches,
    component::Symbol)</code></pre><p>Calculate the sparse branch vector whose length is <code>Nbranches*Nmodes</code> for the given component symbol. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccircuitgraph-Tuple{JosephsonCircuits.ParsedSortedCircuit}" href="#JosephsonCircuits.calccircuitgraph-Tuple{JosephsonCircuits.ParsedSortedCircuit}"><code>JosephsonCircuits.calccircuitgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccircuitgraph(parsedsortedcircuit::ParsedSortedCircuit)</code></pre><p>Calculate the superconducting spanning tree, incidence matrix, closure branches, and loops from the parsed and sorted circuit.</p><p>See also <a href="#JosephsonCircuits.CircuitGraph"><code>CircuitGraph</code></a>, <a href="#JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}"><code>calcgraphs</code></a>, and <a href="#JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}"><code>extractbranches</code></a>  for more explanation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
psc = JosephsonCircuits.ParsedSortedCircuit(
    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],
    [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
    [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3)
cg = JosephsonCircuits.calccircuitgraph(psc)
# output
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L Lj Cj
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;2&quot;,L))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
# output
JosephsonCircuits.CircuitGraph(Dict((3, 2) =&gt; 3, (1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1, (2, 3) =&gt; 3), sparse([1, 3, 2, 3], [1, 1, 2, 2], [1, -1, 1, 1], 3, 2), [(1, 2), (1, 3)], [(3, 2)], [(1, 2), (1, 3), (2, 3)], [[1, 2, 3]], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm!-NTuple{4, Any}" href="#JosephsonCircuits.calccm!-NTuple{4, Any}"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm!(cm, S, Snoise, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables a b c d an bn cn dn;cm = Num[0, 0];JosephsonCircuits.calccm!(cm,Num[a b; c d],[an bn; cn dn],[1, -1]);cm
2-element Vector{Num}:
 abs2(a) + abs2(an) - abs2(b) - abs2(bn)
 abs2(c) + abs2(cn) - abs2(d) - abs2(dn)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm!-Tuple{Any, Any, Any}" href="#JosephsonCircuits.calccm!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm!(cm, S, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the field ladder operator basis. Overwrites cm with output. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables a b;cm=Num[0,0];JosephsonCircuits.calccm!(cm,[a b; b a],[-1,1]);cm
2-element Vector{Num}:
 abs2(b) - abs2(a)
 abs2(a) - abs2(b)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any, Any}} where T&lt;:AbstractFloat" href="#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any, Any}} where T&lt;:AbstractFloat"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm!(cm, S, Snoise, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output.  Use a compensated sum to reduce floating point errors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cm=Float64[0, 0];JosephsonCircuits.calccm!(cm,[1 2;3 4],[1 2 3 4;5 6 7 8],[-1,1]);cm
2-element Vector{Float64}:
 13.0
 33.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T&lt;:AbstractFloat" href="#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T&lt;:AbstractFloat"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm!(cm, S, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output. Use a compensated sum to reduce floating point errors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cm=Float64[0,0];JosephsonCircuits.calccm!(cm,[3/5 4/5;4/5 3/5],[-1,1]);cm
2-element Vector{Float64}:
  0.28000000000000014
 -0.28000000000000014</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Any}} where T" href="#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Any}} where T"><code>JosephsonCircuits.calccm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm(S, Snoise, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 1 1 1],[1 1e-100 2e-100 1;1 1 1 1],[1, -1])
2-element Vector{Float64}:
 6.0e-200
 0.0

julia&gt; JosephsonCircuits.calccm(Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],[1, -1])
2-element Vector{Float64}:
 6.0e-200
 0.0

julia&gt; @variables a b c d an bn cn dn;JosephsonCircuits.calccm([a b; c d],[an bn; cn dn],[1, -1])
2-element Vector{Num}:
 abs2(a) + abs2(an) - abs2(b) - abs2(bn)
 abs2(c) + abs2(cn) - abs2(d) - abs2(dn)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T" href="#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>JosephsonCircuits.calccm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calccm(S, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calccm(Complex{Float64}[3/5 4/5;4/5 3/5],[1])
2-element Vector{Float64}:
 1.0
 1.0

julia&gt; JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 0 0 1],[1, -1])
2-element Vector{Float64}:
 3.0e-200
 0.0

julia&gt; @variables a b;JosephsonCircuits.calccm([a b; b a],[1, -1])
2-element Vector{Num}:
 abs2(a) - abs2(b)
 abs2(b) - abs2(a)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcdZdroZ2-NTuple{5, Any}" href="#JosephsonCircuits.calcdZdroZ2-NTuple{5, Any}"><code>JosephsonCircuits.calcdZdroZ2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcdZdroZ2(sensitivityindices, componenttypes, componentvalues, wmodes,
    symfreqvar)</code></pre><p>Calculate 1/Z^2 times the derivative of Z with respect to parameter scaling the value of the circuit component. For example: Zc = 1/(im<em>w</em>Cg<em>r) 1/Zc^2</em>dZc/dr|_{r=1} = -im<em>Cg</em>w</p><p>Zl = im<em>w</em>Lj<em>r 1/Zl^2</em>dZl/dr =1/(im<em>Lj</em>r^2<em>w)|_{r=1} = 1/(im</em>Lj*w)</p><p>Zr = R<em>r 1/Zr^2</em>dZr/dr|_{r=1} = 1/(r^2*R) = 1/R</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:R], [50.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.02 + 0.0im

julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:C], [2.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.0 - 2.0im

julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:L], [2.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.0 - 0.5im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcfj!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 9}}" href="#JosephsonCircuits.calcfj!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 9}}"><code>JosephsonCircuits.calcfj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcfj(F,J,nodeflux,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,
    Ljbindicesm,Nmodes,Lmean,AoLjbm)</code></pre><p>Calculate the residual and the Jacobian. These are calculated with one function in order to reuse the time domain nonlinearity calculation.</p><p>Leave off the type signatures on F and J because the solver will pass a type of Nothing if it only wants to calculate F or J. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcfj2!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 18}}" href="#JosephsonCircuits.calcfj2!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix{Int64}, AbstractMatrix{Int64}, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 18}}"><code>JosephsonCircuits.calcfj2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcfj2(F,J,phin,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,
    Ljbindicesm,Nmodes,Lmean,AoLjbm)</code></pre><p>Calculate the residual and the Jacobian. These are calculated with one function in order to reuse as much as possible.</p><p>Leave off the type signatures on F and J because the solver will pass <code>nothing</code> if it only wants to calculate F or J.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcfreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N" href="#JosephsonCircuits.calcfreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N"><code>JosephsonCircuits.calcfreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcfreqs(Nharmonics::NTuple{N,Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the DFT or RFDT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array. See also <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N" href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>JosephsonCircuits.calcfreqsdft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcfreqsdft(Nharmonics::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the DFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain DFT array.</p><p><strong>Arguments</strong></p><ul><li><code>Nharmonics</code>: is a tuple of the number of harmonics to calculate for   each frequency.</li></ul><p><strong>Returns</strong></p><ul><li><code>Frequencies</code>: A simple structure to hold time and frequency domain   information for the signal for a single node. See <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcfreqsrdft((1,))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((2,))
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,))
JosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,3))
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N" href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>JosephsonCircuits.calcfreqsrdft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcfreqsrdft(Nharmonics::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the RDFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array.</p><p><strong>Arguments</strong></p><ul><li><code>Nharmonics</code>: is a tuple of the number of harmonics to calculate for   each frequency.</li></ul><p><strong>Returns</strong></p><ul><li><code>Frequencies</code>: A simple structure to hold time and frequency domain   information for the signal for a single node. See <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcfreqsrdft((1,))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((2,))
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,))
JosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,3))
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}" href="#JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}"><code>JosephsonCircuits.calcgraphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcgraphs(Ledgearray::Array{Tuple{Int, Int}, 1}, Nnodes::Int)</code></pre><p>Calculate the superconducting spanning tree, closure branches, and loops. Accepts the graph of linear inductors and Josephson junctions. Outputs lists of edges that can be used to generate graphs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (2, 1), (3, 1)], 3)
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)

julia&gt; JosephsonCircuits.calcgraphs([(4, 3), (3, 6), (5, 3), (3, 7), (2, 4), (6, 8), (2, 5), (8, 7), (2, 8)], 8)
JosephsonCircuits.CircuitGraph(Dict((6, 8) =&gt; 8, (2, 5) =&gt; 2, (3, 7) =&gt; 7, (6, 3) =&gt; 6, (7, 8) =&gt; 9, (3, 4) =&gt; 4, (7, 3) =&gt; 7, (2, 8) =&gt; 3, (4, 2) =&gt; 1, (8, 6) =&gt; 8…), sparse([1, 2, 3, 4, 5, 6, 7, 1, 4, 2, 5, 6, 8, 7, 9, 3, 8, 9], [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7], [-1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1], 9, 7), [(2, 4), (2, 5), (2, 8), (3, 4), (3, 6), (3, 7)], [(5, 3), (8, 6), (8, 7)], [(2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (3, 7), (6, 8), (7, 8)], [[2, 4, 3, 5], [2, 4, 3, 6, 8], [2, 4, 3, 7, 8]], [1], Graphs.SimpleGraphs.SimpleGraph{Int64}(9, [Int64[], [4, 5, 8], [4, 5, 6, 7], [2, 3], [2, 3], [3, 8], [3, 8], [2, 6, 7]]), 9)

julia&gt; JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (3, 1)],4)
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 3), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcimpedance-NTuple{4, Any}" href="#JosephsonCircuits.calcimpedance-NTuple{4, Any}"><code>JosephsonCircuits.calcimpedance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcimpedance(c, type, w, symfreqvar)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:R,2.0,w)
60.0 + 0.0im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:C,2.0,w)
0.0 - 0.008333333333333333im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:R,-2.0,w)
-60.0 + 0.0im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:C,-2.0,w)
0.0 - 0.008333333333333333im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcimpedance-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Any, Any, Any}} where T&lt;:Union{AbstractFloat, Integer}" href="#JosephsonCircuits.calcimpedance-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Any, Any, Any}} where T&lt;:Union{AbstractFloat, Integer}"><code>JosephsonCircuits.calcimpedance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcimpedance(c::Union{Integer,T,Complex{T}}, type, w, symfreqvar,
    ) where {T&lt;:AbstractFloat}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcimpedance(30.0,:C,1.0,nothing)
0.0 - 0.03333333333333333im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:R,1.0,nothing)
30.0 + 0.0im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:C,-1.0,nothing)
-0.0 + 0.03333333333333333im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:R,-1.0,nothing)
30.0 + 0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcindexdict-Tuple{Any}" href="#JosephsonCircuits.calcindexdict-Tuple{Any}"><code>JosephsonCircuits.calcindexdict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcindexdict(N::Int)</code></pre><p>Return a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindexdict(3)
Dict{CartesianIndex{1}, Int64} with 3 entries:
  CartesianIndex(2,) =&gt; 2
  CartesianIndex(3,) =&gt; 3
  CartesianIndex(1,) =&gt; 1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcindexdict-Tuple{Tuple}" href="#JosephsonCircuits.calcindexdict-Tuple{Tuple}"><code>JosephsonCircuits.calcindexdict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcindexdict(N::Tuple)</code></pre><p>Return a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindexdict((2,3))
Dict{CartesianIndex{2}, Int64} with 6 entries:
  CartesianIndex(2, 3) =&gt; 6
  CartesianIndex(2, 1) =&gt; 2
  CartesianIndex(1, 3) =&gt; 5
  CartesianIndex(1, 1) =&gt; 1
  CartesianIndex(2, 2) =&gt; 4
  CartesianIndex(1, 2) =&gt; 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcindices-Tuple{Integer}" href="#JosephsonCircuits.calcindices-Tuple{Integer}"><code>JosephsonCircuits.calcindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcindices(m::Integer)</code></pre><p>The indices over which to calculate the idlers using the formula ws+2<em>i</em>wp  where i is an index. This could be defined differently without causing any issues.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindices(7)
-3:3

julia&gt; JosephsonCircuits.calcindices(8)
-4:3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinputcurrentoutputvoltage!-NTuple{8, Any}" href="#JosephsonCircuits.calcinputcurrentoutputvoltage!-NTuple{8, Any}"><code>JosephsonCircuits.calcinputcurrentoutputvoltage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinputcurrentoutputvoltage!(inputcurrent, outputvoltage, nodeflux,
    bnm, inputportindices, outputportindices, nodeindices, wmodes)</code></pre><p>Calculate the elements of the Z matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]
symfreqvar = nothing
JosephsonCircuits.calcinputcurrentoutputvoltage!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,nodeindices,wmodes)
println(inputwave)
println(outputwave)

# output
ComplexF64[-1.0 + 0.0im;;]
ComplexF64[-100.0 + 0.0im;;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinputoutput!-NTuple{12, Any}" href="#JosephsonCircuits.calcinputoutput!-NTuple{12, Any}"><code>JosephsonCircuits.calcinputoutput!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinputoutput!(inputwave, outputwave, phin, bnm, inputportindices,
    outputportindices, inputportimpedances, outputportimpedances,
    nodeindices, componenttypes, wmodes, symfreqvar)</code></pre><p>Return the input and output waves for the system linearized around the strong pump.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[0;0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(inputwave)
println(outputwave)

# output
ComplexF64[3.5355339059327378 + 0.0im;;]
ComplexF64[-3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[50/(im*wmodes[1]);0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(inputwave)
println(outputwave)

# output
ComplexF64[3.5355339059327378 + 0.0im;;]
ComplexF64[3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [1 1 1 1 0 1 1; 2 2 2 2 0 3 3;]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[50/(im*wmodes[1]);0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(inputwave)
println(outputwave)

# output
ComplexF64[-3.5355339059327378 - 0.0im;;]
ComplexF64[-3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[0;0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(inputwave)
println(outputwave)

# output
ComplexF64[-3.5355339059327378 + 0.0im;;]
ComplexF64[3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(inputwave)
println(outputwave)

# output
ComplexF64[-3.5355339059327378 + 0.0im;;]
ComplexF64[-10.606601717798213 + 0.0im;;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinputoutput_inner!-NTuple{13, Any}" href="#JosephsonCircuits.calcinputoutput_inner!-NTuple{13, Any}"><code>JosephsonCircuits.calcinputoutput_inner!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinputoutput_inner!(inputwave, outputwave, phin, bnm, inputportindices,
    outputportindices, inputportimpedances, outputportimpedances,
    nodeindices, componenttypes, wmodes, symfreqvar, nosource)</code></pre><p>Calculate the input and output power waves as defined in (except in units of sqrt(photons/second) instead of sqrt(power) K. Kurokawa, &quot;Power Waves and the Scattering Matrix&quot;, IEEE Trans. Micr. Theory and Tech. 13, 194–202 (1965)  doi: 10.1109/TMTT.1965.1125964 inputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * (portvoltage + portimpedance * portcurrent) we can simplify the above to: inputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * portimpedance * sourcecurrent outputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * (portvoltage - conj(portimpedance) * portcurrent)</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinputoutputnoise!-NTuple{12, Any}" href="#JosephsonCircuits.calcinputoutputnoise!-NTuple{12, Any}"><code>JosephsonCircuits.calcinputoutputnoise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinputoutputnoise!(S, inputwave, outputwave, phin, bnm,
    inputportindices, outputportindices, inputportimpedances,
    outputportimpedances, nodeindices, componenttypes, wmodes, symfreqvar)</code></pre><p>Return the input and output waves for the system linearized around the strong pump.</p><p>This is a bit of a hack but I ran into issues with complex capacitance when the capacitor was at the same branch as a current source. the calcS function would use that current source in calculating the output waves, which it should not do.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
noiseoutputwave = ComplexF64[0;;]
phin = ComplexF64[-2.5000000000007394e-10 - 0.000795774715459398im; 1.983790476804266e-20 + 3.141592641138603e-16im;;]
bnm = ComplexF64[1.0 + 0.0im; 0.0 + 0.0im;;]
portimpedanceindices = [2]
noiseportimpedanceindices = [6]
portimpedances = [50]
noiseportimpedances = [1]
nodeindices = [2 2 2 3 3 3; 1 1 3 1 1 1]
componenttypes = [:P, :R, :C, :Lj, :C, :R]
wmodes = [2*pi*5e9]
symfreqvar = nothing
JosephsonCircuits.calcinputoutputnoise!(inputwave,noiseoutputwave,
    phin,bnm,portimpedanceindices,noiseportimpedanceindices,
    portimpedances,noiseportimpedances,nodeindices,
    componenttypes,wmodes,symfreqvar)
println(inputwave)
println(noiseoutputwave)

# output
ComplexF64[1.994711402007163e-5 + 0.0im;;]
ComplexF64[-5.568327974762547e-11 + 3.516177070001411e-15im;;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}" href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>JosephsonCircuits.calcinvLn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinvLn(Lb::SparseVector, Rbn::SparseMatrixCSC, Nmodes)</code></pre><p>Returns the nodal inverse inductance matrix. Accepts the vector of branch inductances <code>Lb</code> and the incidence matrix <code>Rbn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0e9   ⋅ 
  ⋅     2.5e8</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 1 / L1       ⋅
      ⋅  1 / L2</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 2
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 1 / L1       ⋅       ⋅       ⋅
      ⋅  1 / L1       ⋅       ⋅
      ⋅       ⋅  1 / L2       ⋅
      ⋅       ⋅       ⋅  1 / L2</code></pre><pre><code class="language-julia hljs">Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([],Nothing[])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval

# output
Nothing[]</code></pre><pre><code class="language-julia hljs">@syms L1 L2
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval

# output
2-element Vector{Any}:
 1 / L1
 1 / L2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}" href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}"><code>JosephsonCircuits.calcinvLn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcinvLn(Lb::SparseVector, Mb::SparseMatrixCSC,
    Rbn::SparseMatrixCSC, Nmodes)</code></pre><p>Returns the nodal inverse inductance matrix. Accepts the vector of branch inductances <code>Lb</code>, the branch mutual inductance matrix <code>Mb</code>, and the incidence matrix <code>Rbn</code>.</p><p>Using ldiv instead of an inverse: (where the extra div is an escape sequence) Can solve A x = B with: x = A \ B or x = invA * B, so we can perform the inverse here with: s = RbnT * invL * Rbn or s = RbnT * (L \ Rbn), the latter of which should be faster and more numerically stable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 2
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [4e-10,4e-10])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes)

# output
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.04167e9    ⋅         -1.04167e8    ⋅ 
   ⋅          1.04167e9    ⋅         -1.04167e8
 -1.04167e8    ⋅          2.60417e8    ⋅ 
   ⋅         -1.04167e8    ⋅          2.60417e8</code></pre><pre><code class="language-julia hljs">@variables L1 L2 Lm
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm*(Lm / L1)) / (L2 + (-(Lm^2)) / L1)) / L1, (-(Lm / L1)) / (L2 + (-(Lm^2)) / L1), (-(Lm / (L2 + (-(Lm^2)) / L1))) / L1, 1.0 / (L2 + (-(Lm^2)) / L1)], 2, 2)</code></pre><pre><code class="language-julia hljs">@syms L1 L2 Lm
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm*(Lm / L1)) / (L2 + (-(Lm^2)) / L1)) / L1, (-(Lm / L1)) / (L2 + (-(Lm^2)) / L1), (-(Lm / (L2 + (-(Lm^2)) / L1))) / L1, 1.0 / (L2 + (-(Lm^2)) / L1)], 2, 2)</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([], [], Nothing[]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2], [1, 2], Num[1 / L1, 1 / L2], 2, 2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcmodefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Array{Tuple{Vararg{Int64, N}}, 1}}} where N" href="#JosephsonCircuits.calcmodefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Array{Tuple{Vararg{Int64, N}}, 1}}} where N"><code>JosephsonCircuits.calcmodefreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcmodefreqs(w::NTuple{N},modes::Vector{NTuple{N,Int}})</code></pre><p>Calculate the frequencies of the modes given a tuple of fundamental frequencies and a vector of tuples containing the mixing products and harmonics.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables wp1 wp2;JosephsonCircuits.calcmodefreqs((wp1, wp2),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])
6-element Vector{Num}:
          0
        wp1
       2wp1
        wp2
  wp1 + wp2
 wp2 + 2wp1

julia&gt; JosephsonCircuits.calcmodefreqs((1., 1.1),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])
6-element Vector{Float64}:
 0.0
 1.0
 2.0
 1.1
 2.1
 3.1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcnodematrix-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Any, Any, Symbol, Bool}" href="#JosephsonCircuits.calcnodematrix-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Any, Any, Symbol, Bool}"><code>JosephsonCircuits.calcnodematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcnodematrix(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, valuecomponenttypes::Vector, Nmodes, Nnodes,
    component::Symbol, invert::Bool)</code></pre><p>Returns either the capacitance or conductance matrix depending on the values of <code>component</code> and <code>invert</code>. <code>:C</code> and <code>false</code> for capacitance and <code>:R</code> and <code>true</code> for conductance. The dimensions of the output are <code>(Nnodes-1)</code> times <code>Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcnodes-Tuple{Int64, Int64, Vector{Symbol}, Matrix, Dict, Vector{String}}" href="#JosephsonCircuits.calcnodes-Tuple{Int64, Int64, Vector{Symbol}, Matrix, Dict, Vector{String}}"><code>JosephsonCircuits.calcnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcnodes(nodeindex::Int, mutualinductorindex::Int,
    componenttypes::Vector{Symbol}, nodeindexarray::Matrix,
    componentnamedict::Dict, mutualinductorbranchnames::Vector{String})</code></pre><p>Calculate the two nodes (or mutual inductor indices) given the index in the typvector and the component type. For component types where order matters, such as mutual inductors, the nodes are not sorted. For other component types where order does not matter, the nodes are sorted. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables R Cc L1 L2 Cj1 Cj2 I1 V1
@variables Ipump Rleft L1 K1 K2 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;,K2))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = JosephsonCircuits.parsesortcircuit(circuit)
println(JosephsonCircuits.calcnodes(1,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))
println(JosephsonCircuits.calcnodes(5,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))

# output
(1, 2)
(4, 7)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcnodesorting-Tuple{Vector{String}}" href="#JosephsonCircuits.calcnodesorting-Tuple{Vector{String}}"><code>JosephsonCircuits.calcnodesorting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcnodesorting(uniquenodevector::Vector{String};sorting=:number)</code></pre><p>Sort the unique node names in <code>uniquenodevector</code> according to the specified sorting scheme, always placing the ground node at the beginning. Return the indices which sort <code>uniquenodevector</code>.</p><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:name)
4-element Vector{Int64}:
 3
 2
 4
 1

julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:number)
4-element Vector{Int64}:
 3
 4
 2
 1

julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:none)
4-element Vector{Int64}:
 3
 1
 2
 4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}" href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcnoiseportimpedanceindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcnoiseportimpedanceindices(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int}, mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Find the resistors (not located at a port) or lossy capacitors or lossy inductors  and return their indices. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
1-element Vector{Int64}:
 1</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
Int64[]</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,(30+1im)*1e-15])

# output
2-element Vector{Int64}:
 1
 4</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:L,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,(1+1im)*1e-12,30e-15])

# output
2-element Vector{Int64}:
 1
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcphiindices-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, Dict{CartesianIndex{N}, CartesianIndex{N}}}} where N" href="#JosephsonCircuits.calcphiindices-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, Dict{CartesianIndex{N}, CartesianIndex{N}}}} where N"><code>JosephsonCircuits.calcphiindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcphiindicescalcphiindices(frequencies::Frequencies{N},
    conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}})</code></pre><p>Return the indices which map the elements of the frequency domain vector to the corresponding elements of the frequency domain array. Also return the indices <code>conjsourceindices</code> whose data should be copied from the vector to <code>conjtargetindices</code> in the array then complex conjugated</p><p><strong>Arguments</strong></p><ul><li><code>Nt</code>: tuple with dimensions of signal in time domain </li><li><code>dropdict</code>: dictionary of elements of frequency domain signal to drop where   the key is the Cartesian index and the value is the value. </li></ul><p><strong>Returns</strong></p><ul><li><code>indexmap</code>: the indices which map the elements of the frequency domain   vector elements to the corresponding elements of the frequency domain array</li><li><code>conjsourceindices</code>: data should be copied from here</li><li><code>conjtargetindices</code>: data should be copied to here and conjugated</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freq = JosephsonCircuits.Frequencies{2}((4, 3), (5, 7), (8, 7), CartesianIndex{2}[CartesianIndex(2, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(3, 2), CartesianIndex(2, 3), CartesianIndex(1, 4), CartesianIndex(2, 6), CartesianIndex(3, 7)], [(1, 0), (3, 0), (0, 1), (2, 1), (1, 2), (0, 3), (1, -2), (2, -1)])
conjsymdict = Dict{CartesianIndex{2}, CartesianIndex{2}}(CartesianIndex(5, 4) =&gt; CartesianIndex(5, 5), CartesianIndex(1, 3) =&gt; CartesianIndex(1, 6), CartesianIndex(5, 2) =&gt; CartesianIndex(5, 7), CartesianIndex(1, 4) =&gt; CartesianIndex(1, 5), CartesianIndex(1, 2) =&gt; CartesianIndex(1, 7), CartesianIndex(5, 3) =&gt; CartesianIndex(5, 6))
JosephsonCircuits.calcphiindices(freq, conjsymdict)

# output
([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])</code></pre><pre><code class="language-julia hljs">freq = JosephsonCircuits.calcfreqsrdft((4,3));
truncfreq = JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=3)
noconjtruncfreq = JosephsonCircuits.removeconjfreqs(truncfreq)
conjsymdict = JosephsonCircuits.conjsym(noconjtruncfreq)
JosephsonCircuits.calcphiindices(noconjtruncfreq,conjsymdict)

# output
([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}" href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcportimpedanceindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcportimpedanceindices(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Find the resistors located at a port and return their indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
1-element Vector{Int64}:
 2</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
Int64[]</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 3 2 3 3 3 2; 1 1 3 1 1 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15,2,50.0])

# output
2-element Vector{Int64}:
 7
 2</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15,2,50.0])

# output
2-element Vector{Int64}:
 2
 7</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],
    [],
    [2,50,5e-15,1e-12,30e-15,1,50.0])

# output
2-element Vector{Int64}:
 7
 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}" href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcportindicesnumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcportindicesnumbers(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Return vectors containing the indices of the ports and their numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
([1], [1])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:P],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,2])

# output
([1, 5], [1, 2])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:P],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [2,50,5e-15,1e-12,1])

# output
([5, 1], [1, 2])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
(Int64[], Int64[])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqe!-Tuple{Any, Any, Any}" href="#JosephsonCircuits.calcqe!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcqe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqe!(qe, S, Snoise)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qe=Float64[1 2;3 4];JosephsonCircuits.calcqe!(qe,[1 2;3 4],[1 2 3;4 5 6]);qe
2×2 Matrix{Float64}:
 0.0526316  0.210526
 0.0882353  0.156863</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqe!-Tuple{Any, Any}" href="#JosephsonCircuits.calcqe!-Tuple{Any, Any}"><code>JosephsonCircuits.calcqe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqe!(qe, S)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqe-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#JosephsonCircuits.calcqe-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>JosephsonCircuits.calcqe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqe(S)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; @variables a b c d;JosephsonCircuits.calcqe([a b; c d])
2×2 Matrix{Num}:
 abs2(a) / (abs2(a) + abs2(b))  abs2(b) / (abs2(a) + abs2(b))
 abs2(c) / (abs2(c) + abs2(d))  abs2(d) / (abs2(c) + abs2(d))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqe-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T" href="#JosephsonCircuits.calcqe-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><code>JosephsonCircuits.calcqe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqe(S, Snoise)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5],[0.0 0.0;0.0 0.0])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5],Complex{Float64}[0.0 0.0;0.0 0.0])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; @variables a b c d an bn cn dn;JosephsonCircuits.calcqe([a b; c d],[an bn; cn dn])
2×2 Matrix{Num}:
 abs2(a) / (abs2(a) + abs2(an) + abs2(b) + abs2(bn))  …  abs2(b) / (abs2(a) + abs2(an) + abs2(b) + abs2(bn))
 abs2(c) / (abs2(c) + abs2(cn) + abs2(d) + abs2(dn))     abs2(d) / (abs2(c) + abs2(cn) + abs2(d) + abs2(dn))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqeideal!-Tuple{Any, Any}" href="#JosephsonCircuits.calcqeideal!-Tuple{Any, Any}"><code>JosephsonCircuits.calcqeideal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqeideal!(qeideal,S)</code></pre><p>See <a href="#JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>calcqeideal</code></a>. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>JosephsonCircuits.calcqeideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcqeideal(S::AbstractArray)</code></pre><p>Calculate the ideal (best possible) quantum efficiency for each element of a scattering matrix. See also <a href="#JosephsonCircuits.calcqeideal!-Tuple{Any, Any}"><code>calcqeideal!</code></a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqeideal([3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0

julia&gt; JosephsonCircuits.calcqeideal(Complex{Float64}[3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Any, Any}" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave, outputwave)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=[1.0 0.0;0.0 1.0];outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.707107+0.0im
 0.707107+0.0im            0.0+0.707107im

julia&gt; inputwave = rand(Complex{Float64},2,2);outputwave = rand(Complex{Float64},2,2);S=zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);isapprox(S*inputwave,outputwave)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, LinearAlgebra.Diagonal, Any}" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, LinearAlgebra.Diagonal, Any}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave::Diagonal, outputwave)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=JosephsonCircuits.LinearAlgebra.Diagonal([1.0,1.0]);outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.707107+0.0im
 0.707107+0.0im            0.0+0.707107im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Vector, Vector}" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Vector, Vector}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave::Vector, outputwave::Vector)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=[1.0,0.0];outputwave=[im/sqrt(2), 1/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.0+0.0im
 0.707107+0.0im       0.0+0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcsources-NTuple{10, Any}" href="#JosephsonCircuits.calcsources-NTuple{10, Any}"><code>JosephsonCircuits.calcsources</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcsources(modes, sources, portindices, portnumbers, nodeindices,
    edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)</code></pre><p>Calculate the source terms in the branch basis. See also <a href="#JosephsonCircuits.addsources!-NTuple{11, Any}"><code>addsources!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">modes = [(0,), (1,)]
sources = [(mode = (0,), port = 1, current = 0.0005), (mode = (1,), port = 1, current = 1.0e-10)]
portindices = [1]
portnumbers = [1]
nodeindices = [2 2 2 2 0 2 3 4 3 3; 1 1 1 1 0 3 4 1 1 1]
edge2indexdict = Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (4, 1) =&gt; 3, (2, 1) =&gt; 1, (1, 4) =&gt; 3, (3, 4) =&gt; 4, (4, 3) =&gt; 4)
Lmean = 1.005e-9 + 0.0im
Nnodes = 4
Nbranches = 4
Nmodes = 2
JosephsonCircuits.calcsources(modes, sources, portindices, portnumbers,
    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)

# output
8-element Vector{ComplexF64}:
     1526.863796602709 + 0.0im
 0.0003053727593205418 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcspicesortperms-Tuple{Dict{String, Vector{String}}}" href="#JosephsonCircuits.calcspicesortperms-Tuple{Dict{String, Vector{String}}}"><code>JosephsonCircuits.calcspicesortperms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcspicesortperms(variabledict::Dict{String,Vector{String}})</code></pre><p>Calculate the sortperms which will sort the variable and node names.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcspicesortperms(Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]))
Dict{String, Vector{Int64}} with 2 entries:
  &quot;V&quot;  =&gt; [1, 2, 3]
  &quot;Hz&quot; =&gt; [1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcvaluetype-Tuple{Vector{Symbol}, Vector, Vector{Symbol}}" href="#JosephsonCircuits.calcvaluetype-Tuple{Vector{Symbol}, Vector, Vector{Symbol}}"><code>JosephsonCircuits.calcvaluetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcvaluetype(componenttypes::Vector{Symbol},componentvalues::Vector,
    components::Vector{Symbol};checkinverse::Bool=true)</code></pre><p>Returns a zero length vector with the (computer science) type which will hold a set of circuit components of the (electrical engineering) types given in <code>components</code>. This function is not type stable by design, but exists to make the later function calls type stable.</p><p><strong>Arguments</strong></p><ul><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering) types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>components::Vector{Symbol}</code>: find a (computer science) type which will   hold the component (electrical engineering) types in this vector.</li></ul><p><strong>Keywords</strong></p><ul><li><code>checkinverse = true</code>: also check the inverse of each element. This is   useful if the type would be integer but we later want to take the inverse   and want an array with a type that supports this operation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3],[:R])
Float64[]

julia&gt; JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3+0.0im],[:R])
ComplexF64[]

julia&gt; @variables R1 C1 R2;JosephsonCircuits.calcvaluetype([:R,:C,:R],[R1,C1,R2],[:R])
Num[]

julia&gt; @syms R1 C1 R2;JosephsonCircuits.calcvaluetype([:R,:C,:R],[R1,C1,R2],[:R])
SymbolicUtils.BasicSymbolic{Number}[]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcw!-Tuple{Any, AbstractVector, Any, AbstractVector}" href="#JosephsonCircuits.calcw!-Tuple{Any, AbstractVector, Any, AbstractVector}"><code>JosephsonCircuits.calcw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcw!(ws, i, wp, w)</code></pre><p>Generate the signal and idler frequencies using the formula ws + 2<em>i</em>wp. Overwrites w with output. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.calcw-Tuple{Any, Integer, Any}" href="#JosephsonCircuits.calcw-Tuple{Any, Integer, Any}"><code>JosephsonCircuits.calcw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcw(ws::Number, i::Integer, wp::Number)</code></pre><p>Generate the signal and idler frequencies using the formula ws + 2<em>i</em>wp</p><p>Should I switch this to ws+i*wp so it can handle three wave mixing then  always double i for four wave mixing?</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcw(2*pi*4.0e9,-1,2*pi*5.0e9)/(2*pi*1.0e9)
-5.999999999999999

julia&gt; JosephsonCircuits.calcw(2*pi*4.0e9,[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)
3-element Vector{Float64}:
 -5.999999999999999
  4.0
 14.0

julia&gt; JosephsonCircuits.calcw([2*pi*4.0e9,2*pi*4.1e9],[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)
2×3 Matrix{Float64}:
 -6.0  4.0  14.0
 -5.9  4.1  14.1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.checkcomponenttypes-Tuple{Vector{String}}" href="#JosephsonCircuits.checkcomponenttypes-Tuple{Vector{String}}"><code>JosephsonCircuits.checkcomponenttypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkcomponenttypes(allowedcomponents::Vector{String})</code></pre><p>Check that each element in allowedcomponents is found at the correct place. This will detect the case where a two letter component appears in  allowedcomponents after a one letter component with the same starting letter. parsecomponenttype() will match on the first value and this function will throw an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.checkcomponenttypes([&quot;Lj&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;])
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.checkissymbolic-Tuple{Any}" href="#JosephsonCircuits.checkissymbolic-Tuple{Any}"><code>JosephsonCircuits.checkissymbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkissymbolic(a)</code></pre><p>Check if <code>a</code> is a symbolic variable. Define a function to do this because a different function call is required for <code>@syms</code> vs <code>@variables</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms w;JosephsonCircuits.checkissymbolic(w)
true

julia&gt; JosephsonCircuits.checkissymbolic(1.0)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.checkissymbolic-Tuple{Num}" href="#JosephsonCircuits.checkissymbolic-Tuple{Num}"><code>JosephsonCircuits.checkissymbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkissymbolic(a::Num)</code></pre><p>Check if <code>a</code> is a symbolic variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;JosephsonCircuits.checkissymbolic(w)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.comparestruct-Tuple{Any, Any}" href="#JosephsonCircuits.comparestruct-Tuple{Any, Any}"><code>JosephsonCircuits.comparestruct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>comparestruct(x,y)</p><p>Compare two structures for testing purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.comparestruct(JosephsonCircuits.warmupnumericmatrices(),JosephsonCircuits.warmupnumericmatrices())
true

julia&gt; JosephsonCircuits.comparestruct(JosephsonCircuits.warmup(),JosephsonCircuits.warmup())
true

julia&gt; JosephsonCircuits.comparestruct(nothing,nothing)
true

julia&gt; JosephsonCircuits.compare(nothing,nothing)
true

julia&gt; cg = JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), JosephsonCircuits.SparseArrays.sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], JosephsonCircuits.Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2);JosephsonCircuits.compare(cg,cg)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.componentdictionaries-Tuple{Vector{Symbol}, Matrix{Int64}, Dict, Vector{String}}" href="#JosephsonCircuits.componentdictionaries-Tuple{Vector{Symbol}, Matrix{Int64}, Dict, Vector{String}}"><code>JosephsonCircuits.componentdictionaries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">componentdictionaries(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int}, componentnamedict::Dict,
    mutualinductorbranchnames::Vector)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = parsesortcircuit(circuit)
countdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)

println(countdict)
println(indexdict)

# output
Dict((:L, 1, 3) =&gt; 1, (:K, 4, 6) =&gt; 1, (:R, 1, 2) =&gt; 1, (:I, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:L, 1, 2) =&gt; 1)
Dict((:C, 1, 3, 1) =&gt; 7, (:I, 1, 2, 1) =&gt; 2, (:R, 1, 2, 1) =&gt; 3, (:L, 1, 3, 1) =&gt; 6, (:C, 1, 3, 2) =&gt; 8, (:L, 1, 2, 1) =&gt; 4, (:P, 1, 2, 1) =&gt; 1, (:K, 4, 6, 1) =&gt; 5)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 K2 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;,K2))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = parsesortcircuit(circuit)
countdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)

println(countdict)
println(indexdict)

# output
Dict((:L, 1, 3) =&gt; 1, (:K, 4, 7) =&gt; 2, (:R, 1, 2) =&gt; 1, (:I, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:L, 1, 2) =&gt; 1)
Dict((:C, 1, 3, 1) =&gt; 8, (:I, 1, 2, 1) =&gt; 2, (:R, 1, 2, 1) =&gt; 3, (:K, 4, 7, 1) =&gt; 5, (:K, 4, 7, 2) =&gt; 6, (:L, 1, 2, 1) =&gt; 4, (:L, 1, 3, 1) =&gt; 7, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 3, 2) =&gt; 9)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.componentvaluestonumber-Tuple{Vector, Dict}" href="#JosephsonCircuits.componentvaluestonumber-Tuple{Vector, Dict}"><code>JosephsonCircuits.componentvaluestonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">componentvaluestonumber(componentvalues::Vector,circuitdefs::Dict)</code></pre><p>Convert the array of component values to numbers, if defined in <code>circuitdefs</code>.  This function is not type stable by design because we want the output array  to use a concrete type if all of the values are evaluated to numbers. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.componentvaluestonumber([:Lj1,:Lj2],Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
2-element Vector{Float64}:
 1.0e-12
 2.0e-12

julia&gt; @variables Lj1 Lj2;JosephsonCircuits.componentvaluestonumber([Lj1,Lj1+Lj2],Dict(Lj1=&gt;1e-12,Lj2=&gt;2e-12))
2-element Vector{Float64}:
 1.0e-12
 3.0e-12</code></pre><pre><code class="language-julia hljs"># define a frequency dependent impedance function
Zfun(w,R) = ifelse(w&gt;10,R,100*R);
# create symbolic variables including a two argument function
@variables w R
@register_symbolic Zfun(w,R)
# substitute in numerical values and functions for everything but w
out=JosephsonCircuits.componentvaluestonumber([R,Zfun(w,R)],Dict(R=&gt;50));
println(out)
# evaluate with w = 2
println(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=&gt;2),)))
# evaluate with w = 11
println(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=&gt;11),)))

# output
Any[50, Zfun(w, 50)]
[50, 5000]
[50, 50]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.conjnegfreq!-Tuple{SparseArrays.SparseMatrixCSC, Vector}" href="#JosephsonCircuits.conjnegfreq!-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.conjnegfreq!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>conjnegfreq!(A, wmodes)</p><p>Take the complex conjugate of any element of <code>A</code> which would be negative when multipled from the right by a diagonal matrix consisting of <code>wmodes</code> replicated along the diagonal. Overwrite <code>A</code> with the output. </p><p>Each axis of <code>A</code> should be an integer multiple of the length of <code>wmodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq!(A,[-1,1]);A
2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:
 1-1im  1+1im
 1-1im  1+1im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.conjnegfreq-Tuple{SparseArrays.SparseMatrixCSC, Vector}" href="#JosephsonCircuits.conjnegfreq-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.conjnegfreq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>conjnegfreq(A, wmodes)</p><p>Take the complex conjugate of any element of <code>A</code> which would be negative when multipled from the right by a diagonal matrix consisting of <code>wmodes</code> replicated along the diagonal.</p><p>Each axis of <code>A</code> should be an integer multiple of the length of <code>wmodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq(A,[-1,1])
2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:
 1-1im  1+1im
 1-1im  1+1im

julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1im,1im,1im,1im],2,2);all(A*JosephsonCircuits.LinearAlgebra.Diagonal([-1,1]) .== JosephsonCircuits.conjnegfreq(A,[-1,1]))
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.conjsym-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N" href="#JosephsonCircuits.conjsym-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N"><code>JosephsonCircuits.conjsym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conjsym(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})</code></pre><p>Calculate the conjugate symmetries in the multi-dimensional frequency domain data.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,)))
Dict{CartesianIndex{1}, CartesianIndex{1}}()

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,)))
Dict{CartesianIndex{1}, CartesianIndex{1}} with 2 entries:
  CartesianIndex(2,) =&gt; CartesianIndex(5,)
  CartesianIndex(3,) =&gt; CartesianIndex(4,)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1)))
Dict{CartesianIndex{2}, CartesianIndex{2}} with 2 entries:
  CartesianIndex(1, 2) =&gt; CartesianIndex(1, 3)
  CartesianIndex(3, 2) =&gt; CartesianIndex(3, 3)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,1)))
Dict{CartesianIndex{2}, CartesianIndex{2}} with 7 entries:
  CartesianIndex(2, 3) =&gt; CartesianIndex(5, 2)
  CartesianIndex(2, 1) =&gt; CartesianIndex(5, 1)
  CartesianIndex(3, 3) =&gt; CartesianIndex(4, 2)
  CartesianIndex(3, 1) =&gt; CartesianIndex(4, 1)
  CartesianIndex(2, 2) =&gt; CartesianIndex(5, 3)
  CartesianIndex(1, 2) =&gt; CartesianIndex(1, 3)
  CartesianIndex(3, 2) =&gt; CartesianIndex(4, 3)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1,1)))
Dict{CartesianIndex{3}, CartesianIndex{3}} with 8 entries:
  CartesianIndex(1, 2, 1) =&gt; CartesianIndex(1, 3, 1)
  CartesianIndex(1, 2, 3) =&gt; CartesianIndex(1, 3, 2)
  CartesianIndex(1, 2, 2) =&gt; CartesianIndex(1, 3, 3)
  CartesianIndex(3, 2, 1) =&gt; CartesianIndex(3, 3, 1)
  CartesianIndex(1, 1, 2) =&gt; CartesianIndex(1, 1, 3)
  CartesianIndex(3, 2, 3) =&gt; CartesianIndex(3, 3, 2)
  CartesianIndex(3, 2, 2) =&gt; CartesianIndex(3, 3, 3)
  CartesianIndex(3, 1, 2) =&gt; CartesianIndex(3, 1, 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.diagrepeat!-Tuple{Any, Any, Integer}" href="#JosephsonCircuits.diagrepeat!-Tuple{Any, Any, Integer}"><code>JosephsonCircuits.diagrepeat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagrepeat!(out, A, counts::Integer)</code></pre><p>Overwrite <code>out</code> with the elements of <code>A</code> duplicated <code>counts</code> times along the diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2;3 4];out = zeros(eltype(A),4,4);JosephsonCircuits.diagrepeat!(out,A,2);out
4×4 Matrix{Int64}:
 1  0  2  0
 0  1  0  2
 3  0  4  0
 0  3  0  4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.diagrepeat-Tuple{AbstractArray, Integer}" href="#JosephsonCircuits.diagrepeat-Tuple{AbstractArray, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagrepeat(A::Matrix, counts::Integer)</code></pre><p>Return a matrix with each element of <code>A</code> duplicated along the diagonal <code>counts</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat([1 2;3 4],2)
4×4 Matrix{Int64}:
 1  0  2  0
 0  1  0  2
 3  0  4  0
 0  3  0  4

julia&gt; JosephsonCircuits.diagrepeat([1,2],2)
4-element Vector{Int64}:
 1
 1
 2
 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.diagrepeat-Tuple{LinearAlgebra.Diagonal, Integer}" href="#JosephsonCircuits.diagrepeat-Tuple{LinearAlgebra.Diagonal, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagrepeat(A::Diagonal, counts::Integer)</code></pre><p>Return a diagonal matrix with each element of <code>A</code> duplicated along the diagonal <code>counts</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.LinearAlgebra.Diagonal([1,2]),2)
4×4 LinearAlgebra.Diagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅  ⋅
 ⋅  1  ⋅  ⋅
 ⋅  ⋅  2  ⋅
 ⋅  ⋅  ⋅  2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseMatrixCSC, Integer}" href="#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseMatrixCSC, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagrepeat(A::SparseMatrixCSC, counts::Integer)</code></pre><p>Return a sparse matrix with each element of <code>A</code> duplicated along the diagonal  <code>counts</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,1,2,2], [1,2,1,2], [1,2,3,4],2,2),2)
4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 1  ⋅  2  ⋅
 ⋅  1  ⋅  2
 3  ⋅  4  ⋅
 ⋅  3  ⋅  4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseVector, Integer}" href="#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseVector, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagrepeat(A::SparseVector, counts::Integer)</code></pre><p>Return a sparse vector with each element of <code>A</code> duplicated along the diagonal  <code>counts</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparsevec([1,2],[1,2]),2)
4-element SparseArrays.SparseVector{Int64, Int64} with 4 stored entries:
  [1]  =  1
  [2]  =  1
  [3]  =  2
  [4]  =  2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.edge2index-Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}}" href="#JosephsonCircuits.edge2index-Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}}"><code>JosephsonCircuits.edge2index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge2index(graph::Graphs.SimpleDiGraph{Int})</code></pre><p>Generate a dictionary where the tuple of nodes defining an edge of a graph is the key and the value is an index. The index gives the order the edge is found when iterating over the edges of the graph. The same index is used for both orderings of source and destination nodes on the edge. We don&#39;t care about the ordering of the indices as long as they are sequential and unique.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.edge2index(JosephsonCircuits.Graphs.path_digraph(4))
Dict{Tuple{Int64, Int64}, Int64} with 6 entries:
  (3, 2) =&gt; 2
  (1, 2) =&gt; 1
  (2, 1) =&gt; 1
  (3, 4) =&gt; 3
  (4, 3) =&gt; 3
  (2, 3) =&gt; 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.exportnetlist-Tuple{Vector, Dict}" href="#JosephsonCircuits.exportnetlist-Tuple{Vector, Dict}"><code>JosephsonCircuits.exportnetlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exportnetlist(circuit::Vector,circuitdefs::Dict,port::Int = true,
    jj::Bool = true)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables R Cc Lj Cj I
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc),
    (&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj)]

circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    R =&gt; 50.0)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 670.8940240000001f
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=329.105976f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
Lj1 2 0 1000.0000000000001p
C2 2 0 1000.0f</code></pre><pre><code class="language-julia hljs">@variables R Cc L1 L2 Cj1 Cj2 I1 V1
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc),
    (&quot;L1&quot;,&quot;2&quot;,&quot;0&quot;,L1),
    (&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj1),
    (&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,Cj2),
    (&quot;I1&quot;,&quot;2&quot;,&quot;0&quot;,I1)]

circuitdefs = Dict(
    L1 =&gt;2000.0e-12,
    L2 =&gt;2000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj1 =&gt; 500.0e-15,
    Cj2 =&gt; 500.0e-15,
    R =&gt; 50.0,
    I1 =&gt;0.1)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
L1 2 0 1000.0000000000001p
C2 2 0 1000.0f

* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
L1 2 0 1000.0000000000001p
C2 2 0 1000.0f</code></pre><pre><code class="language-julia hljs">@variables Rleft L1 K1 L2 C2 C3 Lj1
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
circuitdefs = Dict(
    Rleft =&gt; 50.0,
    L1 =&gt; 1000.0e-12,
    Lj1 =&gt; 1000.0e-12,
    K1 =&gt; 0.1,
    L2 =&gt; 1000.0e-12,
    C2 =&gt; 1000.0e-15,
    C3 =&gt; 1000.0e-15)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 1670.894024f
K1 L1 L2 0.1
L2 2 0 1000.0000000000001p
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=329.105976f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
Lj1 2 0 1000.0000000000001p
K1 L1 L2 0.1
L2 2 0 1000.0000000000001p
C2 2 0 2000.0f</code></pre><pre><code class="language-julia hljs">@variables Rleft L1 K1 L2 C2 C3 Lj1
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj1))
push!(circuit,(&quot;K1&quot;,&quot;L2&quot;,&quot;L1&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
circuitdefs = Dict(
    Rleft =&gt; 50.0,
    L1 =&gt; 1000.0e-12,
    Lj1 =&gt; 1000.0e-12,
    K1 =&gt; 0.1,
    L2 =&gt; 1000.0e-12,
    C2 =&gt; 1000.0e-15,
    C3 =&gt; 1000.0e-15)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 1670.894024f
K1 L2 L1 0.1
L2 2 0 1000.0000000000001p
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=329.105976f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
Lj1 2 0 1000.0000000000001p
K1 L2 L1 0.1
L2 2 0 1000.0000000000001p
C2 2 0 2000.0f</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.extractbranches!-Tuple{Vector, Vector{Symbol}, Matrix{Int64}}" href="#JosephsonCircuits.extractbranches!-Tuple{Vector, Vector{Symbol}, Matrix{Int64}}"><code>JosephsonCircuits.extractbranches!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractbranches!(branchvector::Vector,componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int})</code></pre><p>Append tuples consisting of a pair of node indices (branches) which we will use to calculate the incidence matrix.  Appends the tuples to branchvector.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}" href="#JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}"><code>JosephsonCircuits.extractbranches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractbranches(componenttypes::Vector{Symbol},nodeindexarray::Matrix{Int})</code></pre><p>Return an array of tuples of pairs of node indices (branches) which we will use to calculate the incidence matrix.  </p><p>This will contain duplicates if multiple components are on the same branch. All checking for duplicate branches will occur in the graph procesing code.</p><p>NOTE: the list of component types considered to lie on branches is hardcoded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.extractbranches([:P,:I,:R,:C,:Lj,:C],[2 2 2 2 3 3; 1 1 1 3 1 1])
3-element Vector{Tuple{Int64, Int64}}:
 (2, 1)
 (2, 1)
 (3, 1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.factorklu!-Tuple{JosephsonCircuits.FactorizationCache, SparseArrays.SparseMatrixCSC}" href="#JosephsonCircuits.factorklu!-Tuple{JosephsonCircuits.FactorizationCache, SparseArrays.SparseMatrixCSC}"><code>JosephsonCircuits.factorklu!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorklu!(cache::FactorizationCache, A::SparseMatrixCSC)</code></pre><p>Factor the sparse matrix <code>A</code> using KLU and place the result in <code>cache</code>. Attempt to reuse the symbolic factorization. Redo the symbolic factorization if we get a SingularException.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.findgroundnodeindex-Tuple{Vector{String}}" href="#JosephsonCircuits.findgroundnodeindex-Tuple{Vector{String}}"><code>JosephsonCircuits.findgroundnodeindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findgroundnodeindex(uniquenodevector::Vector{String})</code></pre><p>Find the index of the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.findgroundnodeindex([&quot;1&quot;,&quot;0&quot;,&quot;2&quot;])
2

julia&gt; JosephsonCircuits.findgroundnodeindex([&quot;1&quot;,&quot;2&quot;])
0

julia&gt; JosephsonCircuits.findgroundnodeindex(String[])
0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}" href="#JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.fourierindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourierindices(freq::Frequencies)</code></pre><p>Generate the indices used in the RDFT or DFT and inverse RDFT or DFT and converting between a node flux vector for solving system and the matrices for the Fourier analysis. See also <a href="#JosephsonCircuits.FourierIndices"><code>FourierIndices</code></a>, <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>, <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.freqsubst-Tuple{SparseArrays.SparseMatrixCSC, Vector, Any}" href="#JosephsonCircuits.freqsubst-Tuple{SparseArrays.SparseMatrixCSC, Vector, Any}"><code>JosephsonCircuits.freqsubst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freqsubst(A::SparseMatrixCSC, wmodes::Vector, symfreqvar)</code></pre><p>Substitute the frequency dependent elements of <code>A</code> using the vector of mode frequencies <code>wmodes</code> and the symbolic frequency variable <code>symfreqvar</code>. Returns a sparse matrix with type <code>Complex{Float64}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables w
wmodes = [-1,2];
A = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,2*w,3*w],2,2),2);
JosephsonCircuits.freqsubst(A,wmodes,w)

# output
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:
 -1.0+0.0im      ⋅      -3.0+0.0im      ⋅    
      ⋅      2.0+0.0im       ⋅      6.0+0.0im
      ⋅          ⋅      -2.0+0.0im      ⋅    
      ⋅          ⋅           ⋅      4.0+0.0im</code></pre><pre><code class="language-julia hljs">wmodes = [-1,2];
A = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,3],2,2),2);
JosephsonCircuits.freqsubst(A,wmodes,nothing)

# output
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:
 1.0+0.0im      ⋅      3.0+0.0im      ⋅    
     ⋅      1.0+0.0im      ⋅      3.0+0.0im
     ⋅          ⋅      2.0+0.0im      ⋅    
     ⋅          ⋅          ⋅      2.0+0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.frequencyscale-Tuple{String}" href="#JosephsonCircuits.frequencyscale-Tuple{String}"><code>JosephsonCircuits.frequencyscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequencyscale(frequencyunit::String)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.frequencyscale(&quot;MHz&quot;)
1.0e6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K" href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>JosephsonCircuits.hblinsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hblinsolve(w, circuit,circuitdefs; Nmodulationharmonics = (0,),
    nonlinear=nothing, symfreqvar=nothing, threewavemixing=false,
    fourwavemixing=true, maxintermodorder=Inf,
    nbatches::Integer = Base.Threads.nthreads(), returnS = true,
    returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnnodefluxadjoint = false,
    returnvoltage = false,
    )</code></pre><p>Harmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around <code>pump</code>, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones).</p><p><strong>Arguments</strong></p><ul><li><code>w</code>:</li><li><code>circuit</code>:</li><li><code>circuitdefs</code>:</li></ul><p><strong>Keywords</strong></p><ul><li><code>Nmodulationharmonics = (0,)</code>:</li><li><code>nonlinear=nothing</code>:</li><li><code>symfreqvar=nothing</code>:</li><li><code>threewavemixing=false</code>:</li><li><code>fourwavemixing=true</code>:</li><li><code>maxintermodorder=Inf</code>:</li><li><code>nbatches::Integer = Base.Threads.nthreads()</code>:</li><li><code>returnS = true</code>:</li><li><code>returnSnoise = false</code>:</li><li><code>returnQE = true</code>:</li><li><code>returnCM = true</code>:</li><li><code>returnnodeflux = false</code>:</li><li><code>returnnodefluxadjoint = false</code>:</li><li><code>returnvoltage = false</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>LinearizedHB</code>: A simple structure to hold the harmonic balance solutions.   See <a href="#JosephsonCircuits.LinearizedHB"><code>LinearizedHB</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 1e-6*0
Ip=5.0e-6
wp=2*pi*5e9
ws=2*pi*5.2e9
symfreqvar = nothing

# modulation settings
Npumpharmonics = (16,)
Nmodulationharmonics = (2,)
threewavemixing=false
fourwavemixing=true

nonlinear=hbnlsolve(
    (wp,),
    Npumpharmonics,
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    circuit,circuitdefs;dc=true,odd=fourwavemixing,even=threewavemixing)

linearized = JosephsonCircuits.hblinsolve(ws,
    circuit, circuitdefs; Nmodulationharmonics = Nmodulationharmonics,
    nonlinear = nonlinear, symfreqvar=nothing, threewavemixing=false,
    fourwavemixing=true, returnnodeflux=true, keyedarrays = Val(false))
isapprox(linearized.nodeflux,
    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],
    atol = 1e-6)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{N}, Tuple{Any, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, Any, JosephsonCircuits.Frequencies{N}}} where {N, K}" href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{N}, Tuple{Any, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, Any, JosephsonCircuits.Frequencies{N}}} where {N, K}"><code>JosephsonCircuits.hblinsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hblinsolve(w, psc::ParsedSortedCircuit,
    cg::CircuitGraph, circuitdefs, signalfreq::Frequencies{N};
    nonlinear=nothing, symfreqvar=nothing,
    nbatches::Integer = Base.Threads.nthreads(), returnS = true,
    returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnnodefluxadjoint = false,
    returnvoltage = false,
    )</code></pre><p>Harmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around <code>pump</code>, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 1e-6*0
Ip = 5.0e-6
wp = 2*pi*5e9
ws = 2*pi*5.2e9
Npumpharmonics = (2,)
Nmodulationharmonics = (2,)
threewavemixing = false
fourwavemixing = true

frequencies = JosephsonCircuits.removeconjfreqs(
    JosephsonCircuits.truncfreqs(
        JosephsonCircuits.calcfreqsrdft(Npumpharmonics),
        dc = true, odd = true, even = false, maxintermodorder = Inf,
    )
)
fi = JosephsonCircuits.fourierindices(frequencies)
Nmodes = length(frequencies.modes)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
nm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)
nonlinear = hbnlsolve(
    (wp,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    frequencies, fi, psc, cg, nm)
signalfreq =JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsdft(Nmodulationharmonics),
    dc = true, odd = threewavemixing, even = fourwavemixing,
    maxintermodorder = Inf,
)
linearized = JosephsonCircuits.hblinsolve(ws, psc, cg, circuitdefs,
    signalfreq;nonlinear = nonlinear, returnnodeflux=true, keyedarrays = Val(false))
isapprox(linearized.nodeflux,
    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],
    atol = 1e-6)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hblinsolve_inner!-NTuple{40, Any}" href="#JosephsonCircuits.hblinsolve_inner!-NTuple{40, Any}"><code>JosephsonCircuits.hblinsolve_inner!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hblinsolve_inner!(S, Snoise, QE, CM, nodeflux, voltage, Asparse,
    AoLjnm, invLnm, Cnm, Gnm, bnm,
    AoLjnmindexmap, invLnmindexmap, Cnmindexmap, Gnmindexmap,
    Cnmfreqsubstindices, Gnmfreqsubstindices, invLnmfreqsubstindices,
    portindices, portimpedanceindices, noiseportimpedanceindices,
    portimpedances, noiseportimpedances, nodeindices, componenttypes,
    w, indices, wp, Nmodes, Nnodes, symfreqvar, wi)</code></pre><p>Solve the linearized harmonic balance problem for a subset of the frequencies given by <code>wi</code>. This function is thread safe in that different frequencies can be computed in parallel on separate threads.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K" href="#JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>JosephsonCircuits.hblinsolveold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hblinsolveold(w, circuit, circuitdefs; wp = 0.0, Nmodes = 1,
    Am = zeros(Complex{Float64},0,0), symfreqvar = nothing,
    nbatches = Base.Threads.nthreads(), sorting = :number, returnS = true,
    returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnvoltage = false)</code></pre><p>Linearized harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p>Returns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: signal frequency or vector of signal frequencies in radians/second.</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values. </li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>wp = 0.0</code>: pump frequency in radians/second. This function only supports a   single pump frequency.</li><li><code>Nmodes = 1</code>: number of signal and idler modes.</li><li><code>Am = zeros(Complex{Float64},0,0)</code>: </li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to <code>nothing</code>   by default but should be set equal to the frequency variable like <code>w</code> if    there is frequency dependence.</li><li><code>nbatches = Base.Threads.nthreads()</code>: for the linearized harmonic balance   solution, split the solutions for different frequencies into this many   batches. Set equal to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. </li><li><code>sorting = :number</code>: sort the ports by turning them into integers and   sorting those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this   fails.</li><li><code>returnS = true</code>: if <code>true</code>, return the scattering parameters for each set   of ports and signal and idler frequencies.</li><li><code>returnSnoise = false</code>: if <code>true</code>, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. </li><li><code>returnQE = true</code>: if <code>true</code>, return the quantum efficiency for each signal   and idler at each combinaton of ports.</li><li><code>returnCM = true</code>: if <code>true</code>, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).</li><li><code>returnnodeflux = false</code>: if <code>true</code>, return the node fluxes for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li><li><code>returnnodefluxadjoint = false</code>: if <code>true</code>, return the node fluxes adjoint   for each signal and idler at each node. Set to <code>false</code> by default to   reduce memory usage.</li><li><code>returnvoltage = false</code>: if <code>true</code>, return the node voltages for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage. </li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
w = 2*pi*(4.5:0.01:5.0)*1e9
result=JosephsonCircuits.hblinsolveold(w, circuit, circuitdefs)
using Plots;plot(w/(2*pi*1e9),angle.(result.S[:]))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbmatind-Union{Tuple{JosephsonCircuits.Frequencies{N}}, Tuple{N}} where N" href="#JosephsonCircuits.hbmatind-Union{Tuple{JosephsonCircuits.Frequencies{N}}, Tuple{N}} where N"><code>JosephsonCircuits.hbmatind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbmatind(truncfrequencies::Frequencies{N})</code></pre><p>Returns a matrix describing which indices of the frequency domain matrix (from the RFFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; freq = JosephsonCircuits.calcfreqsrdft((5,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=2)))[2]
3×3 Matrix{Int64}:
 1  -3  -5
 3   1  -3
 5   3   1

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((3,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]
4×4 Matrix{Int64}:
 1  -2  -3  -4
 2   1  -2  -3
 3   2   1  -2
 4   3   2   1

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[1]
7×7 Matrix{Tuple{Int64, Int64}}:
 (0, 0)   (-1, 0)  (-2, 0)   (0, -1)  (-1, -1)  (0, -2)  (-1, 1)
 (1, 0)   (0, 0)   (-1, 0)   (1, -1)  (0, -1)   (1, -2)  (0, 1)
 (2, 0)   (1, 0)   (0, 0)    (2, -1)  (1, -1)   (2, -2)  (1, 1)
 (0, 1)   (-1, 1)  (-2, 1)   (0, 0)   (-1, 0)   (0, -1)  (-1, 2)
 (1, 1)   (0, 1)   (-1, 1)   (1, 0)   (0, 0)    (1, -1)  (0, 2)
 (0, 2)   (-1, 2)  (-2, 2)   (0, 1)   (-1, 1)   (0, 0)   (-1, 3)
 (1, -1)  (0, -1)  (-1, -1)  (1, -2)  (0, -2)   (1, -3)  (0, 0)

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]
7×7 Matrix{Int64}:
  1   -2   -3  13   -5  10  -14
  2    1   -2  14   13  11    4
  3    2    1  15   14  12    5
  4  -14  -15   1   -2  13  -11
  5    4  -14   2    1  14    7
  7  -11  -12   4  -14   1    0
 14   13   -5  11   10   0    1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbmatind-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, JosephsonCircuits.Frequencies{N}}} where N" href="#JosephsonCircuits.hbmatind-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, JosephsonCircuits.Frequencies{N}}} where N"><code>JosephsonCircuits.hbmatind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbmatind(frequencies::Frequencies{N},
    truncfrequencies::Frequencies{N})</code></pre><p>Returns a matrix describing which indices of the frequency domain matrix (from the RFFT or FFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pumpfreq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((4,)))
signalfreq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsdft((4,));
    dc=false,odd=true,even=false,maxintermodorder=2,
)
JosephsonCircuits.hbmatind(pumpfreq, signalfreq)[2]

# output
4×4 Matrix{Int64}:
  1  -3  5   3
  3   1  0   5
 -5   0  1  -3
 -3  -5  3   1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}" href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><code>JosephsonCircuits.hbnlsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbnlsolve(w::NTuple{N,Any}, sources, frequencies::Frequencies{N},
    indices::FourierIndices{N}, psc::ParsedSortedCircuit, cg::CircuitGraph,
    nm::CircuitMatrices; iterations = 1000, x0 = nothing,
    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,
    symfreqvar = nothing)</code></pre><p>New version of the nonlinear harmonic balance solver suitable for arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 50e-5
Ip=0.0001e-6
wp=2*pi*5e9
Nharmonics = (2,)
frequencies = JosephsonCircuits.removeconjfreqs(
    JosephsonCircuits.truncfreqs(
        JosephsonCircuits.calcfreqsrdft(Nharmonics),
        dc=true, odd=true, even=false, maxintermodorder=Inf,
    )
)
fi = JosephsonCircuits.fourierindices(frequencies)
Nmodes = length(frequencies.modes)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
nm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)

out=hbnlsolve(
    (wp,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    frequencies, fi, psc, cg, nm)
isapprox(out.nodeflux[:],
    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],
    atol = 1e-6)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Tuple{Vararg{Int64, N}}, Any, Any, Any}} where {N, K}" href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Tuple{Vararg{Int64, N}}, Any, Any, Any}} where {N, K}"><code>JosephsonCircuits.hbnlsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbnlsolve(w::NTuple{N,Any}, Nharmonics::NTuple{N,Int}, sources,
    circuit, circuitdefs; iterations = 1000,
    maxintermodorder = Inf, dc = false, odd = true, even = false,
    x0 = nothing, ftol = 1e-8, switchofflinesearchtol = 1e-5,
    alphamin = 1e-4, symfreqvar = nothing, sorting= :number)</code></pre><p>New version of the nonlinear harmonic balance solver suitable for arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor.</p><p><strong>Arguments</strong></p><ul><li><code>w::NTuple{N,Any}</code>:</li><li><code>Nharmonics::NTuple{N,Int}</code>:</li><li><code>sources</code>:</li><li><code>circuit</code>:</li><li><code>circuitdefs</code>:</li></ul><p><strong>Keywords</strong></p><ul><li><code>iterations = 1000</code>:</li><li><code>maxintermodorder = Inf</code>:</li><li><code>dc = false</code>:</li><li><code>odd = true</code>:</li><li><code>even = false</code>:</li><li><code>x0 = nothing</code>:</li><li><code>ftol = 1e-8</code>:</li><li><code>switchofflinesearchtol = 1e-5</code>:</li><li><code>alphamin = 1e-4</code>:</li><li><code>symfreqvar = nothing</code>:</li><li><code>sorting= :number</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>NonlinearHB</code>: A simple structure to hold the harmonic balance solutions.   See <a href="#JosephsonCircuits.NonlinearHB"><code>NonlinearHB</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 50e-5
Ip=0.0001e-6
wp=2*pi*5e9
Npumpmodes = 2
out=hbnlsolve(
    (wp,),
    (Npumpmodes,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    circuit,circuitdefs;dc=true,odd=true,even=false)
isapprox(out.nodeflux[:],
    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],
    atol = 1e-6)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbnlsolveold-Union{Tuple{K}, NTuple{5, Any}} where K" href="#JosephsonCircuits.hbnlsolveold-Union{Tuple{K}, NTuple{5, Any}} where K"><code>JosephsonCircuits.hbnlsolveold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbnlsolveold(wp, Ip, Nmodes, circuit, circuitdefs; ports = [1],
    iterations = 1000, ftol = 1e-8, symfreqvar = nothing,
    sorting = :number)</code></pre><p>Nonlinear harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p><strong>Arguments</strong></p><ul><li><code>wp</code>: pump frequency in radians/second. This function only supports a single   pump frequency.</li><li><code>Ip</code>: pump current or vector of pump currents in amps. Length of <code>Ip</code> must   be equal to length of <code>ports</code>.</li><li><code>Nmodes</code>: number of modes (harmonics).</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values.</li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>ports = [1]</code>: vector of drive port numbers. Default is a single drive at port 1.</li><li><code>iterations = 1000</code>: number of iterations at which the nonlinear solver stops   even if convergence criteria not reached.</li><li><code>ftol = 1e-8</code>: relative or absolute tolerance at which nonlinear solver stops   (whichever is reached first).</li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to <code>nothing</code>   by default but should be set equal to the frequency variable like <code>w</code> if   there is frequency dependence.</li><li><code>sorting = :number</code>: sort the ports by turning them into integers and sorting   those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this fails.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
wp = 2*pi*4.75001*1e9
Ip = 0.00565e-6
Nmodes = 8
hbnlsolve(wp, Ip, Nmodes, circuit, circuitdefs, ports=[1])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{Any, Any, Any, Int64, Int64, Any, Any}} where K" href="#JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{Any, Any, Any, Int64, Int64, Any, Any}} where K"><code>JosephsonCircuits.hbsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbsolve(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs;
    pumpports = [1], iterations = 1000, ftol = 1e-8,
    switchofflinesearchtol = 1e-5, alphamin = 1e-4,
    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),
    sorting = :number, returnS = true, returnSnoise = false,
    returnQE = true, returnCM = true, returnnodeflux = false,
    returnvoltage = false, returnnodefluxadjoint = false,
    )</code></pre><p>Calls the new harmonic balance solvers, <a href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><code>hbnlsolve</code></a> and <a href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolve</code></a>, which work for an arbitrary number of modes and ports), using an identical syntax to <a href="#JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K"><code>hbsolveold</code></a>, which only supports four wave mixing processes involving single strong tone and an arbitrary number of tone in the linearized solver. This function is primarily for testing the new solvers and will eventually be deprecated.</p><p>This function attempts to mimic <a href="#JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K"><code>hbsolveold</code></a>, but with the difference: The outputs of the linearized harmonic balance solver <a href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolve</code></a> may not have the same ordering of signal modes as in <a href="#JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolveold</code></a>. In <a href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolve</code></a> the signal mode is always at index 1 and the location of the other modes can be found by inspecting the contents of <code>modes</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{M}, Tuple{N}, Tuple{Any, Tuple{Vararg{Any, N}}, Vector, Tuple{Vararg{Any, M}}, Tuple{Vararg{Any, N}}, Any, Any}} where {N, M, K}" href="#JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{M}, Tuple{N}, Tuple{Any, Tuple{Vararg{Any, N}}, Vector, Tuple{Vararg{Any, M}}, Tuple{Vararg{Any, N}}, Any, Any}} where {N, M, K}"><code>JosephsonCircuits.hbsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbsolve(ws, wp::NTuple{N,Any}, sources::Vector,
    Nmodulationharmonics::NTuple{M,Any}, Npumpharmonics::NTuple{N,Any},
    circuit, circuitdefs; dc = false, threewavemixing = false,
    fourwavemixing = true, maxintermodorder=Inf, iterations = 1000,
    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,
    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),
    sorting = :number, returnS = true, returnSnoise = false,
    returnQE = true, returnCM = true, returnnodeflux = false,
    returnvoltage = false, returnnodefluxadjoint = false,
    returnvoltageadjoint = false, keyedarrays::Val{K} = Val(true),
    sensitivitynames = String[], returnSsensitivity = false,
    returnZ = false, returnZadjoint = false,
    returnZsensitivity = false, returnZsensitivityadjoint = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>ws</code>:</li><li><code>wp::NTuple{N,Any}</code>:</li><li><code>sources::Vector</code>:</li><li><code>Nmodulationharmonics::NTuple{M,Any}</code>:</li><li><code>Npumpharmonics::NTuple{N,Any}</code>:</li><li><code>circuit</code>:</li><li><code>circuitdefs</code>:</li></ul><p><strong>Keywords</strong></p><ul><li><code>dc = false</code>:</li><li><code>threewavemixing = false</code>:</li><li><code>fourwavemixing = true</code>:</li><li><code>maxintermodorder=Inf</code>:</li><li><code>iterations = 1000</code>:</li><li><code>ftol = 1e-8</code>:</li><li><code>switchofflinesearchtol = 1e-5</code>:</li><li><code>alphamin = 1e-4</code>:</li><li><code>symfreqvar = nothing</code>:</li><li><code>nbatches = Base.Threads.nthreads()</code>:</li><li><code>sorting = :number</code>:</li><li><code>returnS = true</code>:</li><li><code>returnSnoise = false</code>:</li><li><code>returnQE = true</code>:</li><li><code>returnCM = true</code>:</li><li><code>returnnodeflux = false</code>:</li><li><code>returnvoltage = false</code>:</li><li><code>returnnodefluxadjoint = false</code>:</li><li><code>returnvoltageadjoint = false</code>:</li><li><code>keyedarrays::Val{K} = Val(true)</code>:</li><li><code>sensitivitynames = String[]</code>:</li><li><code>returnSsensitivity = false</code>:</li><li><code>returnZ = false</code>:</li><li><code>returnZadjoint = false</code>:</li><li><code>returnZsensitivity = false</code>:</li><li><code>returnZsensitivityadjoint = false</code>:</li></ul><p><strong>Returns</strong></p><ul><li><code>HB</code>: A simple structure to hold the harmonic balance solutions. See   <a href="#JosephsonCircuits.HB"><code>HB</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K" href="#JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K"><code>JosephsonCircuits.hbsolveold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs;
    pumpports = [1], iterations = 1000, ftol = 1e-8,
    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),
    sorting = :number, returnS = true, returnSnoise = false,
    returnQE = true, returnCM = true, returnnodeflux = false,
    returnvoltage = false)</code></pre><p>Harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p>Returns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.</p><p><strong>Arguments</strong></p><ul><li><code>ws</code>: signal frequency or vector of signal frequencies in radians/second.</li><li><code>wp</code>: pump frequency in radians/second. This function only supports a single   pump frequency.</li><li><code>Ip</code>: pump current or vector of pump currents in amps. Length of <code>Ip</code> must   be equal to length of <code>pumpports</code>.</li><li><code>Nsignalmodes</code>: number of signal and idler modes.</li><li><code>Npumpmodes</code>: number of pump modes (pump harmonics).</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values.</li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>pumpports = [1]</code>: vector of pump port numbers. Default is a single pump at   port 1.</li><li><code>iterations = 1000</code>: number of iterations at which the nonlinear solver   stops even if convergence criteria not reached. </li><li><code>ftol = 1e-8</code>: relative or absolute tolerance at which nonlinear solver   stops (whichever is reached first).</li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to   <code>nothing</code> by default but should be set equal to the frequency variable   like <code>w</code> if there is frequency dependence.</li><li><code>nbatches = Base.Threads.nthreads()</code>: for the linearized harmonic balance   solution,split the solutions for different frequencies into this many   batches. Set equalt to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. </li><li><code>sorting = :number</code>: sort the ports by turning them into integers and   sorting those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this   fails.</li><li><code>returnS = true</code>: if <code>true</code>, return the scattering parameters for each set   of ports and signal and idler frequencies.</li><li><code>returnSnoise = false</code>: if <code>true</code>, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. </li><li><code>returnQE = true</code>: if <code>true</code>, return the quantum efficiency for each signal   and idler at each combinaton of ports.</li><li><code>returnCM = true</code>: if <code>true</code>, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).</li><li><code>returnnodeflux = false</code>: if <code>true</code>, return the node fluxes for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li><li><code>returnnodefluxadjoint = false</code>: if <code>true</code>, return the node fluxes adjoint   for each signal and idler at each node. Set to <code>false</code> by default to   reduce memory usage.</li><li><code>returnvoltage = false</code>: if <code>true</code>, return the node voltages for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
ws = 2*pi*(4.5:0.01:5.0)*1e9
wp = 2*pi*4.75001*1e9
Ip = 0.00565e-6
Nsignalmodes = 8
Npumpmodes = 8
result=JosephsonCircuits.hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs,pumpports=[1])
using Plots;plot(ws/(2*pi*1e9),10*log10.(abs2.(result.signal.S[result.signal.signalindex,result.signal.signalindex,:])))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isbegininformation-Tuple{String}" href="#JosephsonCircuits.isbegininformation-Tuple{String}"><code>JosephsonCircuits.isbegininformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbegininformation(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [begin information] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isbegininformation(&quot;[begin information]&quot;)
true

julia&gt; JosephsonCircuits.isbegininformation(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isend-Tuple{String}" href="#JosephsonCircuits.isend-Tuple{String}"><code>JosephsonCircuits.isend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isend(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [end] line of a Touchstone file. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isend(&quot;[end]&quot;)
true

julia&gt; JosephsonCircuits.isend(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isendinformation-Tuple{String}" href="#JosephsonCircuits.isendinformation-Tuple{String}"><code>JosephsonCircuits.isendinformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isendinformation(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [end information] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isendinformation(&quot;[end information]&quot;)
true

julia&gt; JosephsonCircuits.isendinformation(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.ismatrixformat-Tuple{String}" href="#JosephsonCircuits.ismatrixformat-Tuple{String}"><code>JosephsonCircuits.ismatrixformat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismatrixformat(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [matrix format] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ismatrixformat(&quot;[matrix format] full&quot;)
true

julia&gt; JosephsonCircuits.ismatrixformat(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.ismixedmodeorder-Tuple{String}" href="#JosephsonCircuits.ismixedmodeorder-Tuple{String}"><code>JosephsonCircuits.ismixedmodeorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismixedmodeorder(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [mixed-mode order] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ismixedmodeorder(&quot;[mixed-mode order] full&quot;)
true

julia&gt; JosephsonCircuits.ismixedmodeorder(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isnetworkdata-Tuple{String}" href="#JosephsonCircuits.isnetworkdata-Tuple{String}"><code>JosephsonCircuits.isnetworkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnetworkdata(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [network data] line of a Touchstone file. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isnetworkdata(&quot;[network data]&quot;)
true

julia&gt; JosephsonCircuits.isnetworkdata(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isnoisedata-Tuple{String}" href="#JosephsonCircuits.isnoisedata-Tuple{String}"><code>JosephsonCircuits.isnoisedata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnoisedata(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [noise data] line of a Touchstone file. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isnoisedata(&quot;[noise data]&quot;)
true

julia&gt; JosephsonCircuits.isnoisedata(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isnumberoffrequencies-Tuple{String}" href="#JosephsonCircuits.isnumberoffrequencies-Tuple{String}"><code>JosephsonCircuits.isnumberoffrequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnumberoffrequencies(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [number of frequencies] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isnumberoffrequencies(&quot;[number of frequencies]&quot;)
true

julia&gt; JosephsonCircuits.isnumberoffrequencies(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isnumberofnoisefrequencies-Tuple{String}" href="#JosephsonCircuits.isnumberofnoisefrequencies-Tuple{String}"><code>JosephsonCircuits.isnumberofnoisefrequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnumberofnoisefrequencies(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [number of noise frequencies] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isnumberofnoisefrequencies(&quot;[number of noise frequencies]&quot;)
true

julia&gt; JosephsonCircuits.isnumberofnoisefrequencies(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isnumberofports-Tuple{String}" href="#JosephsonCircuits.isnumberofports-Tuple{String}"><code>JosephsonCircuits.isnumberofports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnumberofports(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [number of ports] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isnumberofports(&quot;[number of ports] 1&quot;)
true

julia&gt; JosephsonCircuits.isnumberofports(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isoptionline-Tuple{String}" href="#JosephsonCircuits.isoptionline-Tuple{String}"><code>JosephsonCircuits.isoptionline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isoptionline(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the option line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isoptionline(&quot;# MHz Z MA R 75&quot;)
true

julia&gt; JosephsonCircuits.isoptionline(&quot;[number of ports] 1&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isreference-Tuple{String}" href="#JosephsonCircuits.isreference-Tuple{String}"><code>JosephsonCircuits.isreference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreference(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [reference] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isreference(&quot;[reference]&quot;)
true

julia&gt; JosephsonCircuits.isreference(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.istwoportdataorder-Tuple{String}" href="#JosephsonCircuits.istwoportdataorder-Tuple{String}"><code>JosephsonCircuits.istwoportdataorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istwoportdataorder(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [two-port data order] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.istwoportdataorder(&quot;[two-port data order] 12_21&quot;)
true

julia&gt; JosephsonCircuits.istwoportdataorder(&quot;[version] 1.0&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.isversion-Tuple{String}" href="#JosephsonCircuits.isversion-Tuple{String}"><code>JosephsonCircuits.isversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isversion(line::String)</code></pre><p>Return <code>true</code> if the string <code>line</code> is the [version] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.isversion(&quot;[version] 1.0&quot;)
true

julia&gt; JosephsonCircuits.isversion(&quot;[number of ports] 1&quot;)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N" href="#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><code>JosephsonCircuits.keepfreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keepfreqs(frequencies::Frequencies{N},
    keepcoords::AbstractVector{CartesianIndex{N}})</code></pre><p>Return a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,)], [(0,)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N" href="#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N"><code>JosephsonCircuits.keepfreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keepfreqs(frequencies::Frequencies{N},
    keepmodes::AbstractVector{NTuple{N,Int}})</code></pre><p>Return a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),[(0,0),(1,0),(0,1),(1,1)])
JosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(1, 2), CartesianIndex(2, 2)], [(0, 0), (1, 0), (0, 1), (1, 1)])

julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),Tuple{Int64,Int64}[])
JosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[], Tuple{Int64, Int64}[])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.linesearch-NTuple{4, Any}" href="#JosephsonCircuits.linesearch-NTuple{4, Any}"><code>JosephsonCircuits.linesearch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linesearch(f, fp, dfdalpha, alphamin)</code></pre><p>Quadratic linesearch based on Nocedal and Wright, chapter 3 section 5. <code>f</code> is the value at the first point alpha=0.0, <code>fp</code> is the value at the second point, alpha=1.0, <code>dfdalpha</code> is the derivative at the first point, and <code>alphamin</code> is the minimum value of <code>dfdalpha</code> below which we will take a full step. The linesearch will return the fitted minimum of the function with respect to alpha as (alpha at which minimum occurs, minimum value of function).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.matrixindices-Tuple{Any, Any, Any}" href="#JosephsonCircuits.matrixindices-Tuple{Any, Any, Any}"><code>JosephsonCircuits.matrixindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixindices(nports, format, twoportdataorder)</code></pre><p>Return the cartesian indices of the elements of a scattering matrix given the number of ports <code>nports</code> and the format <code>format</code> which can be &quot;Full&quot;, &quot;Upper&quot;, or &quot;Lower&quot;. The two port data order <code>twoportdataorder</code> can be &quot;<code>12_21</code>&quot; or &quot;<code>21_12</code>&quot; for 2 ports but must be &quot;<code>12_21</code>&quot; for other numbers of ports.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.matrixindices(2,&quot;Full&quot;,&quot;12_21&quot;)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 1)
 CartesianIndex(2, 2)

julia&gt; JosephsonCircuits.matrixindices(2,&quot;Full&quot;,&quot;21_12&quot;)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.matrixindices-Tuple{Any, Any}" href="#JosephsonCircuits.matrixindices-Tuple{Any, Any}"><code>JosephsonCircuits.matrixindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixindices(nports, format)</code></pre><p>Return the cartesian indices of the elements of a scattering matrix given the number of ports <code>nports</code> and the format <code>format</code> which can be &quot;Full&quot;, &quot;Upper&quot;, or &quot;Lower&quot;. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.matrixindices(2,&quot;Full&quot;,printflag=true)
11 12 
21 22 
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 1)
 CartesianIndex(2, 2)

julia&gt; JosephsonCircuits.matrixindices(2,&quot;Upper&quot;,printflag=true)
11 12 
   22 
      3-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia&gt; JosephsonCircuits.matrixindices(2,&quot;Lower&quot;,printflag=true)
11 
21 22 
3-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(2, 2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.networkdatatoarray-NTuple{10, Any}" href="#JosephsonCircuits.networkdatatoarray-NTuple{10, Any}"><code>JosephsonCircuits.networkdatatoarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">networkdatatoarray(networkdata, numberofports, numberoffrequencies,
    matrixformat, twoportdataorder, parameter, frequencyunit, format, R,
    version)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networkdata = [4.0, 0.9995813511383583, -17.248815971093425, 4.5, 0.9958480363660398, -26.451285931791276, 5.0, 0.9868361175866559, 2.711906450972103, 5.5, 0.9985678550072272, -12.21545548845392, 6.0, 0.9993761539770525, -16.045248853866596]
numberofports = 1
numberoffrequencies = 5
matrixformat = &quot;Full&quot;
twoportdataorder = &quot;12_21&quot;
parameter = &quot;s&quot;
frequencyunit = &quot;ghz&quot;
format = &quot;ma&quot;
R = 50.0
version = 2.0
frequencies, N = JosephsonCircuits.networkdatatoarray(networkdata,
    numberofports, numberoffrequencies, matrixformat, twoportdataorder,
    parameter, frequencyunit, format, R, version)
println(frequencies)
println(N[1,1,:])

# output
[4.0e9, 4.5e9, 5.0e9, 5.5e9, 6.0e9]
ComplexF64[0.9546262517670427 - 0.296397700700921im, 0.8915960960938982 - 0.44358732281729774im, 0.9857309246425359 + 0.04669118949947016im, 0.9759591344506418 - 0.21128542054786678im, 0.9604441706426364 - 0.2762239892126382im]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.nlsolve!-Union{Tuple{T}, Tuple{Function, Vector{T}, SparseArrays.SparseMatrixCSC{T, Int64}, Vector{T}}} where T" href="#JosephsonCircuits.nlsolve!-Union{Tuple{T}, Tuple{Function, Vector{T}, SparseArrays.SparseMatrixCSC{T, Int64}, Vector{T}}} where T"><code>JosephsonCircuits.nlsolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nlsolve!(fj!, F, J::SparseMatrixCSC, x; iterations=1000, ftol=1e-8,
    switchofflinesearchtol = 1e-5)</code></pre><p>A simple nonlinear solver for sparse matrices using Newton&#39;s method with linesearch based on Nocedal and Wright, chapter 3 section 5. A few points to note: (1) It uses KLU factorization, so only works on sparse matrices. (2) The Jacobian J cannot change sparsity structure. (3) This function attempts to reuse the symbolic factorization which can     sometimes result in a SingularException, which we catch, then create a     new factorization object.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">function fj!(F, J, x)
    if !isnothing(F)
        F[1] = (x[1]+3)*(x[2]^3-7)+18
        F[2] = sin(x[2]*exp(x[1])-1)
    end
    if !isnothing(J)
        J[1, 1] = x[2]^3-7
        J[1, 2] = 3*x[2]^2*(x[1]+3)
        u = exp(x[1])*cos(x[2]*exp(x[1])-1)
        J[2, 1] = x[2]*u
        J[2, 2] = u
    end
    return nothing
end
x = [ 0.1, 1.2]
F = [0.0, 0.0]
J = JosephsonCircuits.sparse([1, 1, 2, 2],[1, 2, 1, 2],[1.3, 0.5, 0.1, 1.2])
JosephsonCircuits.nlsolve!(fj!, F, J, x)
isapprox([0.0,1.0],x)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.nodevariabletokeyed-NTuple{6, Any}" href="#JosephsonCircuits.nodevariabletokeyed-NTuple{6, Any}"><code>JosephsonCircuits.nodevariabletokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodevariabletokeyed(nodevariable, outputmodes, nodenames, inputmodes,
    inputportnumbers, w)</code></pre><p>Convert a node variable array <code>nodevariable</code> (such as node flux or node voltage) vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.nodevariabletokeyed([1 2;3 4;;;],[(0,),(1,)],[&quot;0&quot;,&quot;1&quot;],[(0,),(1,)],[1],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 2-element Vector{Tuple{Int64}}
→   node ∈ 1-element Vector{String}
◪   inputmode ∈ 2-element Vector{Tuple{Int64}}
▨   inputport ∈ 1-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 2×1×2×1×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (&quot;1&quot;)
   (0,)    1
   (1,)    3

[:, :, 2, 1, 1] ~ (:, :, (1,), 1, 1):
          (&quot;1&quot;)
   (0,)    2
   (1,)    4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.nodevariabletokeyed-Tuple{Any, Any, Any}" href="#JosephsonCircuits.nodevariabletokeyed-Tuple{Any, Any, Any}"><code>JosephsonCircuits.nodevariabletokeyed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodevariabletokeyed(nodevariable, outputmodes, nodenames)</code></pre><p>Convert a node variable array <code>nodevariable</code> (such as node flux or node voltage) to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.nodevariabletokeyed([1 2;3 4],[(0,),(1,)],[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;])
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 2-element Vector{Tuple{Int64}}
→   node ∈ 2-element Vector{String}
And data, 2×2 Matrix{Int64}:
          (&quot;1&quot;)  (&quot;2&quot;)
   (0,)    1      2
   (1,)    3      4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.numericmatrices-Tuple{Any, Any}" href="#JosephsonCircuits.numericmatrices-Tuple{Any, Any}"><code>JosephsonCircuits.numericmatrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numericmatrices(circuit, circuitdefs; Nmodes = 1, sorting = :number)</code></pre><p>Return the numeric matrices describing the circuit properties.</p><p>See also <a href="#JosephsonCircuits.CircuitMatrices"><code>CircuitMatrices</code></a>, <a href="#JosephsonCircuits.numericmatrices-Tuple{Any, Any}"><code>numericmatrices</code></a>, <a href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcCn</code></a>, <a href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcGn</code></a>, <a href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLb</code></a>,<a href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLjb</code></a>, <a href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>calcMb</code></a>, <a href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>calcinvLn</code></a>, <a href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>calcLmean</code></a>, <a href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportindicesnumbers</code></a>, <a href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportimpedanceindices</code></a>, and <a href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcnoiseportimpedanceindices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(Lj =&gt;1000.0e-12,Cc =&gt; 100.0e-15,Cj =&gt; 1000.0e-15,Rleft =&gt; 50.0,Ipump =&gt; 1.0e-8)
println(numericmatrices(circuit,circuitdefs))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries, 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries,   [2]  =  1.0e-9,   [2]  =  1.0e-9, sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(Lj =&gt;1000.0e-12,Cc =&gt; 100.0e-15,Cj =&gt; 1000.0e-15,Rleft =&gt; 50.0,Ipump =&gt; 1.0e-8)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
println(numericmatrices(psc, cg, circuitdefs))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries, 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries,   [2]  =  1.0e-9,   [2]  =  1.0e-9, sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsecircuit-Tuple{Any}" href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>JosephsonCircuits.parsecircuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsecircuit(circuit)</code></pre><p>Parse <code>circuit</code> which is a vector where each element contains a tuple with the component name, the first node, the second node, and the component value. Component values can be numbers, symbols, or symbolic variables (including symbolic functions).</p><p>The nodes can be arbitrary strings for SPICE compatibility. Integers are also supported but are converted internally to strings. The ground node is &quot;0&quot; and is required. Specifying the type of the vector <code>circuit</code> is optional; although, typically a vector with a type union is preferable to an array of type Any.</p><p><strong>Arguments</strong></p><ul><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 L2 C2
Kfun(L) = sin(L);@register_symbolic Kfun(L1)
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,Kfun(L1)))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;One&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;One&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;One&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;One&quot;,&quot;Two&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;Two&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;Two&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;One&quot;, &quot;0&quot;, &quot;Two&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = []
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Any[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,:L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :L1, :K1, :L2, :C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsecomponenttype-Tuple{String, Vector{String}}" href="#JosephsonCircuits.parsecomponenttype-Tuple{String, Vector{String}}"><code>JosephsonCircuits.parsecomponenttype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsecomponenttype(name::String,allowedcomponents::Vector{String})</code></pre><p>The first one or two characters of the component name in the string <code>name</code> should match one of the strings in the vector <code>allowedcomponents</code>. Return the  index first of the match found.</p><p>NOTE: if a two letter component appears in allowedcomponents after a one  letter component with the same starting letter this function will match on the first value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsecomponenttype(&quot;L10&quot;,[&quot;Lj&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;])
2

julia&gt; [JosephsonCircuits.parsecomponenttype(c,[&quot;Lj&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;]) for c in [&quot;Lj&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;]]
7-element Vector{Int64}:
 1
 2
 3
 4
 5
 6
 7

julia&gt; JosephsonCircuits.parsecomponenttype(&quot;L10&quot;,[&quot;Lj&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;])
2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parseinformation!-Tuple{Vector{String}, Vector{String}, IO}" href="#JosephsonCircuits.parseinformation!-Tuple{Vector{String}, Vector{String}, IO}"><code>JosephsonCircuits.parseinformation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parseinformation!(information::Vector{String},io::IO)</code></pre><p>Append the contents of the information section of a Touchstone file from the IOBuffer or IOStream <code>io</code> to the vector <code>information</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">information = String[]
comments = String[]
io = IOBuffer(&quot;This is an information section.
[End Information]&quot;)
JosephsonCircuits.parseinformation!(information,comments,io)
println(information)

# output
[&quot;this is an information section.&quot;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsematrixformat-Tuple{String}" href="#JosephsonCircuits.parsematrixformat-Tuple{String}"><code>JosephsonCircuits.parsematrixformat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsematrixformat(line::String)</code></pre><p>Return the two-port data order string parsed from the [two-port data order] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsematrixformat(&quot;[matrix format] lower&quot;)
&quot;Lower&quot;

julia&gt; JosephsonCircuits.parsematrixformat(&quot;[matrix format] upper&quot;)
&quot;Upper&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsemixedmodeorder!-Tuple{Vector{Tuple{Char, Vector{Int64}}}, String}" href="#JosephsonCircuits.parsemixedmodeorder!-Tuple{Vector{Tuple{Char, Vector{Int64}}}, String}"><code>JosephsonCircuits.parsemixedmodeorder!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsemixedmodeorder!(mixedmodeorder::Vector{Tuple{Char, Vector{Int}}}, line::String)</code></pre><p>Append the contents of the [mixed-mode order] line of a Touchstone file from the to the vector <code>mixedmodeorder</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mixedmodeorder = Tuple{Char, Vector{Int}}[];JosephsonCircuits.parsemixedmodeorder!(mixedmodeorder,&quot;[Mixed-Mode Order] D2,3 D6,5 C2,3 C6,5 S4 S1&quot;);mixedmodeorder
6-element Vector{Tuple{Char, Vector{Int64}}}:
 (&#39;D&#39;, [2, 3])
 (&#39;D&#39;, [6, 5])
 (&#39;C&#39;, [2, 3])
 (&#39;C&#39;, [6, 5])
 (&#39;S&#39;, [4])
 (&#39;S&#39;, [1])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsenetworkdata!-Tuple{Vector{Float64}, Vector{String}, IO}" href="#JosephsonCircuits.parsenetworkdata!-Tuple{Vector{Float64}, Vector{String}, IO}"><code>JosephsonCircuits.parsenetworkdata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsenetworkdata!(networkdata::Vector{Float64}, comments::Vector{String}, io::IO)</code></pre><p>Append the contents of the networkdata section of a Touchstone file from the IOBuffer or IOStream <code>io</code> to the vector <code>networkdata</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networkdata = Float64[]
comments = String[]
io = IOBuffer(&quot;1.0000 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211
2.0000 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054
10.000 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
println(networkdata)

# output
[1.0, 0.3926, -0.1211, -0.0003, -0.0021, -0.0003, -0.0021, 0.3926, -0.1211, 2.0, 0.3517, -0.3054, -0.0096, -0.0298, -0.0096, -0.0298, 0.3517, -0.3054, 10.0, 0.3419, 0.3336, -0.0134, 0.0379, -0.0134, 0.0379, 0.3419, 0.3336]</code></pre><pre><code class="language-julia hljs">networkdata = Float64[]
comments = String[]
io = IOBuffer(&quot;2 .95 -26 3.57 157 .04 76 .66 -14
22 .60 -144 1.30 40 .14 40 .56 -85
! NOISE PARAMETERS
4 .7 .64 69 .38
18 2.7 .46 -33 .40&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
println(networkdata)

# output
[2.0, 0.95, -26.0, 3.57, 157.0, 0.04, 76.0, 0.66, -14.0, 22.0, 0.6, -144.0, 1.3, 40.0, 0.14, 40.0, 0.56, -85.0]</code></pre><pre><code class="language-julia hljs">networkdata = Float64[]
comments = String[]
io = IOBuffer(&quot;2 .95 -26 3.57 157 .04 76 .66 -14
22 .60 -144 1.30 40 .14 40 .56 -85
[Noise Data]
4 .7 .64 69 19
18 2.7 .46 -33 20
[End]&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
println(networkdata)

# output
[2.0, 0.95, -26.0, 3.57, 157.0, 0.04, 76.0, 0.66, -14.0, 22.0, 0.6, -144.0, 1.3, 40.0, 0.14, 40.0, 0.56, -85.0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsenoisedata!-Tuple{Any, Any, Any}" href="#JosephsonCircuits.parsenoisedata!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.parsenoisedata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsenoisedata!(noisedata::Vector{Float64}, comments::Vector{String},
    io::IO)</code></pre><p>Append the contents of the networkdata section of a Touchstone file from the IOBuffer or IOStream <code>io</code> to the vector <code>networkdata</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networkdata = Float64[]
noisedata = Float64[]
comments = String[]
io = IOBuffer(&quot;1.0000 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211
2.0000 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054
10.000 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
JosephsonCircuits.parsenoisedata!(noisedata,comments,io)
println(noisedata)

# output
Float64[]</code></pre><pre><code class="language-julia hljs">networkdata = Float64[]
noisedata = Float64[]
comments = String[]
io = IOBuffer(&quot;2 .95 -26 3.57 157 .04 76 .66 -14
22 .60 -144 1.30 40 .14 40 .56 -85
! NOISE PARAMETERS
4 .7 .64 69 .38
18 2.7 .46 -33 .40&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
JosephsonCircuits.parsenoisedata!(noisedata,comments,io)
println(noisedata)

# output
[4.0, 0.7, 0.64, 69.0, 0.38, 18.0, 2.7, 0.46, -33.0, 0.4]</code></pre><pre><code class="language-julia hljs">networkdata = Float64[]
noisedata = Float64[]
comments = String[]
io = IOBuffer(&quot;2 .95 -26 3.57 157 .04 76 .66 -14
22 .60 -144 1.30 40 .14 40 .56 -85
[Noise Data]
4 .7 .64 69 19
18 2.7 .46 -33 20
[End]&quot;)
JosephsonCircuits.parsenetworkdata!(networkdata,comments,io)
JosephsonCircuits.parsenoisedata!(noisedata,comments,io)
println(noisedata)

# output
[4.0, 0.7, 0.64, 69.0, 19.0, 18.0, 2.7, 0.46, -33.0, 20.0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsenumberoffrequencies-Tuple{String}" href="#JosephsonCircuits.parsenumberoffrequencies-Tuple{String}"><code>JosephsonCircuits.parsenumberoffrequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsenumberoffrequencies(line::String)</code></pre><p>Return the number of frequencies parsed from the [number of frequencies] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsenumberoffrequencies(&quot;[number of frequencies] 10&quot;)
10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsenumberofnoisefrequencies-Tuple{String}" href="#JosephsonCircuits.parsenumberofnoisefrequencies-Tuple{String}"><code>JosephsonCircuits.parsenumberofnoisefrequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsenumberofnoisefrequencies(line::String)</code></pre><p>Return the number of noise frequencies parsed from the [number of noise frequencies] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsenumberofnoisefrequencies(&quot;[number of noise frequencies] 10&quot;)
10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsenumberofports-Tuple{String}" href="#JosephsonCircuits.parsenumberofports-Tuple{String}"><code>JosephsonCircuits.parsenumberofports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsenumberofports(line::String)</code></pre><p>Return the number of ports parsed from the [number of ports] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsenumberofports(&quot;[number of ports] 1&quot;)
1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parseoptionline-Tuple{String}" href="#JosephsonCircuits.parseoptionline-Tuple{String}"><code>JosephsonCircuits.parseoptionline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parseoptionline(line::String)</code></pre><p>Return a struct TouchstoneOptionLine which contains the option line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parseoptionline(&quot;# MHz Z MA R 75&quot;)
JosephsonCircuits.TouchstoneOptionLine(&quot;MHz&quot;, &quot;Z&quot;, &quot;MA&quot;, 75.0)

julia&gt; JosephsonCircuits.parseoptionline(&quot;# MHz H RI R 75&quot;)
JosephsonCircuits.TouchstoneOptionLine(&quot;MHz&quot;, &quot;H&quot;, &quot;RI&quot;, 75.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsereference!-Tuple{Vector{Float64}, Vector{String}, String, Int64, IO}" href="#JosephsonCircuits.parsereference!-Tuple{Vector{Float64}, Vector{String}, String, Int64, IO}"><code>JosephsonCircuits.parsereference!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsereference!(reference::Vector{Float64}, comments::Vector{String},
    line::String, numberofports::Int, io::IO)</code></pre><p>Append the contents of the [reference] section of a Touchstone file from the IOBuffer or IOStream <code>io</code> to the vector <code>reference</code>. The reference impedance values can be spread across multiple lines. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">io = IOBuffer(&quot;[Reference] 50.0 60.0 75.0&quot;)
numberofports = 3
comments = String[]
reference = Float64[]
line = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))
JosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)
println(reference)

# output
[50.0, 60.0, 75.0]</code></pre><pre><code class="language-julia hljs">io = IOBuffer(&quot;[Reference] 50.0 
60.0 75.0&quot;)
numberofports = 3
comments = String[]
reference = Float64[]
line = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))
JosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)
println(reference)

# output
[50.0, 60.0, 75.0]</code></pre><pre><code class="language-julia hljs">io = IOBuffer(&quot;[Reference] 50.0 
60.0 75.0
[Number of Frequencies] 1&quot;)
numberofports = 3
comments = String[]
reference = Float64[]
line = JosephsonCircuits.stripcommentslowercase!(comments,readline(io))
JosephsonCircuits.parsereference!(reference, comments, line, numberofports, io)
println(reference)

# output
[50.0, 60.0, 75.0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsesortcircuit-Tuple{Any}" href="#JosephsonCircuits.parsesortcircuit-Tuple{Any}"><code>JosephsonCircuits.parsesortcircuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsesortcircuit(circuit; sorting = :name)</code></pre><p>Parse and sort the circuit. See <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>, <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for more explanation.</p><p><strong>Arguments</strong></p><ul><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.</li></ul><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
println(parsesortcircuit(circuit))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 3 3; 1 1 1 3 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Num[1, Ipump, Rleft, Cc, Lj, Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 L2 C2
Kfun(L) = sin(L);@register_symbolic Kfun(L1)
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,Kfun(L1)))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
println(parsesortcircuit(circuit))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsespicevariable-Tuple{String}" href="#JosephsonCircuits.parsespicevariable-Tuple{String}"><code>JosephsonCircuits.parsespicevariable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsespicevariable(variable::String)</code></pre><p>Parse a variable name string into the variable name and node number. Will this work with arbitrary node strings?</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsespicevariable(&quot;V1(5)&quot;)
(&quot;V1&quot;, 5)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;V1&quot;)
(&quot;V&quot;, 1)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;V-1&quot;)
(&quot;V&quot;, 1)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;frequency&quot;)
(&quot;frequency&quot;, &quot;frequency&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parsetwoportdataorder-Tuple{String}" href="#JosephsonCircuits.parsetwoportdataorder-Tuple{String}"><code>JosephsonCircuits.parsetwoportdataorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsetwoportdataorder(line::String)</code></pre><p>Return the two-port data order string parsed from the [two-port data order] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsetwoportdataorder(&quot;[two-port data order] 12_21&quot;)
&quot;12_21&quot;

julia&gt; JosephsonCircuits.parsetwoportdataorder(&quot;[two-port data order] 21_12&quot;)
&quot;21_12&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.parseversion-Tuple{String}" href="#JosephsonCircuits.parseversion-Tuple{String}"><code>JosephsonCircuits.parseversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parseversion(line::String)</code></pre><p>Return the version parsed from the [version] line of a Touchstone file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parseversion(&quot;[version] 1.0&quot;)
1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.phimatrixtovector!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}" href="#JosephsonCircuits.phimatrixtovector!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><code>JosephsonCircuits.phimatrixtovector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phimatrixtovector!(phivector::Vector, phimatrix::Array,
    indexmap::Vector{Int}, conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int}, Nbranches::Int)</code></pre><p>The harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts an array to a vector with the above properties.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]
conjsourceindices = [16, 6]
conjtargetindices = [21, 31]
Nbranches = 1

phivector = zeros(Complex{Float64}, Nbranches*length(freqindexmap))
phimatrix = [0.0 + 0.0im 0.0 + 3.0im 0.0 + 0.0im 0.0 + 6.0im 0.0 - 6.0im 0.0 + 0.0im 0.0 - 3.0im; 0.0 + 1.0im 0.0 + 0.0im 0.0 + 5.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 7.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 4.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 8.0im; 0.0 + 2.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;]

JosephsonCircuits.phimatrixtovector!(phivector,
    phimatrix,
    freqindexmap,
    conjsourceindices,
    conjtargetindices,
    Nbranches,
)
phivector

# output
8-element Vector{ComplexF64}:
 0.0 + 1.0im
 0.0 + 2.0im
 0.0 + 3.0im
 0.0 + 4.0im
 0.0 + 5.0im
 0.0 + 6.0im
 0.0 + 7.0im
 0.0 + 8.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.phivectortomatrix!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}" href="#JosephsonCircuits.phivectortomatrix!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><code>JosephsonCircuits.phivectortomatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phivectortomatrix!(phivector::AbstractVector,phimatrix::AbstractArray,
    indexmap::Vector{Int},conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int},Nbranches::Int)</code></pre><p>The harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts a vector to an array with the above properties.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]
conjsourceindices = [16, 6]
conjtargetindices = [21, 31]
Nbranches = 1

phivector = 1im.*Complex.(1:Nbranches*length(freqindexmap));
phimatrix=zeros(Complex{Float64},5,7,1)

JosephsonCircuits.phivectortomatrix!(phivector,
    phimatrix,
    freqindexmap,
    conjsourceindices,
    conjtargetindices,
    Nbranches,
)
phimatrix

# output
5×7×1 Array{ComplexF64, 3}:
[:, :, 1] =
 0.0+0.0im  0.0+3.0im  0.0+0.0im  0.0+6.0im  0.0-6.0im  0.0+0.0im  0.0-3.0im
 0.0+1.0im  0.0+0.0im  0.0+5.0im  0.0+0.0im  0.0+0.0im  0.0+7.0im  0.0+0.0im
 0.0+0.0im  0.0+4.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+8.0im
 0.0+2.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T" href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>JosephsonCircuits.plan_applynl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plan_applynl(fd::Array{Complex{T}})</code></pre><p>Creates an empty time domain data array and the inverse and forward plans for the RFFT of an array of frequency domain data. See also <a href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>applynl!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}" href="#JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.printsymmetries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printsymmetries(freq::Frequencies)</code></pre><p>See  <a href="#JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}"><code>printsymmetries</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,)))
3-element Vector{Int64}:
 0
 0
 0

julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsdft((2,)))
5-element Vector{Int64}:
  0
  1
  2
 -2
 -1

julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,2)))
3×5 Matrix{Int64}:
 0  1  3  -3  -1
 0  0  0   0   0
 0  2  4  -4  -2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.printsymmetries-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N" href="#JosephsonCircuits.printsymmetries-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N"><code>JosephsonCircuits.printsymmetries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printsymmetries(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})</code></pre><p>Print the conjugate symmetries in the multi-dimensional DFT or RDFT from the dimensions of the signal in the frequency domain and the time domain. Negative numbers indicate that element is the complex conjugate of the corresponding positive number. A zero indicates that element has no corresponding complex conjugate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.printsymmetries((3,),(4,))
3-element Vector{Int64}:
 0
 0
 0

julia&gt; JosephsonCircuits.printsymmetries((4,),(4,))
4-element Vector{Int64}:
  0
  1
  0
 -1

julia&gt; JosephsonCircuits.printsymmetries((3,3),(4,3))
3×3 Matrix{Int64}:
 0  1  -1
 0  0   0
 0  2  -2

julia&gt; JosephsonCircuits.printsymmetries((4,3),(4,3))
4×3 Matrix{Int64}:
  0   2  -2
  1   3   5
  0   4  -4
 -1  -5  -3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, Any}" href="#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, Any}"><code>JosephsonCircuits.processnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processnode(uniquenodedict::Dict{String, Int},
    uniquenodevector::Vector{String},node)</code></pre><p>Return the node index when given a node. Add the node string to the vector <code>uniquenodevector</code> and the dictionary <code>uniquenodedict</code> with the node string as the key and the node index (index at which it appears in  <code>uniquenodevector</code>) as the value. If &quot;node&quot; is not a string, make it a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,15))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;15&quot;]
Dict(&quot;10&quot; =&gt; 1, &quot;15&quot; =&gt; 2)</code></pre><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,:A))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;A&quot;]
Dict(&quot;A&quot; =&gt; 2, &quot;10&quot; =&gt; 1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, String}" href="#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, String}"><code>JosephsonCircuits.processnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processnode(uniquenodedict::Dict{String, Int},
    uniquenodevector::Vector{String},node::String)</code></pre><p>Return the node index when given a node. Add the node string to the vector <code>uniquenodevector</code> and the dictionary <code>uniquenodedict</code> with the node string as the key and the node index (index at which it appears in <code>uniquenodevector</code>) as the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,&quot;15&quot;))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;15&quot;]
Dict(&quot;10&quot; =&gt; 1, &quot;15&quot; =&gt; 2)</code></pre><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,&quot;10&quot;))
println(uniquenodevector)
println(uniquenodedict)

# output
1
[&quot;10&quot;]
Dict(&quot;10&quot; =&gt; 1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.pushval!-Tuple{Vector, Any, Any, Bool}" href="#JosephsonCircuits.pushval!-Tuple{Vector, Any, Any, Bool}"><code>JosephsonCircuits.pushval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushval!(V::Vector, val, c, invert::Bool)</code></pre><p>Append the value <code>val</code> of capacitance or conductance to the vector <code>V</code>. Scale the value by <code>c</code>. If <code>invert = true</code>, append <code>c/val</code> otherwise append <code>c*val</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,false);V
1-element Vector{Float64}:
 -2.0

julia&gt; V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,true);V
1-element Vector{Float64}:
 -0.5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.removeconjfreqs-Tuple{JosephsonCircuits.Frequencies}" href="#JosephsonCircuits.removeconjfreqs-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.removeconjfreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removeconjfreqs(frequencies::Frequencies{N})</code></pre><p>Return a new Frequencies struct with the conjugate symmetric terms in the DFT or RDFT removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removeconjfreqs(JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)]))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; frequencies = JosephsonCircuits.Frequencies{2}((2,2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3), CartesianIndex(1, 4), CartesianIndex(2, 4), CartesianIndex(3, 4), CartesianIndex(1, 5), CartesianIndex(2, 5), CartesianIndex(3, 5)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2), (0, -2), (1, -2), (2, -2), (0, -1), (1, -1), (2, -1)]);JosephsonCircuits.removeconjfreqs(frequencies).modes
11-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (0, 1)
 (1, 1)
 (2, 1)
 (0, 2)
 (1, 2)
 (2, 2)
 (1, -2)
 (1, -1)

julia&gt; JosephsonCircuits.removeconjfreqs(JosephsonCircuits.calcfreqsrdft((2,2))).modes
11-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (0, 1)
 (1, 1)
 (2, 1)
 (0, 2)
 (1, 2)
 (2, 2)
 (1, -2)
 (1, -1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N" href="#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><code>JosephsonCircuits.removefreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removefreqs(frequencies::Frequencies{N},
    removecoords::AbstractVector{CartesianIndex{N}})</code></pre><p>Return a new Frequency struct with the coordinates and modes for the modes in removemodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(2,), CartesianIndex(3,)], [(1,), (2,)])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,),CartesianIndex(2,),CartesianIndex(3,),CartesianIndex(4,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N" href="#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{Tuple{Vararg{Int64, N}}, 1}}} where N"><code>JosephsonCircuits.removefreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removefreqs(frequencies::Frequencies{N},
    removemodes::AbstractVector{NTuple{N,Int}})</code></pre><p>Return a new Frequency struct with the coordinates and modes for the modes in removemodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(2,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(0,),(1,),(2,),(3,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.showstruct-Tuple{IO, Any}" href="#JosephsonCircuits.showstruct-Tuple{IO, Any}"><code>JosephsonCircuits.showstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>showstruct(io::IO,out)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.warmupnumericmatrices())
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [2], Int64[], 1.0e-9, Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])

julia&gt; JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.warmupsymsold())

julia&gt; JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.warmupsyms())</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sincosnl-Tuple{Matrix{ComplexF64}}" href="#JosephsonCircuits.sincosnl-Tuple{Matrix{ComplexF64}}"><code>JosephsonCircuits.sincosnl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sincosnl(am::Array{Complex{Float64},2})</code></pre><p>Applies the junction nonlinearity to a vector of Fourier coefficients of the phases across the junction of size 2*m by (Nnodes-1) where m is the number of pump harmonics (0w, 1w, 2w, 3w, etc). To save time, this calculates both the sine and cosine nonlinearities at the same time. If the input is odd harmonics, the sine terms will also be odd harmonics the cosine terms will be even harmonics.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0.001+0im;0 0]),ComplexF64[1.0 + 0.0im 1.000999499833375 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im])
true

julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0;0 0;0 0; 0 0]), ComplexF64[0.99999900000025 + 0.0im 1.0 + 0.0im; 0.0009999995000000916 + 0.0im 0.0 + 0.0im; -4.999998333421463e-7 + 0.0im 0.0 + 0.0im; -1.6666664597909941e-10 + 0.0im 0.0 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0 + 0.0im])
true

julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0.25+0im;0 0;0 0; 0 0]),ComplexF64[0.99999900000025 + 0.0im 0.9384698079924576 + 0.0im; 0.0009999995000000916 + 0.0im 0.24226844566945333 + 0.0im; -4.999998333421463e-7 + 0.0im -0.03060435952740681 + 0.0im; -1.6666664597909941e-10 + 0.0im -0.0025556763673518224 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0003214729527288296 + 0.0im])
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sincosnloddtoboth-Tuple{Vector{ComplexF64}, Int64, Int64}" href="#JosephsonCircuits.sincosnloddtoboth-Tuple{Vector{ComplexF64}, Int64, Int64}"><code>JosephsonCircuits.sincosnloddtoboth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sincosnloddtoboth(amodd::Array{Complex{Float64},1},Nbranches::Int,m::Int)</code></pre><p>Applies the junction nonlinearity to a vector of branch fluxes of length <code>Nbranches*m</code> where <code>m</code> is the number of odd pump harmonics (1w, 3w, 5w, etc). The ordering is (mode 1, node 1), (mode 2, node 1) ... (mode 1, node 2) ... Returns even AND odd terms in a 2d array with dimensions 2*m by Nbranches.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isapprox(JosephsonCircuits.sincosnloddtoboth([0.5+0.0im,0,0,0],1,4),ComplexF64[0.765197686557965 + 0.0im; 0.44005058574495276 + 0.0im; -0.11490348493140057 + 0.0im; -0.019563353994648498 + 0.0im; 0.0024766387010484486 + 0.0im; 0.0002497629794614272 + 0.0im; -2.084411456066653e-5 + 0.0im; -3.0046516347986037e-6 + 0.0im;;])
true

julia&gt; isapprox(JosephsonCircuits.sincosnloddtoboth([0.02+0.0im,0,0.01+0.0im,0],2,2),ComplexF64[0.9996000399980445 + 0.0im 0.9999000024999694 + 0.0im; 0.019996000293322436 + 0.0im 0.009999500009166587 + 0.0im; -0.00019996666853328016 + 0.0im -4.999791669583568e-5 + 0.0im; -2.6664000106757513e-6 + 0.0im -3.3332500006440685e-7 + 0.0im])
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}" href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>JosephsonCircuits.sortnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortnodes(uniquenodevector::Vector{String},
    nodeindexvector::Vector{Int};sorting=:name)</code></pre><p>Sort the unique node names in <code>uniquenodevector</code> according to the specified sorting scheme, always placing the ground node at the beginning.</p><p>Return the sorted <code>uniquenodevector</code> and <code>nodeindexvector</code> (with the vector reshaped from a vector of length 2*Nnodes into a matrix with dimensions 2 by Nnodes).</p><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:none);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;101&quot;, &quot;111&quot;, &quot;11&quot;]
[2 2 2 2 3 3 4; 1 1 1 3 1 1 2]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:name);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;101&quot;, &quot;11&quot;, &quot;111&quot;]
[2 2 2 2 4 4 3; 1 1 1 4 1 1 2]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:number);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;11&quot;, &quot;101&quot;, &quot;111&quot;]
[3 3 3 3 4 4 2; 1 1 1 4 1 1 3]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;1&quot;, &quot;0&quot;, &quot;2&quot;],[1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],sorting=:number);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]
[2 2 2 2 0 3 3; 1 1 1 1 0 1 1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spaddkeepzeros-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" href="#JosephsonCircuits.spaddkeepzeros-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>JosephsonCircuits.spaddkeepzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spaddkeepzeros(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Add sparse matrices <code>A</code> and <code>B</code> and return the result, keeping any structural zeros, unlike the default Julia sparse matrix addition functions. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sprand(10,10,0.2); B = JosephsonCircuits.SparseArrays.sprand(10,10,0.2);JosephsonCircuits.spaddkeepzeros(A,B) == A+B
true</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,0],2,2);
B = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1],2,2);
JosephsonCircuits.spaddkeepzeros(A,B)

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  0
 ⋅  3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, LinearAlgebra.Diagonal, SparseArrays.SparseMatrixCSC, Vector}" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, LinearAlgebra.Diagonal, SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseadd!(A::SparseMatrixCSC, c::Number, Ad::Diagonal, As::SparseMatrixCSC,     indexmap::Vector)</p><p>Add sparse matrices <code>A</code> and <code>c*Ad*As</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,Ad,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  5
 ⋅  2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Vector}" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC, Ad::Diagonal,     indexmap)</p><p>Add sparse matrices <code>A</code> and <code>c*As*Ad</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,As,Ad,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  -19
 ⋅    2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, Vector}" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC, indexmap)</p><p>Add sparse matrices <code>A</code> and <code>c*As</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  5
 ⋅  2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseadd!(A::SparseMatrixCSC, As::SparseMatrixCSC, indexmap)</p><p>Add sparse matrices <code>A</code> and <code>As</code> and return the result in <code>A</code> without performing any allocations. This is only possible if the positions of elements in <code>As</code> are a subset of the positions of elements in <code>A</code>. The <code>indexmap</code> can be generated with <a href="#JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>sparseaddmap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 4  1
 ⋅  2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseaddconjsubst!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Any, LinearAlgebra.Diagonal, LinearAlgebra.Diagonal, Vector, Any}" href="#JosephsonCircuits.sparseaddconjsubst!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Any, LinearAlgebra.Diagonal, LinearAlgebra.Diagonal, Vector, Any}"><code>JosephsonCircuits.sparseaddconjsubst!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseaddconjsubst!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC,     Ad::Diagonal, indexmap, conjflag::Diagonal, wmodesm::Diagonal,     freqsubstindices::Vector, symfreqvar)</p><p>Perform the operation <code>A+c*As*Ad</code> and return the result in <code>A</code>. Take the complex conjugate of <code>As</code> for any column where <code>conjflag = true</code>.</p><p>The sparse matrix <code>As</code> must have nonzero elements only in a subset of the  positions in <code>A</code> which has nonzero lements.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1.0+1.0im,2.0+1.0im,-3.0+0.0im],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3.0+2.0im,4.0+3.0im],2,2)
wmodesm = JosephsonCircuits.LinearAlgebra.Diagonal([-1,1])
indexmap = JosephsonCircuits.sparseaddmap(A,As)
freqsubstindices  = JosephsonCircuits.symbolicindices(As)
JosephsonCircuits.sparseaddconjsubst!(A,2,As,Ad,indexmap,wmodesm .&lt; 0,wmodesm,freqsubstindices,nothing)
A

# output
2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 3 stored entries:
 7.0-3.0im  -19.0-12.0im
     ⋅        2.0+1.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" href="#JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>JosephsonCircuits.sparseaddmap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sparseaddmap(A::SparseMatrixCSC, B::SparseMatrixCSC)</p><p>Return a vector of length <code>nnz(B)</code> which maps the indices of elements of <code>B</code> in <code>B.nzval</code> to the corresponding indices in <code>A.nzval</code>. The sparse matrix <code>B</code> must have elements in a subset of the positions in <code>A</code> which have nonzero entries (structural zeros are elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1], [2], [4],2,2)
JosephsonCircuits.sparseaddmap(A,As)

# output
1-element Vector{Int64}:
 2</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [4,2],2,2)
JosephsonCircuits.sparseaddmap(A,As)

# output
2-element Vector{Int64}:
 1
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spice_hb_load-Tuple{Any}" href="#JosephsonCircuits.spice_hb_load-Tuple{Any}"><code>JosephsonCircuits.spice_hb_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spice_hb_load(filename)</code></pre><p>Load a Xyce harmonic balance simulation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spice_raw_load-Tuple{Any}" href="#JosephsonCircuits.spice_raw_load-Tuple{Any}"><code>JosephsonCircuits.spice_raw_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spice_raw_load(filename)</code></pre><p>Parse the binary raw output file from WRSPICE or Xyce. Tested for transient analysis and frequency domain analysis. The file format is documented in the WRSPICE manual in Appendix 1, File Formats, A.1 Rawfile Format http://www.srware.com/xictools/docs/wrsmanual-4.3.13.pdf</p><p>The Xyce rawfile format is very similar and described in: https://xyce.sandia.gov/files/xyce/Reference_Guide.pdf#section.8.2</p><p>The function outputs a header, the times/frequencies, the currents, and the voltages. The voltage and current arrays have dimensions nVoltages by nPoints and nCurrents by nPoints.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spice_run-Tuple{AbstractVector{String}, Any}" href="#JosephsonCircuits.spice_run-Tuple{AbstractVector{String}, Any}"><code>JosephsonCircuits.spice_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spice_run(input::AbstractArray{String,1})</code></pre><p>If the input to wrspice_run() is an array of strings, then call multiple processes in parallel. The number of parallel processes is decided from Threads.nthreads(). It can be changed manually.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spice_run-Tuple{String, Any}" href="#JosephsonCircuits.spice_run-Tuple{String, Any}"><code>JosephsonCircuits.spice_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spice_run(input::String, spicecmd::String)</code></pre><p>Argument is a string containing the input commands for wrspice.  This function saves the string to disk, runs spice, parses the results with wrsplice_load(), then returns those parsed results.</p><p>The input should not should have a file name listed after the write command in the .control block so that we can specify the raw output file with a command line argument.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.spmatmul!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{Bool}}" href="#JosephsonCircuits.spmatmul!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{Bool}}"><code>JosephsonCircuits.spmatmul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spmatmul!(C::SparseMatrixCSC, A::SparseMatrixCSC, B::SparseMatrixCSC,
    xb::Vector{Bool})</code></pre><p>Non-allocating sparse matrix multiplication of <code>A</code> and <code>B</code> when sparsity pattern of product <code>C</code> is known. Based on spmatmul from SparseArrays.jl https://github.com/JuliaSparse/SparseArrays.jl/blob/main/src/linalg.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = JosephsonCircuits.sprand(100,100,0.1);b = JosephsonCircuits.sprand(100,100,0.1);c = a*b; d = copy(c);xb = fill(false, size(a,1));JosephsonCircuits.spmatmul!(c,a,b,xb);c == d
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sprandsubset" href="#JosephsonCircuits.sprandsubset"><code>JosephsonCircuits.sprandsubset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sprandsubset(A::SparseMatrixCSC, p::AbstractFloat, dropzeros = true)</code></pre><p>Given a sparse matrix <code>A</code>, return a sparse matrix with random values in some fraction of the non-zero elements with probability p. If <code>dropzeros = false</code>, then the zeros will be retained as structural zeros otherwise they are dropped.</p><p>This is used for testing non-allocating sparse matrix addition.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sprand(2,2,0.5)
B = JosephsonCircuits.sprandsubset(A, 0.1)
length(A.nzval) &gt;= length(B.nzval)

# output
true</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sprand(100,100,0.5)
B = JosephsonCircuits.sprandsubset(A, 0.1)
length(A.nzval) &gt;= length(B.nzval)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.storeuniqueloops!-Tuple{Any, Any, Any}" href="#JosephsonCircuits.storeuniqueloops!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.storeuniqueloops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storeuniqueloops!(lvarray, vmap, ul)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],[[1,2,3]]);lvarray
1-element Vector{Vector{Int64}}:
 [1, 2, 3]

julia&gt; lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],Vector{Int64}[]);lvarray
1-element Vector{Vector{Int64}}:
 []</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.stripcommentslowercase!-Tuple{Vector{String}, String}" href="#JosephsonCircuits.stripcommentslowercase!-Tuple{Vector{String}, String}"><code>JosephsonCircuits.stripcommentslowercase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stripcommentslowercase!(comments::Vector{String},line::String)</code></pre><p>Append the comment portion of a line <code>line</code> of a Touchstone file to the vector <code>comments</code>. Return the line with the comments removed and made lowercase. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; comments=String[];println(JosephsonCircuits.stripcommentslowercase!(comments,&quot;! This is a comment&quot;));println(comments)

[&quot; This is a comment&quot;]

julia&gt; comments=String[];println(JosephsonCircuits.stripcommentslowercase!(comments,&quot;This is a !comment&quot;));println(comments)
this is a 
[&quot;comment&quot;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sumbranchvalues!-Tuple{Symbol, Int64, Int64, Vector, Dict, Dict}" href="#JosephsonCircuits.sumbranchvalues!-Tuple{Symbol, Int64, Int64, Vector, Dict, Dict}"><code>JosephsonCircuits.sumbranchvalues!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumbranchvalues!(type::Symbol, node1::Int, node2::Int,componentvalues::Vector,
    countdict, indexdict)</code></pre><p>Given a branch and a type, return the sum of all of the values of the same type and branch. The sum will behave differently depending on the type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vvn = Real[1, 50.0, 1.0e-13, 2.0e-9, 2.0e-9, 5.0e-13, 5.0e-13, 0.1]
countdict = Dict((:L, 1, 3) =&gt; 2, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:C, 2, 3) =&gt; 1, (:I, 1, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:C, 1, 3, 1) =&gt; 6, (:R, 1, 2, 1) =&gt; 2, (:L, 1, 3, 1) =&gt; 4, (:C, 1, 3, 2) =&gt; 7, (:L, 1, 3, 2) =&gt; 5, (:P, 1, 2, 1) =&gt; 1, (:I, 1, 3, 1) =&gt; 8)
println(JosephsonCircuits.sumbranchvalues!(:C, 1, 3, vvn, countdict, indexdict))

# output
(true, 1.0e-12, 6)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.sumvalues-Tuple{Symbol, Any, Any}" href="#JosephsonCircuits.sumvalues-Tuple{Symbol, Any, Any}"><code>JosephsonCircuits.sumvalues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumvalues(type::Symbol, value1, value2)</code></pre><p>Sum together two values in different ways depending on the circuit component type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.sumvalues(:L, 1.0, 4.0)
0.8

julia&gt; JosephsonCircuits.sumvalues(:Lj, 1.0, 4.0)
0.8

julia&gt; JosephsonCircuits.sumvalues(:C, 1.0, 4.0)
5.0

julia&gt; JosephsonCircuits.sumvalues(:K, 1.0, 4.0)
5.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.symbolicindices-Tuple{Any}" href="#JosephsonCircuits.symbolicindices-Tuple{Any}"><code>JosephsonCircuits.symbolicindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolicindices(A)</code></pre><p>Return the indices in <code>A.nzval</code> where the elements of the matrix <code>A</code> are symbolic variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms w;A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,1.0,3*w+1]);println(A.nzval);JosephsonCircuits.symbolicindices(A)
Any[w, 1 + 3w, 1.0]
2-element Vector{Int64}:
 1
 2

julia&gt; @variables w;A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,1.0,3*w+1]);println(A.nzval);JosephsonCircuits.symbolicindices(A)
Num[w, 1 + 3w, 1.0]
2-element Vector{Int64}:
 1
 2

julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,1.0,2+3im]);JosephsonCircuits.symbolicindices(A)
Int64[]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.symbolicmatrices-Tuple{Any}" href="#JosephsonCircuits.symbolicmatrices-Tuple{Any}"><code>JosephsonCircuits.symbolicmatrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolicmatrices(circuit; Nmodes = 1, sorting = :number)</code></pre><p>Return the symbolic matrices describing the circuit properties.</p><p>See also  <a href="#JosephsonCircuits.CircuitMatrices"><code>CircuitMatrices</code></a>, <a href="#JosephsonCircuits.numericmatrices-Tuple{Any, Any}"><code>numericmatrices</code></a>, <a href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcCn</code></a>, <a href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcGn</code></a>, <a href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLb</code></a>,<a href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLjb</code></a>, <a href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>calcMb</code></a>, <a href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>calcinvLn</code></a>, <a href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>calcLmean</code></a>, <a href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportindicesnumbers</code></a>, <a href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportimpedanceindices</code></a>, and <a href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcnoiseportimpedanceindices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
println(symbolicmatrices(circuit))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolic{Real}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolic{Real}[1 / Rleft], 2, 2), 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries, 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries,   [2]  =  Lj,   [2]  =  Lj, sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
println(symbolicmatrices(psc, cg))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolic{Real}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolic{Real}[1 / Rleft], 2, 2), 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries, 2-element SparseArrays.SparseVector{Nothing, Int64} with 0 stored entries,   [2]  =  Lj,   [2]  =  Lj, sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.testshow-Tuple{IO, SparseArrays.AbstractSparseVector}" href="#JosephsonCircuits.testshow-Tuple{IO, SparseArrays.AbstractSparseVector}"><code>JosephsonCircuits.testshow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>testshow(io::IO,S)</p><p>Print <code>S</code> to the IOStream or IOBuffer <code>io</code>. This is used to generate the inputs for testing purposes. The default <code>show</code> function doesn&#39;t always produce an output which can be evaluated as the input. For example, for sparse vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([1],[2],3))
sparsevec([1], [2], 3)

julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([],Nothing[],3))
sparsevec(Int64[], Nothing[], 3)

julia&gt; JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.AxisKeys.KeyedArray(rand(Int8, 2,10), ([:a, :b], 10:10:100)))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_file-Tuple{AbstractVector{Float64}, Array{ComplexF64, 3}}" href="#JosephsonCircuits.touchstone_file-Tuple{AbstractVector{Float64}, Array{ComplexF64, 3}}"><code>JosephsonCircuits.touchstone_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_file(f::Vector{Float64}, N::Array{Complex{Float64}};
    frequencyunit::String = &quot;GHz&quot;,
    parameter::String = &quot;S&quot;,
    format::String = &quot;MA&quot;,
    R::Float64 = 50.0, 
    version::Float64 = 2.0,
    twoportdataorder::String = &quot;&quot;,
    numberofnoisefrequencies::Int = 0,
    reference::Vector{Float64} = Float64[],
    information::Vector{String} = String[],
    matrixformat::String = &quot;Full&quot;,
    mixedmodeorder::Vector{Tuple{Char, Vector{Int}}} = Tuple{Char, Vector{Int}}[],
    comments::Vector{String} = String[],
    noisedata::Vector{Float64} = Float64[])</code></pre><p>Generate a TouchstoneFile struct from the frequency vector <code>f</code> in units of Hz and the complex network data array <code>N</code> where the frequency axis is the last dimension. All other arguments are optional.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_load-Tuple{Any}" href="#JosephsonCircuits.touchstone_load-Tuple{Any}"><code>JosephsonCircuits.touchstone_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_load(filename)</code></pre><p>Read a file in the Touchstone format. Standard compliant.</p><p>This is the 1.1 spec: https://ibis.org/connector/touchstone<em>spec11.pdf and the 2.0 spec: https://ibis.org/touchstone</em>ver2.0/touchstone<em>ver2</em>0.pdf</p><p>Outputs un-normalized network parameters with frequency units of Hz. Don&#39;t enforce any particular file extension or try to infer the number of ports from the extension.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_parse-Tuple{IO}" href="#JosephsonCircuits.touchstone_parse-Tuple{IO}"><code>JosephsonCircuits.touchstone_parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_parse(io::IO)</code></pre><p>Parse the Touchstone file described by the IOBuffer or IOStream <code>io</code>.</p><p>This is the 1.1 spec: https://ibis.org/connector/touchstone<em>spec11.pdf and the 2.0 spec: https://ibis.org/touchstone</em>ver2.0/touchstone<em>ver2</em>0.pdf</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">str=&quot;!Example 1:
!1-port S-parameter file, single frequency point
# MHz S MA R 50
!freq magS11 angS11
2.000 0.894 -12.136&quot;;
println(str);
JosephsonCircuits.touchstone_parse(IOBuffer(str))

# output
!Example 1:
!1-port S-parameter file, single frequency point
# MHz S MA R 50
!freq magS11 angS11
2.000 0.894 -12.136
JosephsonCircuits.TouchstoneFile([2.0e6], ComplexF64[0.874020294860635 - 0.18794819544685323im;;;], &quot;mhz&quot;, &quot;s&quot;, &quot;ma&quot;, 50.0, 1.0, 1, &quot;12_21&quot;, 1, 0, [50.0], String[], &quot;Full&quot;, Tuple{Char, Vector{Int64}}[], [&quot;Example 1:&quot;, &quot;1-port S-parameter file, single frequency point&quot;, &quot;freq magS11 angS11&quot;], [2.0, 0.894, -12.136], Float64[])</code></pre><pre><code class="nohighlight hljs">str=&quot;!Example 4 (Version 2.0):
! 4-port S-parameter data
! Default impedance is overridden by [Reference]
! Data cannot be represented using 1.0 syntax
! Note that the [Reference] keyword arguments appear on a separate line
[Version] 2.0
# GHz S MA R 50
[Number of Ports] 4
[Reference]
50 75 0.01 0.01
[Number of Frequencies] 1
[Network Data]
5.00000 0.60 161.24 0.40 -42.20 0.42 -66.58 0.53 -79.34 !row 1
0.40 -42.20 0.60 161.20 0.53 -79.34 0.42 -66.58 !row 2
0.42 -66.58 0.53 -79.34 0.60 161.24 0.40 -42.20 !row 3
0.53 -79.34 0.42 -66.58 0.40 -42.20 0.60 161.24 !row 4&quot;;
println(str);
JosephsonCircuits.touchstone_parse(IOBuffer(str))

# output
!Example 4 (Version 2.0):
! 4-port S-parameter data
! Default impedance is overridden by [Reference]
! Data cannot be represented using 1.0 syntax
! Note that the [Reference] keyword arguments appear on a separate line
[Version] 2.0
# GHz S MA R 50
[Number of Ports] 4
[Reference]
50 75 0.01 0.01
[Number of Frequencies] 1
[Network Data]
5.00000 0.60 161.24 0.40 -42.20 0.42 -66.58 0.53 -79.34 !row 1
0.40 -42.20 0.60 161.20 0.53 -79.34 0.42 -66.58 !row 2
0.42 -66.58 0.53 -79.34 0.60 161.24 0.40 -42.20 !row 3
0.53 -79.34 0.42 -66.58 0.40 -42.20 0.60 161.24 !row 4
JosephsonCircuits.TouchstoneFile([5.0e9], ComplexF64[-0.5681244079815996 + 0.1929628385351877im 0.29632183851470006 - 0.2686882357291961im 0.16693665375723588 - 0.38539869438327984im 0.09803970583787712 - 0.5208533537179372im; 0.29632183851470006 - 0.2686882357291961im -0.5679895560694177 + 0.1933594171383067im 0.09803970583787712 - 0.5208533537179372im 0.16693665375723588 - 0.38539869438327984im; 0.16693665375723588 - 0.38539869438327984im 0.09803970583787712 - 0.5208533537179372im -0.5681244079815996 + 0.1929628385351877im 0.29632183851470006 - 0.2686882357291961im; 0.09803970583787712 - 0.5208533537179372im 0.16693665375723588 - 0.38539869438327984im 0.29632183851470006 - 0.2686882357291961im -0.5681244079815996 + 0.1929628385351877im;;;], &quot;ghz&quot;, &quot;s&quot;, &quot;ma&quot;, 50.0, 2.0, 4, &quot;12_21&quot;, 1, 0, [50.0, 75.0, 0.01, 0.01], String[], &quot;Full&quot;, Tuple{Char, Vector{Int64}}[], [&quot;Example 4 (Version 2.0):&quot;, &quot; 4-port S-parameter data&quot;, &quot; Default impedance is overridden by [Reference]&quot;, &quot; Data cannot be represented using 1.0 syntax&quot;, &quot; Note that the [Reference] keyword arguments appear on a separate line&quot;, &quot;row 1&quot;, &quot;row 2&quot;, &quot;row 3&quot;, &quot;row 4&quot;], [5.0, 0.6, 161.24, 0.4, -42.2, 0.42, -66.58, 0.53, -79.34, 0.4  …  0.4, -42.2, 0.53, -79.34, 0.42, -66.58, 0.4, -42.2, 0.6, 161.24], Float64[])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_save-Tuple{String, AbstractVector, AbstractArray}" href="#JosephsonCircuits.touchstone_save-Tuple{String, AbstractVector, AbstractArray}"><code>JosephsonCircuits.touchstone_save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_save(filename::String,frequencies::AbstractArray,
    N::AbstractArray;version=1.0,reference=[50.0,50.0],R = 50.0,format=&quot;RI&quot;,
    comments=[&quot;&quot;],twoportdataorder=&quot;12_21&quot;,matrixformat=&quot;Full&quot;,frequencyunit=&quot;Hz&quot;)</code></pre><p>Write a file in the Touchstone format. Standards compliant except does not support writing noise data.</p><p>This is the 1.1 spec: https://ibis.org/connector/touchstone<em>spec11.pdf and the 2.0 spec: https://ibis.org/touchstone</em>ver2.0/touchstone<em>ver2</em>0.pdf</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_write-Tuple{IO, AbstractVector{Float64}, Array{ComplexF64, 3}}" href="#JosephsonCircuits.touchstone_write-Tuple{IO, AbstractVector{Float64}, Array{ComplexF64, 3}}"><code>JosephsonCircuits.touchstone_write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_write(io::IO, frequencies::AbstractVector, N::AbstractArray;
    version=1.0, reference=[50.0,50.0], R = 50.0, format=&quot;RI&quot;,
    parameter = &quot;S&quot;, comments=[&quot;&quot;], twoportdataorder=&quot;12_21&quot;,
    matrixformat=&quot;Full&quot;, frequencyunit=&quot;Hz&quot;)</code></pre><p>Write a Touchstone file to the IOStream or IOBuffer <code>io</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();JosephsonCircuits.touchstone_write(io, [1.0e9, 2.0e9, 10.0e9], [0.3926 - 0.1211im -0.0003 - 0.0021im; -0.0003 - 0.0021im 0.3926 - 0.1211im;;; 0.3517 - 0.3054im -0.0096 - 0.0298im; -0.0096 - 0.0298im 0.3517 - 0.3054im;;; 0.3419 + 0.3336im -0.0134 + 0.0379im; -0.0134 + 0.0379im 0.3419 + 0.3336im];version=1.0,R=50.0,format=&quot;RI&quot;,frequencyunit=&quot;Hz&quot;,comments=[&quot;Example 4:&quot;,&quot;2-port S-parameter file, three frequency points&quot;]);println(String(take!(io)))
!Example 4:
!2-port S-parameter file, three frequency points
# Hz S RI R 50.0
! freq ReS11 ImS11 ReS21 ImS21 ReS12 ImS12 ReS22 ImS22 
1.0e9 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211
2.0e9 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054
1.0e10 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336


julia&gt; io = IOBuffer();JosephsonCircuits.touchstone_write(io, [1.0e9, 2.0e9, 10.0e9], [0.3926 - 0.1211im -0.0003 - 0.0021im; -0.0003 - 0.0021im 0.3926 - 0.1211im;;; 0.3517 - 0.3054im -0.0096 - 0.0298im; -0.0096 - 0.0298im 0.3517 - 0.3054im;;; 0.3419 + 0.3336im -0.0134 + 0.0379im; -0.0134 + 0.0379im 0.3419 + 0.3336im];version=2.0,R=50.0,format=&quot;RI&quot;,frequencyunit=&quot;Hz&quot;,comments=[&quot;Example 4:&quot;,&quot;2-port S-parameter file, three frequency points&quot;]);println(String(take!(io)))
!Example 4:
!2-port S-parameter file, three frequency points
[Version] 2.0
# Hz S RI R 50.0
[Number of Ports] 2
[Two-Port Data Order] 12_21
[Number of Frequencies] 3
[Reference] 50.0 50.0
[Network Data]
! freq ReS11 ImS11 ReS12 ImS12 ReS21 ImS21 ReS22 ImS22 
1.0e9 0.3926 -0.1211 -0.0003 -0.0021 -0.0003 -0.0021 0.3926 -0.1211
2.0e9 0.3517 -0.3054 -0.0096 -0.0298 -0.0096 -0.0298 0.3517 -0.3054
1.0e10 0.3419 0.3336 -0.0134 0.0379 -0.0134 0.0379 0.3419 0.3336
[End]
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.touchstone_write-Tuple{IO, JosephsonCircuits.TouchstoneFile}" href="#JosephsonCircuits.touchstone_write-Tuple{IO, JosephsonCircuits.TouchstoneFile}"><code>JosephsonCircuits.touchstone_write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touchstone_write(io::IO, ts::TouchstoneFile)</code></pre><p>Write a Touchstone file specified by the TouchstoneFile object <code>ts</code> to the IOStream or IOBuffer <code>io</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.truncfreqs-Tuple{JosephsonCircuits.Frequencies}" href="#JosephsonCircuits.truncfreqs-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.truncfreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncfreqs(frequencies::Frequencies;
    dc = false, odd = true, even = false, maxintermodorder = Inf)</code></pre><p>Return a new Frequencies struct with the coordinates and modes truncated according to the user specified criteria.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2).modes
12-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (3, 0)
 (0, 1)
 (1, 1)
 (0, 2)
 (0, 3)
 (0, -3)
 (0, -2)
 (0, -1)
 (1, -1)

julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));dc=false,even=false,maxintermodorder=3).modes
10-element Vector{Tuple{Int64, Int64}}:
 (1, 0)
 (3, 0)
 (0, 1)
 (2, 1)
 (1, 2)
 (0, 3)
 (0, -3)
 (1, -2)
 (0, -1)
 (2, -1)

julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2)
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(1, 3), CartesianIndex(1, 4), CartesianIndex(1, 5), CartesianIndex(1, 6), CartesianIndex(1, 7), CartesianIndex(2, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (0, 2), (0, 3), (0, -3), (0, -2), (0, -1), (1, -1)])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.tuple2edge-Tuple{Vector{NTuple{4, Int64}}}" href="#JosephsonCircuits.tuple2edge-Tuple{Vector{NTuple{4, Int64}}}"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuple2edge(tuplevector::Vector{Tuple{Int, Int, Int, Int}})</code></pre><p>Converts a vector of edges specified with tuples of integers to a vector of Graphs edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge([(1,2,3,4),(5,6,7,8)])
2-element Vector{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}}:
 (Edge 1 =&gt; 2, Edge 3 =&gt; 4)
 (Edge 5 =&gt; 6, Edge 7 =&gt; 8)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.tuple2edge-Tuple{Vector{Tuple{Int64, Int64}}}" href="#JosephsonCircuits.tuple2edge-Tuple{Vector{Tuple{Int64, Int64}}}"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuple2edge(tuplevector::Vector{Tuple{Int, Int}})</code></pre><p>Converts a vector of edges specified with tuples of integers to a vector of Graphs edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge([(1,2),(3,4)])
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 3 =&gt; 4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.tuple2edge-Union{Tuple{Dict{NTuple{4, Int64}, T}}, Tuple{T}} where T" href="#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{NTuple{4, Int64}, T}}, Tuple{T}} where T"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuple2edge(tupledict::Dict{Tuple{Int, Int, Int, Int},T})</code></pre><p>Converts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Int}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Int64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Float64}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Float64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1.0
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3.0

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Complex{Float64}}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, ComplexF64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1.0+0.0im
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3.0+0.0im

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Any}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Any} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.tuple2edge-Union{Tuple{Dict{Tuple{Int64, Int64}, T}}, Tuple{T}} where T" href="#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{Tuple{Int64, Int64}, T}}, Tuple{T}} where T"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuple2edge(tupledict::Dict{Tuple{Int, Int},T})</code></pre><p>Converts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Int64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1
  Edge 3 =&gt; 4 =&gt; 3
  Edge 2 =&gt; 3 =&gt; 2

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Float64}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Float64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1.0
  Edge 3 =&gt; 4 =&gt; 3.0
  Edge 2 =&gt; 3 =&gt; 2.0

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Complex{Float64}}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, ComplexF64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1.0+0.0im
  Edge 3 =&gt; 4 =&gt; 3.0+0.0im
  Edge 2 =&gt; 3 =&gt; 2.0+0.0im

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Any}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Any} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1
  Edge 3 =&gt; 4 =&gt; 3
  Edge 2 =&gt; 3 =&gt; 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.updateAoLjbm!-Tuple{SparseArrays.SparseMatrixCSC, Any, SparseArrays.SparseVector, Any, Any, Any}" href="#JosephsonCircuits.updateAoLjbm!-Tuple{SparseArrays.SparseMatrixCSC, Any, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.updateAoLjbm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateAoLjbm!(AoLjbm::SparseMatrixCSC, Am, Ljb::SparseVector, Lmean, Nmodes,
    Nbranches)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;
AoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2);
AoLjbmcopy = copy(AoLjbm);
AoLjbmcopy.nzval .= 0;
JosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)
all(AoLjbmcopy.nzval .- AoLjbm.nzval .== 0)

# output
true</code></pre><pre><code class="language-julia hljs">@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;
AoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2);
AoLjbmcopy = copy(AoLjbm);
AoLjbmcopy.nzval .= 0;
JosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2)
all(AoLjbmcopy.nzval .- AoLjbm.nzval .== 0)

# output
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.updateAoLjbm2!-Tuple{SparseArrays.SparseMatrixCSC, Array, Any, Any, SparseArrays.SparseVector, Any}" href="#JosephsonCircuits.updateAoLjbm2!-Tuple{SparseArrays.SparseMatrixCSC, Array, Any, Any, SparseArrays.SparseVector, Any}"><code>JosephsonCircuits.updateAoLjbm2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateAoLjbm2!(AoLjbm::SparseMatrixCSC, Am::Array, AoLjbmindices,
    conjindicessorted, Ljb::SparseVector, Lmean)</code></pre><p>Update the values in the sparse AoLjbm matrix in place.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{Any, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{Any, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value, circuitdefs)</code></pre><p>If the component value <code>value</code> is a number (or a type we haven&#39;t considered, return it as is.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(1.0,Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{Complex{Num}, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{Complex{Num}, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value::Complex{Symbolics.Num},circuitdefs)</code></pre><p>If the component value is Complex{Symbolics.Num}, then try substituting in the definition from <code>circuitdefs</code>. </p><p>NOTE: Below fails because Symbolics.jl doesn&#39;t have good support for complex  numbers.  @variables Lj1::Complex Lj2::Complex;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=&gt;3.0e-12,Lj2=&gt;1.0e-12)) 4.0e-12</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Lj1::Complex;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=&gt;3.0e-12))
3.0e-12</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{Num, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{Num, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbolics.Num,circuitdefs)</code></pre><p>If the component value is Symbolics.Num, then try substituting in the definition from <code>circuitdefs</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=&gt;3.0e-12))
3.0e-12

julia&gt; @variables Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=&gt;3.0e-12,Lj2=&gt;1.0e-12))
4.0e-12</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{String, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{String, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value::String,circuitdefs)</code></pre><p>If the component value is a string, assume it is a dictionary key.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(&quot;Lj1&quot;,Dict(&quot;Lj1&quot;=&gt;1e-12,&quot;Lj2&quot;=&gt;2e-12))
1.0e-12</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{Symbol, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{Symbol, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbol,circuitdefs)</code></pre><p>If the component value is a symbol, assume it is a dictionary key.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(:Lj1,Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
1.0e-12</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.valuetonumber-Tuple{SymbolicUtils.Symbolic, Any}" href="#JosephsonCircuits.valuetonumber-Tuple{SymbolicUtils.Symbolic, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbolics.Symbol, circuitdefs)</code></pre><p>If the component value <code>value</code> has a type Complex{Symbolics.Num}, then try substituting in the definition from <code>circuitdefs</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=&gt;3.0e-12))
3.0e-12

julia&gt; @syms Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=&gt;3.0e-12,Lj2=&gt;1.0e-12))
4.0e-12</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.visualizefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, JosephsonCircuits.Frequencies{N}}} where N" href="#JosephsonCircuits.visualizefreqs-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, JosephsonCircuits.Frequencies{N}}} where N"><code>JosephsonCircuits.visualizefreqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visualizefreqs(w::NTuple{N,Any}, freq::Frequencies{N})</code></pre><p>Create a vector or array containing the mixing products for visualization  purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables wp1
w = (wp1,)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,)),
        dc=true, odd=true, even=true, maxintermodorder=Inf,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4-element Vector{Num}:
    0
  wp1
 2wp1
 3wp1</code></pre><pre><code class="language-julia hljs">@variables wp1,wp2
w = (wp1,wp2)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,3)),
        dc=true, odd=true, even=true, maxintermodorder=3,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4×7 Matrix{Num}:
    0         wp2        2wp2  3wp2  -3wp2       -2wp2        -wp2
  wp1   wp1 + wp2  wp1 + 2wp2     0      0  wp1 - 2wp2   wp1 - wp2
 2wp1  wp2 + 2wp1           0     0      0           0  2wp1 - wp2
 3wp1           0           0     0      0           0           0</code></pre><pre><code class="language-julia hljs">w = (1.1,1.2)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,3)),
        dc=true, odd=true, even=true, maxintermodorder=3,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4×7 Matrix{Float64}:
 0.0  1.2  2.4  3.6  -3.6  -2.4  -1.2
 1.1  2.3  3.5  0.0   0.0  -1.3  -0.1
 2.2  3.4  0.0  0.0   0.0   0.0   1.0
 3.3  0.0  0.0  0.0   0.0   0.0   0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.wrspice_calcS_paramp-Tuple{Any, Any, Any}" href="#JosephsonCircuits.wrspice_calcS_paramp-Tuple{Any, Any, Any}"><code>JosephsonCircuits.wrspice_calcS_paramp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrspice_calcS_paramp(out, wswrspice, Nnodes, stepsperperiod = 80,
    Is = 1e-13)</code></pre><p>This function assume the first node is the input port and the last node is the output port. Nnodes is the number of nodes including the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nnodes = 2
ws = 2*pi*5e9
wp = 2*pi*6e9
stepsperperiod = 80
t = LinRange(0,2*pi/wp,stepsperperiod)
Is = 1e-13
Vpump = zeros(1,length(t))
Vsignalsin = zeros(1,length(t))
Vsignalcos = zeros(1,length(t))
Vpump[1,:] .= sin.(2*pi*wp*t)
Vsignalsin[1,:] .= sin.(2*pi*wp*t)+Is/50*sin.(2*pi*ws*t)
Vsignalcos[1,:] .= sin.(2*pi*wp*t)+Is/50*cos.(2*pi*ws*t)

out = [(values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vpump),),
        (values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vsignalsin),),
        (values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vsignalcos),),
        ];
out[1].values[&quot;V&quot;];
out[2].values[&quot;V&quot;];
out[3].values[&quot;V&quot;];
JosephsonCircuits.wrspice_calcS_paramp(out, 2*pi, Nnodes;
    stepsperperiod = stepsperperiod, Is = Is)

# output
(S11 = ComplexF64[-0.9999710828404902 + 2.7521387922213123e-5im], S21 = ComplexF64[2.8917159509832197e-5 + 2.7521387922213123e-5im])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.wrspice_cmd-Tuple{}" href="#JosephsonCircuits.wrspice_cmd-Tuple{}"><code>JosephsonCircuits.wrspice_cmd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrspice_cmd()</code></pre><p>This returns the path of the WRSPICE executable.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.wrspice_input_ac-Tuple{String, AbstractVector{Float64}, Any, Any}" href="#JosephsonCircuits.wrspice_input_ac-Tuple{String, AbstractVector{Float64}, Any, Any}"><code>JosephsonCircuits.wrspice_input_ac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrspice_input_ac(netlist,nsteps,fstart,fstop)</code></pre><p>Generate the WRSPICE input file for an AC small signal simulation using circuit parameters from the given netlist, and the specified frequency range. Example usage:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_ac(&quot;* SPICE Simulation&quot;,100,4e9,5e9,[1,2],1e-6))
* SPICE Simulation
* AC current source with magnitude 1 and phase 0
isrc 1 0 ac 1.0e-6 0.0

* Set up the AC small signal simulation
.ac lin 100 4.0g 5.0g

* The control block
.control

* Maximum size of data to export in kilobytes from 1e3 to 2e9 with 
* default 2.56e5. This has to come before the run command
set maxdata = 10e6

* Run the simulation
run

* Binary files are faster to save and load. 
set filetype=binary

* Leave filename empty so we can add that as a command line argument.
* Don&#39;t specify any variables so it saves everything.    
write

.endc
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_ac(&quot;* SPICE Simulation&quot;,(4:0.01:5)*1e9,[1,2],1e-6))
* SPICE Simulation
* AC current source with magnitude 1 and phase 0
isrc 1 0 ac 1.0e-6 0.0

* Set up the AC small signal simulation
.ac lin 99 4.0g 5.0g

* The control block
.control

* Maximum size of data to export in kilobytes from 1e3 to 2e9 with 
* default 2.56e5. This has to come before the run command
set maxdata = 10e6

* Run the simulation
run

* Binary files are faster to save and load. 
set filetype=binary

* Leave filename empty so we can add that as a command line argument.
* Don&#39;t specify any variables so it saves everything.    
write

.endc
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.wrspice_input_paramp-NTuple{4, Any}" href="#JosephsonCircuits.wrspice_input_paramp-NTuple{4, Any}"><code>JosephsonCircuits.wrspice_input_paramp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrspice_input_paramp(netlist, ws, wp, Ip; stepsperperiod = 80, Is = 1e-13,
    tstop = 200e-9, trise = 10e-9)</code></pre><p>Generate the WRSPICE input files for a time domain domain simulation in which the signal angular frequency is swept over <code>ws</code> with pump angular frequency <code>wp</code> and pump current <code>Ip</code>. </p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using JosephsonCircuits
using Plots
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc),
    (&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj)]
circuitdefs = Dict(
    :Lj =&gt;1000.0e-12,
    :Cc =&gt; 100.0e-15,
    :Cj =&gt; 1000.0e-15,
    :R =&gt; 50.0)
ws = 2*pi*(4.5:0.001:5.0)*1e9
wp = (2*pi*4.75001*1e9,)
Ip = 0.00565e-6
sources = [(mode=(1,),port=1,current=Ip)]
Npumpharmonics = (16,)
Nmodulationharmonics = (8,)
@time jpa = hbsolve(ws, wp, sources, Nmodulationharmonics,
    Npumpharmonics, circuit, circuitdefs)
wswrspice=2*pi*(4.5:0.01:5.0)*1e9
n = JosephsonCircuits.exportnetlist(circuit,circuitdefs);
input = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,wp[1],2*Ip);
@time output = JosephsonCircuits.spice_run(input,JosephsonCircuits.wrspice_cmd());
S11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes);
plot(ws/(2*pi*1e9),
    10*log10.(abs2.(jpa.linearized.S((0,),1,(0,),1,:))),
    label=&quot;JosephsonCircuits.jl&quot;,
    xlabel=&quot;Frequency (GHz)&quot;,
    ylabel=&quot;S11 (dB)&quot;)
plot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),
    label=&quot;WRSPICE&quot;,
    seriestype=:scatter)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JosephsonCircuits.wrspice_input_transient-NTuple{10, Any}" href="#JosephsonCircuits.wrspice_input_transient-NTuple{10, Any}"><code>JosephsonCircuits.wrspice_input_transient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrspice_input_transient(netlist, idrive, fdrive, thetadrive, idrive2,
    fdrive2, thetadrive2, tstep, tstop, trise; maxdata = 10e6, jjaccel = 1,
    dphimax = 0.01, filetype = &quot;binary&quot;)</code></pre><p>Generate the WRSPICE input file for a transient simulation using circuit  parameters from the given netlist, the source current and frequency, and the  time step and stop time. Leave filename empty so we can add that as a command line argument. Don&#39;t specify any variables so it saves everything.</p><p><strong>Arguments</strong></p><ul><li><code>netlist</code>: </li><li><code>idrive</code>: </li><li><code>fdrive</code>: </li><li><code>thetadrive</code>: </li><li><code>idrive2</code>: </li><li><code>fdrive2</code>: </li><li><code>thetadrive2</code>: </li><li><code>tstep</code>: </li><li><code>tstop</code>: </li><li><code>trise</code>: </li></ul><p><strong>Keywords</strong></p><ul><li><code>maxdata = 10e6</code>: Maximum size of data to export in kilobytes from 1e3 to   2e9 with  default 2.56e5. This has to come before the run command.</li><li><code>jjaccel = 1</code>: Causes a faster convergence testing and iteration control   algorithm to be used, rather than the standard more comprehensive   algorithm suitable for all devices.</li><li><code>dphimax = 0.01</code>: The maximum allowed phase change per time step. Decreasing   dphimax from the default of pi/5 to a smaller value is critical for   matching the accuracy of the harmonic balance method simulations. This   increases simulation time by pi/5/(dphimax).</li><li><code>filetype = &quot;binary&quot;</code>: Binary files are faster to save and load.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_transient(&quot;* SPICE Simulation&quot;,1e-6,5e9,3.14,1e-3,6e9,6.28,1e-9,100e-9,10e-9))
* SPICE Simulation
* Current source
* 1-hyperbolic secant rise
isrc 0 1 1.0u*sin(31.41592653589793g*x+3.14)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))
isrc2 0 1 1000.0u*sin(37.69911184307752g*x+6.28)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))

* isrc 1 0 sin(0 1.0u 5.0g 0.0 179.90874767107852)
* isrc2 1 0 sin(0 1000.0u 6.0g 0.0 359.81749534215703)

* Set up the transient simulation
* .tran 5p 10n
.tran 1000.0000000000001p 100.0n uic

* The control block
.control
set maxdata=1.0e7
set jjaccel=1
set dphimax=0.01
run
set filetype=binary
write
.endc
</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« JosephsonCircuits.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Monday 18 September 2023 14:59">Monday 18 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
