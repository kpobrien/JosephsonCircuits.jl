<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · JosephsonCircuits</title><meta name="title" content="Reference · JosephsonCircuits"/><meta property="og:title" content="Reference · JosephsonCircuits"/><meta property="twitter:title" content="Reference · JosephsonCircuits"/><meta name="description" content="Documentation for JosephsonCircuits."/><meta property="og:description" content="Documentation for JosephsonCircuits."/><meta property="twitter:description" content="Documentation for JosephsonCircuits."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JosephsonCircuits</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">JosephsonCircuits.jl</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kpobrien/JosephsonCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Phi0"><a class="docstring-binding" href="#JosephsonCircuits.Phi0"><code>JosephsonCircuits.Phi0</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Phi0</code></pre><p>A constant for Phi0, the magnetic flux quantum in Weber, H<em>A: Phi0 = h/(2</em>charge of electron).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.boltzmann_constant"><a class="docstring-binding" href="#JosephsonCircuits.boltzmann_constant"><code>JosephsonCircuits.boltzmann_constant</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const boltzmann_constant</code></pre><p>A constant for the Boltzmann constant which is 1.380649×10−23 J/K.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.phi0"><a class="docstring-binding" href="#JosephsonCircuits.phi0"><code>JosephsonCircuits.phi0</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const phi0</code></pre><p>A constant for phi0, the reduced magnetic flux quantum in Weber, H<em>A: phi0 = hbar/(2</em>charge of electron).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.planck_constant"><a class="docstring-binding" href="#JosephsonCircuits.planck_constant"><code>JosephsonCircuits.planck_constant</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const planck_constant</code></pre><p>A constant for the Planck constant which is 6.62607015e-34 J*s.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.reduced_planck_constant"><a class="docstring-binding" href="#JosephsonCircuits.reduced_planck_constant"><code>JosephsonCircuits.reduced_planck_constant</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const reduced_planck_constant</code></pre><p>A constant for the reduced Planck constant which is planck_constant/(2*pi).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.speed_of_light"><a class="docstring-binding" href="#JosephsonCircuits.speed_of_light"><code>JosephsonCircuits.speed_of_light</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const speed_of_light</code></pre><p>A constant for the speed of light which is 2.99792458e8 m/s.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.CircuitGraph"><a class="docstring-binding" href="#JosephsonCircuits.CircuitGraph"><code>JosephsonCircuits.CircuitGraph</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CircuitGraph(edge2indexdict, Rbn, searray, cearray, glearray, lvarray,
    isolatednodes, gl, Nbranches)</code></pre><p>A simple structure to hold the circuit graph information.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.CircuitMatrices"><a class="docstring-binding" href="#JosephsonCircuits.CircuitMatrices"><code>JosephsonCircuits.CircuitMatrices</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CircuitMatrices(Cnm::SparseMatrixCSC, Gnm::SparseMatrixCSC, Lb::SparseVector
    Lbm::SparseVector, Ljb::SparseVector, Ljbm::SparseVector,
    Mb::SparseMatrixCSC, invLnm::SparseMatrixCSC,
    Rbnm::SparseMatrixCSC{Int, Int}, portindices::Vector{Int},
    portnumbers::Vector{Int}, portimpedanceindices::Vector{Int}
    noiseportimpedanceindices::Vector{Int}, Lmean, vvn)</code></pre><p>A simple structure to hold the circuit matrices including the capacitance matrix, the conductance matrix, the inductance vectors, the Josephson inductance vectors, the mutual inductance matrix, the inverse inductance matrix, the incidence matrix, the dictionary of port and resistor values where the nodes are the keys and the values are the values, and the mean of the inductances. See also <a href="#JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><code>numericmatrices</code></a> and <a href="#JosephsonCircuits.symbolicmatrices-Tuple{AbstractVector}"><code>symbolicmatrices</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>Cnm::SparseMatrixCSC</code>: the capacitance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.</li><li><code>Gnm::SparseMatrixCSC</code>: the conductance matrix in the node basis with each   element duplicated along the diagonal Nmodes times.</li><li><code>Lb::SparseVector</code>: vector of branch linear inductances.</li><li><code>Lbm::SparseVector</code>: vector of branch linear inductances with each element   duplicated Nmodes times.</li><li><code>Ljb::SparseVector</code>: vector of branch Josephson junction inductances.</li><li><code>Ljbm::SparseVector</code>: vector of branch Josephson junction inductances with   each element duplicated Nmodes times.</li><li><code>Mb::SparseMatrixCSC</code>: the mutual inductance matrix in the branch basis.</li><li><code>invLnm::SparseMatrixCSC</code>: the inverse inductance matrix in the node basis   with each element duplicated along the diagonal Nmodes times.</li><li><code>Rbnm::SparseMatrixCSC{Int, Int}</code>: incidence matrix to convert between the   node and branch bases.</li><li><code>portindices::Vector{Int}</code>: vector of indices at which ports occur.</li><li><code>portnumbers::Vector{Int}</code>: vector of port numbers.</li><li><code>portimpedanceindices::Vector{Int}</code>: vector of indices at which port   impedances occur.</li><li><code>noiseportimpedanceindices::Vector{Int}</code>: vector of indices at which   resistive elements other than port impedances occur, for noise   calculations.</li><li><code>Lmean</code>: the mean of all of the geometric and Josephson inductances.</li><li><code>vvn</code>: the vector of component values with numbers substituted in.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.CoupledLinesBasis"><a class="docstring-binding" href="#JosephsonCircuits.CoupledLinesBasis"><code>JosephsonCircuits.CoupledLinesBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoupledLinesBasis(ZC, TI, TV, theta, U, lambda, S)</code></pre><p>A simple structure to hold the output of <code>ZC_basis_coupled_tlines</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Factorization"><a class="docstring-binding" href="#JosephsonCircuits.Factorization"><code>JosephsonCircuits.Factorization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Factorization(outofplace,inplace,kwargs)</code></pre><p>A structure to hold the factorizations and their keyword arguments.</p><p>```</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.FactorizationCache"><a class="docstring-binding" href="#JosephsonCircuits.FactorizationCache"><code>JosephsonCircuits.FactorizationCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FactorizationCache(factorization)</code></pre><p>A cache for the factorization object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.FactorizationCache(JosephsonCircuits.KLU.klu(JosephsonCircuits.sparse([1, 2], [1, 2], [1/2, 1/2], 2, 2)));
</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.FourierIndices"><a class="docstring-binding" href="#JosephsonCircuits.FourierIndices"><code>JosephsonCircuits.FourierIndices</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FourierIndices(conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}},
    vectomatmap::Vector{Int}, conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int}, hbmatmodes::Matrix{NTuple{N, Int}},
    hbmatindices::Matrix{Int})</code></pre><p>A simple structure to hold time and frequency domain information for the signals, particularly the indices for converting between the node flux vectors and matrices. See also <a href="#JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}"><code>fourierindices</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Frequencies"><a class="docstring-binding" href="#JosephsonCircuits.Frequencies"><code>JosephsonCircuits.Frequencies</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Frequencies(Nharmonics::NTuple{N, Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int},
    coords::Vector{CartesianIndex{N}}, modes::Vector{NTuple{N,Int})</code></pre><p>A simple structure to hold time and frequency domain information for the signals. See also <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>Nharmonics::NTuple{N, Int}</code>: The number of harmonics for each frequency.</li><li><code>Nw::NTuple{N,Int}</code>: The dimensions of the frequency domain signal for a   single node.</li><li><code>Nt::NTuple{N,Int}</code>: The dimensions of the time domain signal for a single   node.</li><li><code>coords::Vector{CartesianIndex{N}}</code>: The coordinates of each mixing products.</li><li><code>modes::Vector{NTuple{N,Int}}</code>: The mode indices of each mixing product, eg.    (0,0), (1,0), (2,1).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nharmonics = (2,1)
Nw = (3, 3)
Nt = (4, 3)
coords = CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)]
modes = [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)]
JosephsonCircuits.Frequencies(Nharmonics, Nw,Nt,coords,modes)

# output
JosephsonCircuits.Frequencies{2}((2, 1), (3, 3), (4, 3), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, -1), (1, -1), (2, -1)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.HB"><a class="docstring-binding" href="#JosephsonCircuits.HB"><code>JosephsonCircuits.HB</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HB(nonlinear, linearized)</code></pre><p>A simple structure to hold the nonlinear and linearized harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>nonlinear</code>: nonlinear harmonic balance solution for pump and pump   harmonics. See <a href="#JosephsonCircuits.NonlinearHB"><code>NonlinearHB</code></a>.</li><li><code>linearized</code>: linearized harmonic balance solution.   See <a href="#JosephsonCircuits.LinearizedHB"><code>LinearizedHB</code></a>.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.LinearizedHB"><a class="docstring-binding" href="#JosephsonCircuits.LinearizedHB"><code>JosephsonCircuits.LinearizedHB</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearizedHB(S, Snoise, QE, QEideal, CM, nodeflux, voltage, Nmodes, Nnodes,
    Nbranches, signalindex, w)</code></pre><p>A simple structure to hold the linearized harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>w</code>: the signal frequencies.</li><li><code>modes</code>: tuple of the signal mode indices where (0,) is the signal.</li><li><code>S</code>: the scattering matrix relating inputs and outputs for each combination   of port and frequency.</li><li><code>Snoise</code>: the scattering matrix relating inputs at the noise ports.   (lossy devices) and outputs at the physical ports for each combination of   port and frequency.</li><li><code>Ssensitivity</code>:</li><li><code>Z</code>:</li><li><code>Zadjoint</code>: </li><li><code>Zsensitivity</code>: </li><li><code>Zsensitivityadjoint</code>: </li><li><code>QE</code>: the quantum efficiency for each combination of port and frequency.</li><li><code>QEideal</code>: the quantum efficiency for an ideal amplifier with the same level   of gain, for each combination of port and frequency.</li><li><code>CM</code>: the commutation relations (equal to ±1), for each combination of port   and frequency.</li><li><code>nodeflux</code>: the node fluxes resulting from inputs at each frequency and port.</li><li><code>nodefluxadjoint</code>: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.</li><li><code>voltage</code>: the node voltages resulting from inputs at each frequency and port.</li><li><code>voltageadjoint</code>: the node fluxes resulting from inputs at each frequency   and port with a time reversed modulation.</li><li><code>nodenames</code>: the vector of unique node strings.</li><li><code>nodeindices</code>:</li><li><code>componentnames</code>:</li><li><code>componenttypes</code>:</li><li><code>componentnamedict</code>:</li><li><code>mutualinductorbranchnames</code>:</li><li><code>portnumbers</code>: vector of port numbers.</li><li><code>portindices</code>:</li><li><code>portimpedanceindices</code>:</li><li><code>noiseportimpedanceindices</code>:</li><li><code>sensitivitynames</code>:</li><li><code>sensitivityindices</code>:</li><li><code>Nmodes</code>: the number of signal and idler frequencies.</li><li><code>Nnodes</code>: the number of nodes in the circuit (including the ground node).</li><li><code>Nbranches</code>: the number of branches in the circuit.</li><li><code>Nports</code>: the number of ports.</li><li><code>signalindex</code>: the index of the signal mode.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.NonlinearHB"><a class="docstring-binding" href="#JosephsonCircuits.NonlinearHB"><code>JosephsonCircuits.NonlinearHB</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearHB(nodeflux, Rbnm, Ljb, Lb, Ljbm, Nmodes, Nbranches, S)</code></pre><p>A simple structure to hold the nonlinear harmonic balance solutions.</p><p><strong>Fields</strong></p><ul><li><code>w</code>: a tuple containing the the angular frequency of the pump in radians/s.</li><li><code>frequencies</code>:</li><li><code>nodeflux</code>: the node fluxes resulting from inputs at each frequency and   port.</li><li><code>Rbnm</code>: incidence matrix to convert between the node and branch basis.</li><li><code>Ljb</code>: sparse vector of Josephson junction inductances.</li><li><code>Lb</code>: sparse vector of linear inductances.</li><li><code>Ljbm</code>: sparse vector of linear inductances with each element duplicated   Nmodes times.</li><li><code>Nmodes</code>: the number of signal and idler frequencies.</li><li><code>Nbranches</code>: the number of branches in the circuit.</li><li><code>nodenames</code>: the vector of unique node name strings.</li><li><code>componentnames</code>: the vector of component name strings</li><li><code>portnumbers</code>: vector of port numbers.</li><li><code>portindices</code>: </li><li><code>modes</code>: tuple of the pump mode indices where (1,) is the pump in the single   pump case.</li><li><code>S</code>: the scattering matrix relating inputs and outputs for each combination   of port and frequency.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ParsedCircuit"><a class="docstring-binding" href="#JosephsonCircuits.ParsedCircuit"><code>JosephsonCircuits.ParsedCircuit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParsedCircuit(nodeindexvector::Vector{Int},
    uniquenodevector::Vector{String},
    mutualinductorbranchnames::Vector{String},
    componentnames::Vector{String}, componenttypes::Vector{Symbol},
    componentvalues::Vector, componentnamedict::Dict{String, Int},
    Nnodes::Int)</code></pre><p>A simple structure to hold the parsed circuit including a vector of node indices, the unique node names, the inductors coupled by the mutual inductors, the component names, the component types, the values of the components, a dictionary of the names of the components as keys and the index at which the component occurs as the value, and dictionaries for the ports and resistors where the pair of nodes is the key and value is the component value.</p><p>See also <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>nodeindexvector::Vector{Int}</code>: sorted vector of node indices where the   two nodes for each component occur as consecutive elements (pairs).</li><li><code>uniquenodevector::Vector{String}</code>: the unique node names.</li><li><code>mutualinductorbranchnames::Vector{String}</code>: the inductors coupled by the   mutual inductors.</li><li><code>componentnames::Vector{String}</code>: component names.</li><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering)   types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>componentnamedict::Dict{String, Int}</code>: names of the components as keys and   the index at which the component occurs as the value.</li><li><code>Nnodes::Int</code>: number of nodes including the ground node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
println(JosephsonCircuits.ParsedCircuit(
    [1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],
    [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3))

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ParsedSortedCircuit"><a class="docstring-binding" href="#JosephsonCircuits.ParsedSortedCircuit"><code>JosephsonCircuits.ParsedSortedCircuit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParsedSortedCircuit(nodeindices::Matrix{Int},
    nodenames::Vector{String},
    mutualinductorbranchnames::Vector{String},
    componentnames::Vector{String},
    componenttypes::Vector{Symbol}, componentvalues::Vector,
    componentnamedict::Dict{String, Int}, Nnodes::Int)</code></pre><p>A simple structure to hold the parsed and sorted circuit. See also <a href="#JosephsonCircuits.parsesortcircuit-Tuple{Any}"><code>parsesortcircuit</code></a>, <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>, and <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for more explanation.</p><p><strong>Fields</strong></p><ul><li><code>nodeindices::Matrix{Int}</code>: sorted array of node indices (where the length   of the first axis is 2).</li><li><code>nodenames::Vector{String}</code>: the sorted unique node names.</li><li><code>mutualinductorbranchnames::Vector{String}</code>: the inductors coupled by the   mutual inductors.</li><li><code>componentnames::Vector{String}</code>: component names.</li><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering) types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>componentnamedict::Dict{String, Int}</code>: names of the components as keys and   the index at which the component occurs as the value.</li><li><code>Nnodes::Int</code>: number of nodes including the ground node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
println(JosephsonCircuits.ParsedSortedCircuit(
    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],
    [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
    [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.SpiceRaw"><a class="docstring-binding" href="#JosephsonCircuits.SpiceRaw"><code>JosephsonCircuits.SpiceRaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpiceRaw(header::SpiceRawHeader, variables::Dict{String, Vector{String}},
    values::Dict{String,T})</code></pre><p>A simple structure to hold the SPICE raw file contents including the header, variables, and values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;), Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]), Dict{String, Matrix{ComplexF64}}(&quot;V&quot; =&gt; [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], &quot;Hz&quot; =&gt; [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))
JosephsonCircuits.SpiceRaw{Matrix{ComplexF64}}(JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;), Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]), Dict{String, Matrix{ComplexF64}}(&quot;V&quot; =&gt; [48.87562301047733 - 7.413126995337487im 49.97131616467212 + 1.1949290155299537im 49.02611690128596 - 6.90980805243651im; -10.116167243319213 + 1.534380793728424im 57.578470543293086 + 1.3775359827006193im 12.368446655904192 - 1.743197747303436im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im], &quot;Hz&quot; =&gt; [4.0e9 + 0.0im 5.0e9 + 0.0im 6.0e9 + 0.0im]))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.SpiceRawHeader"><a class="docstring-binding" href="#JosephsonCircuits.SpiceRawHeader"><code>JosephsonCircuits.SpiceRawHeader</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpiceRawHeader(title::String, date::String, plotname::String,
    flags::String, nvariables::Int, npoints::Int, command::String,
    option::String)</code></pre><p>A simple structure to hold the SPICE raw file header.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;)
JosephsonCircuits.SpiceRawHeader(&quot;CKT1&quot;, &quot;Thu Dec 29 01:29:27 2022&quot;, &quot;A.C. Small signal analysis&quot;, &quot;complex&quot;, 4, 3, &quot;version 4.3.14&quot;, &quot;&quot;)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_PiY!-Tuple{AbstractMatrix, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_PiY!-Tuple{AbstractMatrix, Number, Number, Number}"><code>JosephsonCircuits.ABCD_PiY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_PiY!(ABCD,Y1,Y2,Y3)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_PiY-Tuple{Number, Number, Number}"><code>ABCD_PiY</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_PiY!(zeros(Complex{Float64},2,2),1,2,4)
2×2 Matrix{ComplexF64}:
 1.5+0.0im  0.25+0.0im
 3.5+0.0im  1.25+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_PiY-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_PiY-Tuple{Number, Number, Number}"><code>JosephsonCircuits.ABCD_PiY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_PiY(Y1,Y2,Y3)</code></pre><p>Return the ABCD matrix for a Pi network of admittances <code>Y1</code>, <code>Y2</code>, and <code>Y3</code>.</p><pre><code class="language-julia hljs">o----Y3-----o
   |     |   
   Y1    Y2  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_PiY(1.0+0.0im,2.0+0.0im,4.0+0.0im)
2×2 Matrix{ComplexF64}:
 1.5+0.0im  0.25-0.0im
 3.5+0.0im  1.25+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_TZ!-Tuple{AbstractMatrix, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_TZ!-Tuple{AbstractMatrix, Number, Number, Number}"><code>JosephsonCircuits.ABCD_TZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_TZ!(ABCD,Z1,Z2,Z3)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_TZ-Tuple{Number, Number, Number}"><code>ABCD_TZ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_TZ!(ones(Complex{Float64},2,2),1,2,4)
2×2 Matrix{ComplexF64}:
 1.25+0.0im  3.5+0.0im
 0.25+0.0im  1.5+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_TZ-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_TZ-Tuple{Number, Number, Number}"><code>JosephsonCircuits.ABCD_TZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_TZ(Z1,Z2,Z3)</code></pre><p>Return the ABCD matrix for a T network of impedances <code>Z1</code>, <code>Z2</code>, and <code>Z3</code>.</p><pre><code class="language-julia hljs">o--Z1-----Z2--o
       |       
      Z3       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_TZ(1.0+0.0im,2.0+0.0im,4.0+0.0im)
2×2 Matrix{ComplexF64}:
 1.25+0.0im  3.5+0.0im
 0.25-0.0im  1.5+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_Pi!-Tuple{Any, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_Pi!-Tuple{Any, Number, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_Pi!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_Pi!(ABCD, Zsource, Zload, attenuationdB)</code></pre><p>Overwrite <code>ABCD</code> with the ABCD matrix for an attenuator with input impedance  <code>Zsource</code>, output impedance <code>Zload</code>, and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Rx</code>, <code>Ry</code>, and <code>Rz</code>.</p><pre><code class="language-julia hljs">o----Rz-----o
   |     |   
   Rx    Ry  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ABCD = zeros(Float64,2,2);JosephsonCircuits.ABCD_attenuator_Pi!(ABCD,50.0,50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_Pi!-Tuple{Any, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_Pi!-Tuple{Any, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_Pi!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_Pi!(ABCD, Z0, attenuationdB)</code></pre><p>Overwrite <code>ABCD</code> with the ABCD matrix for an attenuator with input and output impedance <code>Z0</code> and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Rx</code>, <code>Ry</code>, and <code>Rz</code>.</p><pre><code class="language-julia hljs">o----Rz-----o
   |     |   
   Rx    Ry  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ABCD = zeros(Float64,2,2);JosephsonCircuits.ABCD_attenuator_Pi!(ABCD,50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_Pi-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_Pi-Tuple{Number, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_Pi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_Pi(Zsource, Zload, attenuationdB)</code></pre><p>Return the ABCD matrix for an attenuator with input impedance <code>Zsource</code>, output impedance <code>Zload</code>, and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Rx</code>, <code>Ry</code>, and <code>Rz</code>.</p><pre><code class="language-julia hljs">o----Rz-----o
   |     |   
   Rx    Ry  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_attenuator_Pi(50.0,50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_Pi-Tuple{Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_Pi-Tuple{Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_Pi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_Pi(Z0,attenuationdB)</code></pre><p>Return the ABCD matrix for an attenuator with input and output impedance <code>Z0</code> and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Rx</code>, <code>Ry</code>, and <code>Rz</code>.</p><pre><code class="language-julia hljs">o----Rz-----o
   |     |   
   Rx    Ry  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_attenuator_Pi(50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_T!-Tuple{Any, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_T!-Tuple{Any, Number, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_T!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_T!(ABCD, Zsource, Zload, attenuationdB)</code></pre><p>Overwrite <code>ABCD</code> with the ABCD matrix for an attenuator with input impedance  <code>Zsource</code>, output impedance <code>Zload</code>, and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Ra</code>, <code>Rb</code>, and <code>Rc</code>.</p><pre><code class="language-julia hljs">o--Ra-----Rb--o
       |       
       Rc       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ABCD = zeros(Float64,2,2);JosephsonCircuits.ABCD_attenuator_T!(ABCD, 50.0, 50.0, 10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_T!-Tuple{Any, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_T!-Tuple{Any, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_T!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_T!(ABCD, Z0, attenuationdB)</code></pre><p>Overwrite <code>ABCD</code> with the ABCD matrix for an attenuator with input and output impedance <code>Z0</code> and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Ra</code>, <code>Rb</code>, and <code>Rc</code>.</p><pre><code class="language-julia hljs">o--Ra-----Rb--o
       |       
       Rc       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ABCD = zeros(Float64,2,2);JosephsonCircuits.ABCD_attenuator_T!(ABCD, 50.0, 10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_T-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_T-Tuple{Number, Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_T</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_T(Zsource, Zload, attenuationdB)</code></pre><p>Return the ABCD matrix for an attenuator with input impedance <code>Zsource</code>, output impedance <code>Zload</code>, and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Ra</code>, <code>Rb</code>, and <code>Rc</code>.</p><pre><code class="language-julia hljs">o--Ra-----Rb--o
       |       
       Rc       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_attenuator_T(50.0,50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_attenuator_T-Tuple{Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_attenuator_T-Tuple{Number, Number}"><code>JosephsonCircuits.ABCD_attenuator_T</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_attenuator_T(Z0,attenuationdB)</code></pre><p>Return the ABCD matrix for an attenuator with input and output impedance <code>Z0</code> and attenuation <code>attenuationdB</code> made with a T network of impedances <code>Ra</code>, <code>Rb</code>, and <code>Rc</code>.</p><pre><code class="language-julia hljs">o--Ra-----Rb--o
       |       
       Rc       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_attenuator_T(50.0,10.0)
2×2 Matrix{Float64}:
 1.73925    71.1512
 0.0284605   1.73925</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_coupled_tline!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_coupled_tline!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><code>JosephsonCircuits.ABCD_coupled_tline!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_coupled_tline!(A, Z0e, Z0o, thetae, thetao)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_coupled_tline-NTuple{4, Number}"><code>ABCD_coupled_tline</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_coupled_tline!(zeros(Complex{Float64},4,4),50,50,pi/4,pi/4)
4×4 Matrix{ComplexF64}:
 0.707107+0.0im             0.0+0.0im        …       0.0+0.0im
      0.0+0.0im        0.707107+0.0im                0.0+35.3553im
      0.0+0.0141421im       0.0+0.0im                0.0+0.0im
      0.0+0.0im             0.0+0.0141421im     0.707107+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_coupled_tline-NTuple{4, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_coupled_tline-NTuple{4, Number}"><code>JosephsonCircuits.ABCD_coupled_tline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_coupled_tline(Z0e, Z0o, thetae, thetao)</code></pre><p>Return the ABCD matrix for two coupled transmission lines described by even and odd mode phase delays <code>thetae</code> and <code>thetao</code>, and even and odd mode impedances <code>Z0e</code> and <code>Z0o</code>.</p><pre><code class="language-julia hljs">thetae, Z0e
thetao, Z0o

V1, I1 --&gt;  ======== &lt;-- I3, V3
V2, I2 --&gt;  ======== &lt;-- I4, V4

[(V1+V2)/2, (I1+I2)/2] = ABCDe * [(V3+V4)/2, -(I3+I4)/2]
[(V1-V2)/2, (I1-I2)/2] = ABCDo * [(V3-V4)/2, -(I3-I4)/2]

[V1, V2, I1, I2] = ABCD_coupled_tline * [V3, V4, -I3, -I4]</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_coupled_tline(50,50,pi/4,pi/4)
4×4 Matrix{ComplexF64}:
 0.707107+0.0im             0.0+0.0im        …       0.0+0.0im
      0.0+0.0im        0.707107+0.0im                0.0+35.3553im
      0.0+0.0141421im       0.0+0.0im                0.0+0.0im
      0.0+0.0im             0.0+0.0141421im     0.707107+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_seriesZ!-Tuple{AbstractMatrix, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_seriesZ!-Tuple{AbstractMatrix, Number}"><code>JosephsonCircuits.ABCD_seriesZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_seriesZ!(ABCD,Z1)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_seriesZ-Tuple{Number}"><code>ABCD_seriesZ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_seriesZ!(zeros(Complex{Float64},2,2),50)
2×2 Matrix{ComplexF64}:
 1.0+0.0im  50.0+0.0im
 0.0+0.0im   1.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_seriesZ-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_seriesZ-Tuple{Number}"><code>JosephsonCircuits.ABCD_seriesZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_seriesZ(Z1)</code></pre><p>Return the ABCD matrix for a series impedance <code>Z1</code>.</p><pre><code class="language-julia hljs">o---Z1---o
          
          
o--------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_seriesZ(50.0+0.0im)
2×2 Matrix{ComplexF64}:
 1.0+0.0im  50.0+0.0im
 0.0+0.0im   1.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_shuntY!-Tuple{AbstractMatrix, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_shuntY!-Tuple{AbstractMatrix, Number}"><code>JosephsonCircuits.ABCD_shuntY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_shuntY!(ABCD,Y1)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_shuntY-Tuple{Number}"><code>ABCD_shuntY</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_shuntY!(zeros(Complex{Float64},2,2),1/50)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0+0.0im
 0.02+0.0im  1.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_shuntY-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_shuntY-Tuple{Number}"><code>JosephsonCircuits.ABCD_shuntY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_shuntY(Y1)</code></pre><p>Return the ABCD matrix for a shunt admittance <code>Y1</code>.</p><pre><code class="language-julia hljs">o---------o
     |
     Y1
     |
o---------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_shuntY(1/(50.0+0.0im))
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0+0.0im
 0.02-0.0im  1.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_tline!-Tuple{AbstractMatrix, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_tline!-Tuple{AbstractMatrix, Number, Number}"><code>JosephsonCircuits.ABCD_tline!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_tline!(ABCD, Z0, theta)</code></pre><p>In-place version of <a href="#JosephsonCircuits.ABCD_tline-Tuple{Number, Number}"><code>ABCD_tline</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_tline!(ones(Complex{Float64},2,2),50, pi/4)
2×2 Matrix{ComplexF64}:
 0.707107+0.0im             0.0+35.3553im
      0.0+0.0141421im  0.707107+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCD_tline-Tuple{Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.ABCD_tline-Tuple{Number, Number}"><code>JosephsonCircuits.ABCD_tline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABCD_tline(Z0, theta)</code></pre><p>Return the ABCD matrix for a transmission line described by phase delay <code>theta</code> in radians and characteristic impedance <code>Z0</code> in Ohms.</p><pre><code class="language-julia hljs">   theta, Z0  
o--========--o
              
              
o------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.ABCD_tline(50, pi/4)
2×2 Matrix{ComplexF64}:
 0.707107+0.0im             0.0+35.3553im
      0.0+0.0141421im  0.707107+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ABCDtoS"><a class="docstring-binding" href="#JosephsonCircuits.ABCDtoS"><code>JosephsonCircuits.ABCDtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ABCDtoS(ABCD;portimpedances=50.0)</code></pre><p>Convert the 2 port chain (ABCD) matrix <code>ABCD</code> to the scattering parameter matrix <code>S</code> and return the result. Assumes a port impedance of 50 Ohms unless specified with the <code>portimpedances</code> keyword argument.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.A_coupled_tlines-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.A_coupled_tlines-NTuple{4, Any}"><code>JosephsonCircuits.A_coupled_tlines</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A_coupled_tlines(L,Cmaxwell,l,omega)</code></pre><p>Returns the 2mx2m chain (ABCD) matrix for a port number symmetric multi-port network of m coupled transmission lines described by a symmetric mxm Maxwell inductance (per unit length) matrix <code>L</code>, a symmetric mxm Maxwell capacitance matrix (per unit length) <code>Cmaxwell</code>, a physical length <code>l</code>, and an angular frequency <code>omega</code>.</p><pre><code class="language-julia hljs">V_1, I_1 --&gt;  ======== &lt;-- I_{m+1}, V_{m+1}
V_2, I_2 --&gt;  ======== &lt;-- I_{m+2}, V_{m+2}
          .
          .
          .
V_m, I_m --&gt;  ======== &lt;-- I_n, V_n
              &lt;---l--&gt;

where n=2*m.

[V_1, ...V_m, I_1, ...I_m] = A_coupled_tline * [V_{m+1}, ...V_n, I_{m+1}, ...I_n]</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Zeven = 51.0
Zodd = 49.0
neven = 1.1
nodd = 1.08
l = 3.5e-3
c = JosephsonCircuits.speed_of_light
omega = 2*pi*5e9

L, C = JosephsonCircuits.even_odd_to_maxwell(Zeven, Zodd, neven, nodd)
A1 = JosephsonCircuits.A_coupled_tlines(L,C,l,omega)
A2 = JosephsonCircuits.ABCD_coupled_tline(Zeven,Zodd,neven*omega/c*l,nodd*omega/c*l)
println(isapprox(A1,A2))

# output
true</code></pre><p><strong>References</strong></p><p>Paul, Clayton R. Analysis of Multiconductor Transmission Lines, Second Edition. Wiley, 2008.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoB"><a class="docstring-binding" href="#JosephsonCircuits.AtoB"><code>JosephsonCircuits.AtoB</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AtoB(A)</code></pre><p>Convert the chain (ABCD) matrix <code>A</code> to the inverse chain matrix <code>B</code> and return the result. Note that despite the name, the inverse of the chain matrix is not equal to the inverse chain matrix, inv(A) ≠ B.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Complex{Float64}[1.0 0.0;1/50 1.0];JosephsonCircuits.AtoB(A)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0+0.0im
 0.02-0.0im  1.0-0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.AtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.AtoB!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AtoB!(B::AbstractMatrix,A::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.AtoB"><code>AtoB</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoS"><a class="docstring-binding" href="#JosephsonCircuits.AtoS"><code>JosephsonCircuits.AtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AtoS(A)</code></pre><p>Convert the chain (ABCD) matrix <code>A</code> to the scattering parameter matrix <code>S</code> and return the result.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.AtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>JosephsonCircuits.AtoS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AtoS!(S::AbstractMatrix, A::AbstractMatrix, tmp::AbstractMatrix,
    sqrtportimpedances1, sqrtportimpedances2)</code></pre><p>See <a href="#JosephsonCircuits.AtoS"><code>AtoS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoY"><a class="docstring-binding" href="#JosephsonCircuits.AtoY"><code>JosephsonCircuits.AtoY</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AtoY(A)</code></pre><p>Convert the chain (ABCD) matrix <code>A</code> to the admittance matrix <code>Y</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Complex{Float64}[-1 -50.0;0 -1];JosephsonCircuits.AtoY(A)
2×2 Matrix{ComplexF64}:
 0.02+0.0im  0.02+0.0im
 0.02+0.0im  0.02+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.AtoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.AtoY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AtoY!(Y::AbstractMatrix,A::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.AtoY"><code>AtoY</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoZ"><a class="docstring-binding" href="#JosephsonCircuits.AtoZ"><code>JosephsonCircuits.AtoZ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AtoZ(A)</code></pre><p>Convert the ABCD matrix <code>A</code> to the impedance matrix <code>Z</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Complex{Float64}[1.0 0.0;1/50 1.0];JosephsonCircuits.AtoZ(A)
2×2 Matrix{ComplexF64}:
 50.0+0.0im  50.0+0.0im
 50.0+0.0im  50.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.AtoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.AtoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.AtoZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AtoZ!(Z::AbstractMatrix,A::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.AtoZ"><code>AtoZ</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoA"><a class="docstring-binding" href="#JosephsonCircuits.BtoA"><code>JosephsonCircuits.BtoA</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">BtoA(B)</code></pre><p>Convert the inverse chain matrix <code>B</code> to the chain (ABCD) matrix <code>A</code> and return the result. Note that despite the name, the inverse of the chain matrix is not equal to the inverse chain matrix, inv(A) ≠ B.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = Complex{Float64}[1.0 0.0;1/50 1.0];JosephsonCircuits.BtoA(B)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0+0.0im
 0.02-0.0im  1.0-0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.BtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.BtoA!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BtoA!(A::AbstractMatrix,B::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.BtoA"><code>BtoA</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoS"><a class="docstring-binding" href="#JosephsonCircuits.BtoS"><code>JosephsonCircuits.BtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">BtoS(B)</code></pre><p>Convert the inverse chain (ABCD) matrix <code>B</code> to the scattering parameter matrix <code>S</code> and return the result.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006 with change of overall sign (suspected typo).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.BtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>JosephsonCircuits.BtoS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BtoS!(S::AbstractMatrix, B::AbstractMatrix, tmp::AbstractMatrix,
    sqrtportimpedances1, sqrtportimpedances2)</code></pre><p>See <a href="#JosephsonCircuits.BtoS"><code>BtoS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoY"><a class="docstring-binding" href="#JosephsonCircuits.BtoY"><code>JosephsonCircuits.BtoY</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">BtoY(A)</code></pre><p>Convert the inverse chain matrix <code>B</code> to the admittance matrix <code>Y</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = Complex{Float64}[-1 -50.0;0 -1];JosephsonCircuits.BtoY(B)
2×2 Matrix{ComplexF64}:
 0.02+0.0im  0.02+0.0im
 0.02+0.0im  0.02+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.BtoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.BtoY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BtoY!(Y::AbstractMatrix,B::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.BtoY"><code>BtoY</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoZ"><a class="docstring-binding" href="#JosephsonCircuits.BtoZ"><code>JosephsonCircuits.BtoZ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">BtoZ(A)</code></pre><p>Convert the inverse chain matrix <code>B</code> to the impedance matrix <code>Z</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = Complex{Float64}[1.0 0.0;1/50 1];JosephsonCircuits.BtoZ(B)
2×2 Matrix{ComplexF64}:
 50.0+0.0im  50.0+0.0im
 50.0+0.0im  50.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006 with change of sign on B21 and B22 terms (suspected typo).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.BtoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.BtoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.BtoZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BtoZ!(Z::AbstractMatrix,B::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.BtoZ"><code>BtoZ</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.CMtokeyed-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.CMtokeyed-NTuple{4, Any}"><code>JosephsonCircuits.CMtokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CMtokeyed(CM, outputmodes, outputportnumbers, w)</code></pre><p>Convert a commutation relation array <code>CM</code> vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.CMtokeyed([1 2;3 4;;;],[(0,)],[1,2],[1.0,1.1])
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   freqindex ∈ 2-element UnitRange{Int64}
And data, 1×2×2 Array{Int64, 3}:
[:, :, 1] ~ (:, :, 1):
          (1)  (2)
   (0,)     1    3

[:, :, 2] ~ (:, :, 2):
          (1)  (2)
   (0,)     2    4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.IctoLj-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.IctoLj-Tuple{Any}"><code>JosephsonCircuits.IctoLj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IctoLj(Ic)</code></pre><p>Convert the junction critical current to inductance in SI base units.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; IctoLj(3.29105976e-6)
1.0e-10</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.LjtoIc-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.LjtoIc-Tuple{Any}"><code>JosephsonCircuits.LjtoIc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LjtoIc(Lj)</code></pre><p>Convert the junction inductance to critical current in SI base units.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LjtoIc(100e-12)
3.29105976e-6</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><code>JosephsonCircuits.S_directional_coupler!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler!(S::AbstractMatrix, α::Number, β::Number, 
    θ::Number, ϕ::Number)</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>The directional coupler is specified by the real coefficients α, β such that α²+β² = 1 and the real phases θ, ϕ which satisfy the condition θ + ϕ = π ± 2<em>n</em>π.</p><p>The scattering parameter matrix is unitary. Arbitrary phases can be applied to any of the ports (eg. by connecting a lossless transmission line).</p><p>The voltage coupling coefficient c is a real number where α = √(1-c^2) and β = c. The coupling in dB is defined as C = -20*log10(c).</p><ul><li><p>A symmetric directional coupler has θ = ϕ = π/2.</p></li><li><p>An anti-symmetric directional coupler has θ = 0 and ϕ = π.</p></li><li><p>A quadature hybrid has c = 1/√2 and θ = ϕ = π/2.</p></li><li><p>A magic-T hybrid or a rat-race hybrid has c = 1/√2 and θ = 0, ϕ = π.</p></li></ul><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler-NTuple{4, Any}"><code>JosephsonCircuits.S_directional_coupler</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler(α::Number, β::Number, θ::Number, ϕ::Number)</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>The directional coupler is specified by the real coefficients α, β such that α²+β² = 1 and the real phases θ, ϕ which satisfy the condition θ + ϕ = π ± 2<em>n</em>π.</p><p>The scattering parameter matrix is unitary. Arbitrary phases can be applied to any of the ports (eg. by connecting a lossless transmission line).</p><p>The voltage coupling coefficient c is a real number where α = √(1-c^2) and β = c. The coupling in dB is defined as C = -20*log10(c).</p><ul><li><p>A symmetric directional coupler has θ = ϕ = π/2.</p></li><li><p>An anti-symmetric directional coupler has θ = 0 and ϕ = π.</p></li><li><p>A symmetric hybrid coupler (a 90 degree or quadature hybrid) has c = 1/√2</p></li></ul><p>and θ = ϕ = π/2.</p><ul><li>An anti-symmetric hybrid coupler (a magic-T hybrid or a rat-race hybrid or</li></ul><p>a 180 degree hybrid) has c = 1/√2 and θ = 0, ϕ = π.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler_antisymmetric!-Tuple{Any, Number}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler_antisymmetric!-Tuple{Any, Number}"><code>JosephsonCircuits.S_directional_coupler_antisymmetric!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler_antisymmetric!(S, couplingdB::Number)</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal anti-symmetric directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = √(1-c^2) and β = c and c is the voltage coupling coefficient which is related to the coupling in dB as c = 10^(-couplingdB/20). The anti-symmetric directional coupler has θ = 0 and ϕ = π.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler_antisymmetric-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler_antisymmetric-Tuple{Number}"><code>JosephsonCircuits.S_directional_coupler_antisymmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler_antisymmetric(couplingdB::Number)</code></pre><p>Return the scattering parameter matrix for an ideal anti-symmetric directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = √(1-c^2) and β = c and c is the voltage coupling coefficient which is related to the coupling in dB as c = 10^(-couplingdB/20). The anti-symmetric directional coupler has θ = 0 and ϕ = π.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler_symmetric!-Tuple{Any, Number}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler_symmetric!-Tuple{Any, Number}"><code>JosephsonCircuits.S_directional_coupler_symmetric!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler_symmetric!(S, couplingdB::Number)</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal symmetric directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = √(1-c^2) and β = c and c is the voltage coupling coefficient which is related to the coupling in dB as c = 10^(-couplingdB/20). The symmetric directional coupler has θ = ϕ = π/2.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_directional_coupler_symmetric-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.S_directional_coupler_symmetric-Tuple{Number}"><code>JosephsonCircuits.S_directional_coupler_symmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_directional_coupler_symmetric(couplingdB::Number)</code></pre><p>Return the scattering parameter matrix for an ideal symmetric directional coupler with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = √(1-c^2) and β = c and c is the voltage coupling coefficient which is related to the coupling in dB as c = 10^(-couplingdB/20). The symmetric directional coupler has θ = ϕ = π/2.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_hybrid_coupler_antisymmetric!-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.S_hybrid_coupler_antisymmetric!-Tuple{Any}"><code>JosephsonCircuits.S_hybrid_coupler_antisymmetric!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_hybrid_coupler_antisymmetric!(S)</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal anti-symmetric hybrid (3 dB) coupler (a magic-T hybrid or a rat-race hybrid or a 180 degree hybrid) with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = β = 1/√2 and θ = 0 and ϕ = π for an anti-symmetric hybrid (3 dB) coupler.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_hybrid_coupler_antisymmetric-Tuple{}"><a class="docstring-binding" href="#JosephsonCircuits.S_hybrid_coupler_antisymmetric-Tuple{}"><code>JosephsonCircuits.S_hybrid_coupler_antisymmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_hybrid_coupler_antisymmetric()</code></pre><p>Return the scattering parameter matrix for an ideal anti-symmetric hybrid (3 dB) coupler (a magic-T hybrid or a rat-race hybrid or a 180 degree hybrid) with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = β = 1/√2 and θ = 0 and ϕ = π for an anti-symmetric hybrid (3 dB) coupler.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_hybrid_coupler_symmetric!-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.S_hybrid_coupler_symmetric!-Tuple{Any}"><code>JosephsonCircuits.S_hybrid_coupler_symmetric!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_hybrid_coupler_symmetric!()</code></pre><p>Overwrite <code>S</code> with the scattering parameter matrix for an ideal symmetric hybrid (3 dB) coupler (a 90 degree or quadature hybrid) with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = β = 1/√2 and θ = ϕ = π/2 for a symmetric hybrid (3 dB) coupler.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_hybrid_coupler_symmetric-Tuple{}"><a class="docstring-binding" href="#JosephsonCircuits.S_hybrid_coupler_symmetric-Tuple{}"><code>JosephsonCircuits.S_hybrid_coupler_symmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_hybrid_coupler_symmetric()</code></pre><p>Return the scattering parameter matrix for an ideal symmetric hybrid (3 dB) coupler (a 90 degree or quadature hybrid) with the convention that if a wave is input at port 1, then port 2 is the through, port 3 is the coupled port, and port 4 is the isolated port:</p><pre><code class="language-julia hljs">                           _______
port 1 (input)    --&gt;  ====|     |==== --&gt; port 2 (through)
                           |     |
port 4 (isolated) &lt;--  ====|     |==== --&gt; port 3 (coupled)
                           -------

[0            α            exp(im\*θ)β 0;
 α            0            0            exp(im\*ϕ)β;
 exp(im\*θ)β 0            0            α;
 0            exp(im\*ϕ)β α            0]</code></pre><p>where α = β = 1/√2 and θ = ϕ = π/2 for a symmetric hybrid (3 dB) coupler.</p><p><strong>References</strong></p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_match!-Tuple{AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.S_match!-Tuple{AbstractArray}"><code>JosephsonCircuits.S_match!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_match!(S::AbstractArray)</code></pre><p>Return the scattering parameters for a N port ideal match. Overwrite<code>S</code> with the output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.S_match!(ones(1,1))
1×1 Matrix{Float64}:
 0.0

julia&gt; JosephsonCircuits.S_match!(ones(1,1,2))
1×1×2 Array{Float64, 3}:
[:, :, 1] =
 0.0

[:, :, 2] =
 0.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_open!-Tuple{AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.S_open!-Tuple{AbstractArray}"><code>JosephsonCircuits.S_open!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_open!(S::AbstractArray)</code></pre><p>Return the scattering parameters for a N port ideal open. Overwrite<code>S</code> with the output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.S_open!(ones(1,1))
1×1 Matrix{Float64}:
 1.0

julia&gt; JosephsonCircuits.S_open!(ones(2,2))
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_short!-Tuple{AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.S_short!-Tuple{AbstractArray}"><code>JosephsonCircuits.S_short!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_short!(S::AbstractArray)</code></pre><p>Return the scattering parameters for a N port ideal short. Overwrite<code>S</code> with the output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.S_short!(ones(1,1))
1×1 Matrix{Float64}:
 -1.0

julia&gt; JosephsonCircuits.S_short!(ones(2,2))
2×2 Matrix{Float64}:
 -1.0   0.0
  0.0  -1.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.S_splitter!-Tuple{AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.S_splitter!-Tuple{AbstractArray}"><code>JosephsonCircuits.S_splitter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_splitter!(S::AbstractArray)</code></pre><p>Return the scattering parameters for a N port ideal lossless symmetrical reciprocal network. Overwrite <code>S</code> with the output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.S_splitter!(ones(2,2))
2×2 Matrix{Float64}:
 0.0  1.0
 1.0  0.0

julia&gt; JosephsonCircuits.S_splitter!(ones(3,3))
3×3 Matrix{Float64}:
 -0.333333   0.666667   0.666667
  0.666667  -0.333333   0.666667
  0.666667   0.666667  -0.333333</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Snoisetokeyed-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Snoisetokeyed-NTuple{6, Any}"><code>JosephsonCircuits.Snoisetokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Snoisetokeyed(Snoise, inputmodes, components, outputmodes,
    outputportnumbers, w)</code></pre><p>Convert a noise scattering parameter array <code>Snoise</code> vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Snoisetokeyed([11 12;21 22;;;],[(0,)],[&quot;C1&quot;,&quot;C2&quot;],[(0,)],[1,2],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   inputmode ∈ 1-element Vector{Tuple{Int64}}
→   component ∈ 2-element Vector{String}
◪   outputmode ∈ 1-element Vector{Tuple{Int64}}
▨   outputport ∈ 2-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 1×2×1×2×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (&quot;C1&quot;)  (&quot;C2&quot;)
   (0,)   11      21

[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):
          (&quot;C1&quot;)  (&quot;C2&quot;)
   (0,)   12      22</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoA"><a class="docstring-binding" href="#JosephsonCircuits.StoA"><code>JosephsonCircuits.StoA</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoA(S)</code></pre><p>Convert the scattering parameter matrix <code>S</code> to the chain (ABCD) matrix <code>A</code> and return the result.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.StoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>JosephsonCircuits.StoA!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StoA!(A::AbstractMatrix, S::AbstractMatrix, tmp::AbstractMatrix,
    sqrtportimpedances1, sqrtportimpedances2)</code></pre><p>See <a href="#JosephsonCircuits.StoA"><code>StoA</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoABCD"><a class="docstring-binding" href="#JosephsonCircuits.StoABCD"><code>JosephsonCircuits.StoABCD</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoABCD(S;portimpedances=50.0))</code></pre><p>Convert the scattering parameter matrix <code>S</code> to the 2 port chain (ABCD) matrix and return the result. Assumes a port impedance of 50 Ohms unless specified with the <code>portimpedances</code> keyword argument.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoB"><a class="docstring-binding" href="#JosephsonCircuits.StoB"><code>JosephsonCircuits.StoB</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoB(S)</code></pre><p>Convert the scattering parameter matrix <code>S</code> to the inverse chain (ABCD) matrix <code>B</code> and return the result. Note that despite the name, the inverse of the chain matrix is not equal to the inverse chain matrix, inv(A) ≠ B.</p><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.StoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>JosephsonCircuits.StoB!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StoB!(B::AbstractMatrix, S::AbstractMatrix, tmp::AbstractMatrix,
    sqrtportimpedances1, sqrtportimpedances2)</code></pre><p>See <a href="#JosephsonCircuits.StoB"><code>StoB</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoT"><a class="docstring-binding" href="#JosephsonCircuits.StoT"><code>JosephsonCircuits.StoT</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoT(S)</code></pre><p>Convert the scattering parameter matrix <code>S</code> to a transmission matrix <code>T</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = Complex{Float64}[0.0 1.0;1.0 0.0];JosephsonCircuits.StoT(S)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  -0.0+0.0im
 -0.0-0.0im   1.0-0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoT!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.StoT!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.StoT!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StoT!(T::AbstractMatrix,S::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.StoT"><code>StoT</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoY"><a class="docstring-binding" href="#JosephsonCircuits.StoY"><code>JosephsonCircuits.StoY</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoY(S;portimpedances=50.0)</code></pre><p>Convert the scattering parameter matrix <code>S</code> to an admittance parameter matrix <code>Y</code> and return the result. Assumes a port impedance of 50 Ohms unless specified with the <code>portimpedances</code> keyword argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = Complex{Float64}[0.0 0.999;0.999 0.0];JosephsonCircuits.StoY(S)
2×2 Matrix{ComplexF64}:
  19.99+0.0im  -19.99+0.0im
 -19.99+0.0im   19.99+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><a class="docstring-binding" href="#JosephsonCircuits.StoY!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><code>JosephsonCircuits.StoY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StoY!(Y::AbstractMatrix,S::AbstractMatrix,tmp::AbstractMatrix,sqrtportadmittances)</code></pre><p>See <a href="#JosephsonCircuits.StoY"><code>StoY</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoZ"><a class="docstring-binding" href="#JosephsonCircuits.StoZ"><code>JosephsonCircuits.StoZ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StoZ(S;portimpedances=50.0)</code></pre><p>Convert the scattering parameter matrix <code>S</code> to an impedance parameter matrix <code>Z</code> and return the result. Assumes a port impedance of 50 Ohms unless specified with the <code>portimpedances</code> keyword argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = Complex{Float64}[0.0 0.0;0.0 0.0];JosephsonCircuits.StoZ(S)
2×2 Matrix{ComplexF64}:
 50.0+0.0im   0.0+0.0im
  0.0+0.0im  50.0+0.0im

julia&gt; S = Complex{Float64}[0.0 0.999;0.999 0.0];JosephsonCircuits.StoZ(S)
2×2 Matrix{ComplexF64}:
 49975.0+0.0im  49975.0+0.0im
 49975.0+0.0im  49975.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.StoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><a class="docstring-binding" href="#JosephsonCircuits.StoZ!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><code>JosephsonCircuits.StoZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StoZ!(Z::AbstractMatrix,S::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)</code></pre><p>See <a href="#JosephsonCircuits.StoZ"><code>StoZ</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Stokeyed-NTuple{5, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Stokeyed-NTuple{5, Any}"><code>JosephsonCircuits.Stokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Stokeyed(S, outputmodes, outputportnumbers, inputmodes, inputportnumbers)</code></pre><p>Convert a scattering parameter array <code>S</code> to a keyed array. Returned the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Stokeyed([11 12;21 22],[(0,)],[1,2],[(0,)],[1,2])
4-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   inputmode ∈ 1-element Vector{Tuple{Int64}}
▨   inputport ∈ 2-element Vector{Int64}
And data, 1×2×1×2 Array{Int64, 4}:
[:, :, 1, 1] ~ (:, :, (0,), 1):
          (1)  (2)
   (0,)    11   21

[:, :, 1, 2] ~ (:, :, (0,), 2):
          (1)  (2)
   (0,)    12   22</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Stokeyed-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Stokeyed-NTuple{6, Any}"><code>JosephsonCircuits.Stokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Stokeyed(S, outputmodes, outputportnumbers, inputmodes,
    inputportnumbers, w)</code></pre><p>Convert a scattering parameter array <code>S</code> vs frequency <code>w</code> to a keyed array. Returned the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Stokeyed([11 12;21 22;;;],[(0,)],[1,2],[(0,)],[1,2],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 1-element Vector{Tuple{Int64}}
→   outputport ∈ 2-element Vector{Int64}
◪   inputmode ∈ 1-element Vector{Tuple{Int64}}
▨   inputport ∈ 2-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 1×2×1×2×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (1)  (2)
   (0,)    11   21

[:, :, 1, 2, 1] ~ (:, :, (0,), 2, 1):
          (1)  (2)
   (0,)    12   22</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.TtoS"><a class="docstring-binding" href="#JosephsonCircuits.TtoS"><code>JosephsonCircuits.TtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">TtoS(T)</code></pre><p>Convert the transmission matrix <code>T</code> to a scattering parameter matrix <code>S</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; T = Complex{Float64}[1.0 0.0;0.0 1.0];JosephsonCircuits.TtoS(T)
2×2 Matrix{ComplexF64}:
 -0.0-0.0im   1.0+0.0im
  1.0-0.0im  -0.0-0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006 with change of sign on T11 and T21 terms (suspected typo).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.TtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.TtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.TtoS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TtoS!(S::AbstractMatrix,T::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.TtoS"><code>TtoS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_C-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Y_C-Tuple{Any, Any}"><code>JosephsonCircuits.Y_C</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Y_C(Cmaxwell,w)</p><p>The admittance matrix <code>Y</code> for a network of capacitors is the Maxwell capacitance matrix <code>Cmaxwell</code> times im*w.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_PiY!-Tuple{AbstractMatrix, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Y_PiY!-Tuple{AbstractMatrix, Number, Number, Number}"><code>JosephsonCircuits.Y_PiY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Y_PiY!(Y,Y1,Y2,Y3)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Y_PiY-Tuple{Number, Number, Number}"><code>Y_PiY</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Y_PiY!(zeros(Complex{Float64},2,2),1.0,2.0,4.0)
2×2 Matrix{ComplexF64}:
  5.0+0.0im  -4.0+0.0im
 -4.0+0.0im   6.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_PiY-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Y_PiY-Tuple{Number, Number, Number}"><code>JosephsonCircuits.Y_PiY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Y_PiY(Y1,Y2,Y3)</code></pre><p>Return the admittance matrix for a Pi network of admittances <code>Y1</code>, <code>Y2</code>, and <code>Y3</code>.</p><pre><code class="language-julia hljs">o----Y3-----o
   |     |   
   Y1    Y2  
   |     |   
o-----------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Y_PiY(1.0+0.0im,2.0+0.0im,4.0+0.0im)
2×2 Matrix{ComplexF64}:
  5.0+0.0im  -4.0-0.0im
 -4.0-0.0im   6.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_invL-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Y_invL-Tuple{Any, Any}"><code>JosephsonCircuits.Y_invL</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Y_invL(L,w)</p><p>The admittance matrix <code>Y</code> for a network of inductors and mutual inductors is the inverse of the inductance matrix <code>L</code> divided by im*w.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_seriesY!-Tuple{AbstractMatrix, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Y_seriesY!-Tuple{AbstractMatrix, Number}"><code>JosephsonCircuits.Y_seriesY!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Y_seriesY!(Y,Y1)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Y_seriesY-Tuple{Number}"><code>Y_seriesY</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Y_seriesY!(zeros(Complex{Float64},2,2),1/50)
2×2 Matrix{ComplexF64}:
  0.02+0.0im  -0.02+0.0im
 -0.02+0.0im   0.02+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Y_seriesY-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.Y_seriesY-Tuple{Number}"><code>JosephsonCircuits.Y_seriesY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Y_seriesY(Y1)</code></pre><p>Return the Y matrix for a series admittance <code>Y1</code>.</p><pre><code class="language-julia hljs">o---Y1---o
          
          
o--------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Y_seriesY(1/(50.0+0.0im))
2×2 Matrix{ComplexF64}:
  0.02-0.0im  -0.02+0.0im
 -0.02+0.0im   0.02-0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoA"><a class="docstring-binding" href="#JosephsonCircuits.YtoA"><code>JosephsonCircuits.YtoA</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">YtoA(Y)</code></pre><p>Convert the admittance matrix <code>Y</code> to the chain (ABCD) matrix <code>A</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = Complex{Float64}[1/50 1/50;1/50 1/50];JosephsonCircuits.YtoA(Y)
2×2 Matrix{ComplexF64}:
 -1.0+0.0im  -50.0+0.0im
  0.0+0.0im   -1.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006 with change of overall sign on (suspected typo).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.YtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.YtoA!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">YtoA!(A::AbstractMatrix,Y::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.YtoA"><code>YtoA</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoB"><a class="docstring-binding" href="#JosephsonCircuits.YtoB"><code>JosephsonCircuits.YtoB</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">YtoB(Y)</code></pre><p>Convert the admittance matrix <code>Y</code> to the inverse chain matrix <code>B</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = Complex{Float64}[1/50 1/50;1/50 1/50];JosephsonCircuits.YtoB(Y)
2×2 Matrix{ComplexF64}:
 -1.0+0.0im  -50.0+0.0im
  0.0+0.0im   -1.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.YtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.YtoB!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">YtoB!(B::AbstractMatrix,Y::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.YtoB"><code>YtoB</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoS"><a class="docstring-binding" href="#JosephsonCircuits.YtoS"><code>JosephsonCircuits.YtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">YtoS(Y;portimpedances=50.0)</code></pre><p>Convert the admittance parameter matrix <code>Y</code> to a scattering parameter matrix <code>S</code> and return the result. <code>portimpedances</code> is a scalar, vector, or matrix of port impedances.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = Complex{Float64}[1/50.0 0.0;0.0 1/50.0];JosephsonCircuits.YtoS(Y)
2×2 Matrix{ComplexF64}:
  0.0-0.0im  -0.0-0.0im
 -0.0-0.0im   0.0-0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.YtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><a class="docstring-binding" href="#JosephsonCircuits.YtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><code>JosephsonCircuits.YtoS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">YtoS!(S::AbstractMatrix,Y::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)</code></pre><p>See <a href="#JosephsonCircuits.YtoS"><code>YtoS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZC_basis_coupled_tlines-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.ZC_basis_coupled_tlines-Tuple{Any, Any}"><code>JosephsonCircuits.ZC_basis_coupled_tlines</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZC_basis_coupled_tlines(L, Cmaxwell)

Returns the characteristic impedance matrix `ZC` and eigenbasis for
current `TI` and voltage `TV` from the inductance per unit length matrix
`L` and Maxwell capacitance per unit length matrix `Cmaxwell`.</code></pre><p><strong>Arguments</strong></p><ul><li><code>L</code>: inductance per unit length matrix.</li><li><code>C</code>: Maxwell capacitance per unit length matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>ZC</code>: characteristic impedance matrix.</li><li><code>TI</code>: matrix which transforms mode currents to currents, I = TI<em>Im. Computed       from TI = U</em>theta*S.</li><li><code>TV</code>: matrix which transforms mode voltages to voltages, V = TV<em>Vm. Computed       from TV = U</em>inv(theta)*S.</li><li><code>theta</code>: Diagonal matrix with the square of the eigenvalues of Cmaxwell       along the diagonals.</li><li><code>U</code>: eigenvectors of Cmaxwell.</li><li><code>lambda</code>: Diagonal matrix with the square of the eigenvalues of       theta<em>Ut</em>L<em>U</em>theta along the diagonals. <code>lambda</code> is related       to the propagation constant, gamma, as gamma^2 = -omega^2*lambda^2.</li><li><code>S</code>: eigenvectors of theta<em>Ut</em>L<em>U</em>theta.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Zeven = 51.0
Zodd = 49.0
neven = 1.1
nodd = 1.08
c = JosephsonCircuits.speed_of_light

L, C = JosephsonCircuits.even_odd_to_maxwell(Zeven, Zodd, neven, nodd)
b = JosephsonCircuits.ZC_basis_coupled_tlines(L,C)
@show b.ZC
@show b.TI
@show b.TV
@show Matrix(b.theta)
@show b.U
@show Matrix(b.lambda)
@show b.S
println(isapprox(Zeven,b.ZC[1,1]+b.ZC[1,2]))
println(isapprox(Zodd,b.ZC[1,1]-b.ZC[1,2]))
println(isapprox(neven,b.lambda[2,2]*c))
println(isapprox(nodd,b.lambda[1,1]*c))

# output
b.ZC = [49.999999999999986 0.9999999999999929; 0.9999999999999929 49.999999999999986]
b.TI = [-6.063012846509498e-6 -5.997716107132906e-6; 6.063012846509498e-6 -5.997716107132906e-6]
b.TV = [-82467.25063230767 -83365.06614665617; 82467.25063230767 -83365.06614665617]
Matrix(b.theta) = [8.48205146197092e-6 0.0; 0.0 8.574394996376037e-6]
b.U = [-0.7071067811865475 -0.7071067811865475; -0.7071067811865475 0.7071067811865475]
Matrix(b.lambda) = [3.6024922281400425e-9 0.0; 0.0 3.669205047179673e-9]
b.S = [0.0 1.0; 1.0 0.0]
true
true
true
true</code></pre><p><strong>References</strong></p><p>Paul, Clayton R. Analysis of Multiconductor Transmission Lines, Second Edition. Wiley, 2008.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_L-Tuple{AbstractMatrix, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_L-Tuple{AbstractMatrix, Number}"><code>JosephsonCircuits.Z_L</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Z_L(L,w)</p><p>The impedance matrix <code>Z</code> for a network of inductors and mutual inductors is the inductance matrix <code>Z_L</code> times im*w.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_TZ!-Tuple{AbstractMatrix, Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_TZ!-Tuple{AbstractMatrix, Number, Number, Number}"><code>JosephsonCircuits.Z_TZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_TZ!(Z,Z1,Z2,Z3)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Z_TZ-Tuple{Number, Number, Number}"><code>Z_TZ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_TZ!(ones(Complex{Float64},2,2),1,2,4)
2×2 Matrix{ComplexF64}:
 5.0+0.0im  4.0+0.0im
 4.0+0.0im  6.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_TZ-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_TZ-Tuple{Number, Number, Number}"><code>JosephsonCircuits.Z_TZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_TZ(Z1,Z2,Z3)</code></pre><p>Return the ABCD matrix for a T network of impedances <code>Z1</code>, <code>Z2</code>, and <code>Z3</code>.</p><pre><code class="language-julia hljs">o--Z1-----Z2--o
       |       
      Z3       
       |       
o-------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_TZ(1.0+0.0im,2.0+0.0im,4.0+0.0im)
2×2 Matrix{ComplexF64}:
 5.0+0.0im  4.0+0.0im
 4.0+0.0im  6.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_canonical_coupled_line_circuits-Tuple{Int64, Vararg{Any, 4}}"><a class="docstring-binding" href="#JosephsonCircuits.Z_canonical_coupled_line_circuits-Tuple{Int64, Vararg{Any, 4}}"><code>JosephsonCircuits.Z_canonical_coupled_line_circuits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_canonical_coupled_line_circuit(i::Int,  Z0e, Z0o, thetae, thetao)</code></pre><p>Return the impedance matrix for the <code>i</code>&#39;th canonical coupled line circuit, as a function of the even mode phase delay <code>thetae</code> in radians, the odd mode phase delay <code>thetao</code> in radians, the even mode characteristic impedance <code>Z0e</code> in Ohms, and the odd mode characteristic impedance <code>Z0o</code> in Ohms.</p><ol><li>low pass</li></ol><pre><code class="language-julia hljs">   gnd--==========
1--&gt; o--==========--o &lt;--2</code></pre><ol><li>band pass</li></ol><pre><code class="language-julia hljs">   gnd--==========--o &lt;--2
1--&gt; o--==========--gnd</code></pre><ol><li>band pass</li></ol><pre><code class="language-julia hljs">        ==========--o &lt;--2
1--&gt; o--==========</code></pre><ol><li>band pass</li></ol><pre><code class="language-julia hljs">1--&gt; o--==========--gnd
2--&gt; o--==========</code></pre><ol><li>all pass</li></ol><pre><code class="language-julia hljs">        ==========
1--&gt; o--==========--o  &lt;--2</code></pre><ol><li>all pass</li></ol><pre><code class="language-julia hljs">   gnd--==========--gnd
1--&gt; o--==========--o  &lt;--2</code></pre><ol><li>all pass</li></ol><pre><code class="language-julia hljs">1--&gt; o--==========--|
2--&gt; o--==========--|</code></pre><ol><li>all stop</li></ol><pre><code class="language-julia hljs">   gnd--==========--o  &lt;--2
1--&gt; o--==========</code></pre><ol><li>all stop</li></ol><pre><code class="language-julia hljs">1--&gt; o--==========--gnd
2--&gt; o--==========--gnd</code></pre><ol><li>all stop</li></ol><pre><code class="language-julia hljs">1--&gt; o--==========
2--&gt; o--==========</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θe, θo, Ze, Zo;JosephsonCircuits.Z_canonical_coupled_line_circuits(3,Ze,Zo,θe,θo)
2×2 Matrix{Complex{Num}}:
 -0.5(Ze*cot(θe) + Zo*cot(θo))*im  -0.5(Ze*csc(θe) - Zo*csc(θo))*im
 -0.5(Ze*csc(θe) - Zo*csc(θo))*im  -0.5(Ze*cot(θe) + Zo*cot(θo))*im</code></pre><p><strong>References</strong></p><p>E. M. T. Jones, &quot;Coupled-Strip-Transmission-Line Filters and Directional Couplers,&quot; in IRE Transactions on Microwave Theory and Techniques, vol. 4, no. 2, pp. 75-81, April 1956, doi: 10.1109/TMTT.1956.1125022.</p><p>Pozar, D. M. Microwave Engineering (4 ed.). John Wiley &amp; Sons (2011) ISBN 9780470631553.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_coupled_tline!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><a class="docstring-binding" href="#JosephsonCircuits.Z_coupled_tline!-Tuple{AbstractMatrix, Vararg{Number, 4}}"><code>JosephsonCircuits.Z_coupled_tline!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_coupled_tline!(Z, Z0e, Z0o, thetae, thetao)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Z_coupled_tline-NTuple{4, Number}"><code>Z_coupled_tline</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_coupled_tline!(zeros(Complex{Float64},4,4),50,50,pi/4,pi/4)
4×4 Matrix{ComplexF64}:
 0.0-50.0im     0.0-0.0im      0.0-70.7107im  0.0-0.0im
 0.0-0.0im      0.0-50.0im     0.0-0.0im      0.0-70.7107im
 0.0-70.7107im  0.0-0.0im      0.0-50.0im     0.0-0.0im
 0.0-0.0im      0.0-70.7107im  0.0-0.0im      0.0-50.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_coupled_tline-NTuple{4, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_coupled_tline-NTuple{4, Number}"><code>JosephsonCircuits.Z_coupled_tline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_coupled_tline(Z0e, Z0o, thetae, thetao)</code></pre><p>Return the impedance matrix for two coupled transmission lines described even and odd mode impedances <code>Z0e</code> and <code>Z0o</code> and by even and odd mode phase delays <code>thetae</code> and <code>thetao</code>.</p><pre><code class="language-julia hljs">thetae, Z0e
thetao, Z0o

V1, I1 --&gt;  ======== &lt;-- I3, V3
V2, I2 --&gt;  ======== &lt;-- I4, V4

[(V1+V2)/2, (I1+I2)/2] = ABCDe * [(V3+V4)/2, -(I3+I4)/2]
[(V1-V2)/2, (I1-I2)/2] = ABCDo * [(V3-V4)/2, -(I3-I4)/2]

[V1, V2, V3, V4] = Z_coupled_tline * [I1, I2, I3, I4]</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_coupled_tline(50,50,pi/4,pi/4)
4×4 Matrix{ComplexF64}:
 0.0-50.0im     0.0-0.0im      0.0-70.7107im  0.0-0.0im
 0.0-0.0im      0.0-50.0im     0.0-0.0im      0.0-70.7107im
 0.0-70.7107im  0.0-0.0im      0.0-50.0im     0.0-0.0im
 0.0-0.0im      0.0-70.7107im  0.0-0.0im      0.0-50.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_invC-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.Z_invC-Tuple{Any, Any}"><code>JosephsonCircuits.Z_invC</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Z_invC(invCmaxwell,w)</p><p>The impedance matrix <code>Z</code> for a network of capacitors is the inverse of the Maxwell capacitance matrix <code>invCmaxwell</code> divided by im*w.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_shuntZ!-Tuple{AbstractMatrix, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_shuntZ!-Tuple{AbstractMatrix, Number}"><code>JosephsonCircuits.Z_shuntZ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_shuntZ!(Z,Z1)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Z_shuntZ-Tuple{Number}"><code>Z_shuntZ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_shuntZ!(zeros(Complex{Float64},2,2),50)
2×2 Matrix{ComplexF64}:
 50.0+0.0im  50.0+0.0im
 50.0+0.0im  50.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_shuntZ-Tuple{Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_shuntZ-Tuple{Number}"><code>JosephsonCircuits.Z_shuntZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_shuntZ(Z1)</code></pre><p>Return the Z matrix for a shunt impedance <code>Z1</code>.</p><pre><code class="language-julia hljs">o---------o
     |
     Z1
     |
o---------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_shuntZ(50.0+0.0im)
2×2 Matrix{ComplexF64}:
 50.0+0.0im  50.0+0.0im
 50.0+0.0im  50.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_tline!-Tuple{AbstractMatrix, Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_tline!-Tuple{AbstractMatrix, Number, Number}"><code>JosephsonCircuits.Z_tline!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_tline!(Z, Z0, theta)</code></pre><p>In-place version of <a href="#JosephsonCircuits.Z_tline-Tuple{Number, Number}"><code>Z_tline</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_tline!(ones(Complex{Float64},2,2),50, pi/4)
2×2 Matrix{ComplexF64}:
 0.0-50.0im     0.0-70.7107im
 0.0-70.7107im  0.0-50.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.Z_tline-Tuple{Number, Number}"><a class="docstring-binding" href="#JosephsonCircuits.Z_tline-Tuple{Number, Number}"><code>JosephsonCircuits.Z_tline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z_tline(Z0, theta)</code></pre><p>Return the impedance matrix for a transmission line described by a characteristic impedance <code>Z0</code> in Ohms and phase delay <code>theta</code> in radians </p><pre><code class="language-julia hljs">   theta, Z0  
o--========--o
              
              
o------------o</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.Z_tline(50, pi/4)
2×2 Matrix{ComplexF64}:
 0.0-50.0im     0.0-70.7107im
 0.0-70.7107im  0.0-50.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoA"><a class="docstring-binding" href="#JosephsonCircuits.ZtoA"><code>JosephsonCircuits.ZtoA</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ZtoA(Z)</code></pre><p>Convert the impedance matrix <code>Z</code> to the ABCD matrix <code>A</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z = Complex{Float64}[50.0 50.0;50.0 50.0];JosephsonCircuits.ZtoA(Z)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0-0.0im
 0.02+0.0im  1.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.ZtoA!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.ZtoA!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZtoA!(A::AbstractMatrix,Z::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.ZtoA"><code>ZtoA</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoB"><a class="docstring-binding" href="#JosephsonCircuits.ZtoB"><code>JosephsonCircuits.ZtoB</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ZtoB(Z)</code></pre><p>Convert the impedance matrix <code>Z</code> to the inverse chain matrix <code>B</code> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z = Complex{Float64}[50.0 50;50 50];JosephsonCircuits.ZtoB(Z)
2×2 Matrix{ComplexF64}:
  1.0+0.0im  0.0-0.0im
 0.02+0.0im  1.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.ZtoB!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.ZtoB!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZtoB!(B::AbstractMatrix,Z::AbstractMatrix,tmp::AbstractMatrix)</code></pre><p>See <a href="#JosephsonCircuits.ZtoB"><code>ZtoB</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoS"><a class="docstring-binding" href="#JosephsonCircuits.ZtoS"><code>JosephsonCircuits.ZtoS</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ZtoS(Z;portimpedances=50.0)</code></pre><p>Convert the impedance parameter matrix <code>Z</code> to a scattering parameter matrix <code>S</code> and return the result. <code>portimpedances</code> is a scalar, vector, or matrix of port impedances. Assumes a port impedance of 50 Ohms unless specified with the <code>portimpedances</code> keyword argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z = Complex{Float64}[0.0 0.0;0.0 0.0];JosephsonCircuits.ZtoS(Z)
2×2 Matrix{ComplexF64}:
 -1.0+0.0im   0.0-0.0im
  0.0-0.0im  -1.0+0.0im</code></pre><p><strong>References</strong></p><p>Russer, Peter. Electromagnetics, Microwave Circuit, And Antenna Design for Communications Engineering, Second Edition. Artech House, 2006.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ZtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><a class="docstring-binding" href="#JosephsonCircuits.ZtoS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Any}"><code>JosephsonCircuits.ZtoS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZtoS!(S::AbstractMatrix,Z::AbstractMatrix,tmp::AbstractMatrix,sqrtportimpedances)</code></pre><p>See <a href="#JosephsonCircuits.ZtoS"><code>ZtoS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.add_modes-Union{Tuple{T}, Tuple{AbstractArray{Array{Tuple{T, Int64}, 1}, 1}, Integer}} where T"><a class="docstring-binding" href="#JosephsonCircuits.add_modes-Union{Tuple{T}, Tuple{AbstractArray{Array{Tuple{T, Int64}, 1}, 1}, Integer}} where T"><code>JosephsonCircuits.add_modes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_modes(connections::AbstractVector{Vector{Tuple{T,Int}}},
    Nmodes::Integer) where {T}</code></pre><p>Assume the scattering parameter matrices are multi-mode and <code>connections</code> specifies the connections between physical ports. Return the connections vector with the existing connections re-numbered and with added connections between every mode associated with each physical port.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connections = [[(&quot;S1&quot;,3),(&quot;S2&quot;,4)],[(&quot;S1&quot;,2),(&quot;S2&quot;,1)]];JosephsonCircuits.add_modes(connections,2)
4-element Vector{Vector{Tuple{String, Int64}}}:
 [(&quot;S1&quot;, 5), (&quot;S2&quot;, 7)]
 [(&quot;S1&quot;, 6), (&quot;S2&quot;, 8)]
 [(&quot;S1&quot;, 3), (&quot;S2&quot;, 1)]
 [(&quot;S1&quot;, 4), (&quot;S2&quot;, 2)]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.add_modes-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, T, Int64, Int64}, 1}, Integer}} where T"><a class="docstring-binding" href="#JosephsonCircuits.add_modes-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, T, Int64, Int64}, 1}, Integer}} where T"><code>JosephsonCircuits.add_modes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_modes(connections::AbstractVector{Tuple{T,T,Int,Int}},
    Nmodes::Integer) where {T}</code></pre><p>Assume the scattering parameter matrices are multi-mode and <code>connections</code> specifies the connections between physical ports. Return the connections vector with the existing connections re-numbered and with added connections between every mode associated with each physical port.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connections = [(&quot;S1&quot;,&quot;S2&quot;,3,4),(&quot;S1&quot;,&quot;S2&quot;,2,1)];JosephsonCircuits.add_modes(connections,2)
4-element Vector{Tuple{String, String, Int64, Int64}}:
 (&quot;S1&quot;, &quot;S2&quot;, 5, 7)
 (&quot;S1&quot;, &quot;S2&quot;, 6, 8)
 (&quot;S1&quot;, &quot;S2&quot;, 3, 1)
 (&quot;S1&quot;, &quot;S2&quot;, 4, 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.add_splitters-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Array{Tuple{T, Int64}, 1}, 1}}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.add_splitters-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Array{Tuple{T, Int64}, 1}, 1}}} where {T, N}"><code>JosephsonCircuits.add_splitters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_splitters(networks::AbstractVector{Tuple{T,N}},
    connections::AbstractVector{&lt;:AbstractVector{Tuple{T,Int}}};
    splitter_name_length = 20) where {T,N}</code></pre><p>Return the <code>networks</code> and <code>connections</code> with splitters (ideal lossless symmetrical reciprocal networks) and connections to the splitters added when more than two ports intersect. <code>connections</code> is also converted from a vector of vectors of tuples where the tuple contains the network and the port such as [[(:S1,1),(:S2,1)]] to a vector of tuples where the tuple contains the two networks and ports being connected [(S1,:S2,1,1)].</p><p><strong>References</strong></p><p>S. F. Cao, Y. C. Jiao, and Z. Zhang. &quot;Applications of Generalized Cascade Scattering Matrix on the Microwave Circuits and Antenna Arrays&quot;. International Journal of Antennas and Propagation Vol. 2015, 759439, doi:10.1155/2015/759439.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.add_splitters-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.add_splitters-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><code>JosephsonCircuits.add_splitters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_splitters(networks, connections::AbstractVector{Tuple{T,T,Int,Int}};
    kwargs...)) where T</code></pre><p>If the connections are already in the correct format, just return them. This function assumes ports have already been added to <code>networks</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.addsources!-NTuple{11, Any}"><a class="docstring-binding" href="#JosephsonCircuits.addsources!-NTuple{11, Any}"><code>JosephsonCircuits.addsources!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">addsources!(bbm, modes, sources, portindices, portnumbers,
    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)</code></pre><p>Calculate the source terms in the branch basis. Overwrite bbm with the output. See also <a href="#JosephsonCircuits.calcsources-NTuple{10, Any}"><code>calcsources</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><a class="docstring-binding" href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>JosephsonCircuits.applynl!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">applynl!(fd::Array{Complex{T}}, td::Array{T}, f::Function, irfftplan,
    rfftplan)</code></pre><p>Apply the nonlinear function f to the frequency domain data by transforming to the time domain, applying the function, then transforming back to the frequency domain, overwriting the contents of fd and td in the process. We use plans for the forward and reverse RFFT prepared by <a href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>plan_applynl</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">fd=ones(Complex{Float64},3,2)
td, irfftplan, rfftplan = JosephsonCircuits.plan_applynl(fd)
JosephsonCircuits.applynl!(fd, td, cos, irfftplan, rfftplan)
fd

# output
3×2 Matrix{ComplexF64}:
  0.586589+0.0im   0.586589+0.0im
 -0.413411+0.0im  -0.413411+0.0im
 -0.413411+0.0im  -0.413411+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.applynl-Tuple{Array{ComplexF64}, Any}"><a class="docstring-binding" href="#JosephsonCircuits.applynl-Tuple{Array{ComplexF64}, Any}"><code>JosephsonCircuits.applynl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">applynl(am::Array{Complex{Float64}}, f::Function)</code></pre><p>Perform the inverse discrete Fourier transform on an array <code>am</code> of complex frequency domain data, apply the function <code>f</code> in the time domain, then perform the discrete Fourier transform to return to the frequency domain. Apply the Fourier transform on all but the last dimensions. See also <a href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>applynl!</code></a> and <a href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>plan_applynl</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.applynl([[0, 0.2+0.0im, 0, 0];;],cos)
4×1 Matrix{ComplexF64}:
   0.9603980498951228 + 0.0im
                  0.0 + 0.0im
 -0.01966852794611884 + 0.0im
                  0.0 + 0.0im

julia&gt; JosephsonCircuits.applynl([[0, 0.2+0.0im];;],cos)
2×1 Matrix{ComplexF64}:
   0.9603980498951228 + 0.0im
 -0.01966852794611884 + 0.0im

julia&gt; JosephsonCircuits.applynl([0.0 + 0.0im 0.45 + 0.0im 0.45 + 0.0im; 0.55 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;],sin)
3×3×1 Array{ComplexF64, 3}:
[:, :, 1] =
 -0.0209812+0.0im   0.295151+0.0im   0.295151+0.0im
   0.359826+0.0im  -0.041417+0.0im  -0.041417+0.0im
 0.00788681+0.0im  -0.110947+0.0im  -0.110947+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.axis_to_modes-Tuple{AbstractArray, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.axis_to_modes-Tuple{AbstractArray, Integer}"><code>JosephsonCircuits.axis_to_modes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">axis_to_modes(S::AbstractArray, modes_axis::Integer)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.axis_to_modes([111 121;211 221;;; 112 122;212 222;;; 113 123;213 223],3)
6×6 Matrix{Int64}:
 111    0    0  121    0    0
   0  112    0    0  122    0
   0    0  113    0    0  123
 211    0    0  221    0    0
   0  212    0    0  222    0
   0    0  213    0    0  223

julia&gt; JosephsonCircuits.axis_to_modes([111 121;211 221;;;; 112 122;212 222;;;; 113 123;213 223],4)
6×6×1 Array{Int64, 3}:
[:, :, 1] =
 111    0    0  121    0    0
   0  112    0    0  122    0
   0    0  113    0    0  123
 211    0    0  221    0    0
   0  212    0    0  222    0
   0    0  213    0    0  223

julia&gt; JosephsonCircuits.axis_to_modes([111 121;211 221;;;; 112 122;212 222;;;; 113 123;213 223],3)
2×2×3 Array{Int64, 3}:
[:, :, 1] =
 111  121
 211  221

[:, :, 2] =
 112  122
 212  222

[:, :, 3] =
 113  123
 213  223</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcAoLjbm-Tuple{Any, SparseArrays.SparseVector, Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcAoLjbm-Tuple{Any, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcAoLjbm(Am, Ljb::SparseVector, Lmean, Nmodes, Nbranches)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,2,1)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 A11 / Lj1  A31 / Lj1
 A31 / Lj1  A11 / Lj1

julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 A11 / Lj1  A31 / Lj1          ⋅          ⋅
 A31 / Lj1  A11 / Lj1          ⋅          ⋅
         ⋅          ⋅  A12 / Lj2  A32 / Lj2
         ⋅          ⋅  A32 / Lj2  A12 / Lj2

julia&gt; @variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;JosephsonCircuits.calcAoLjbm([A11;A21;A31],JosephsonCircuits.SparseArrays.sparsevec([1],[Lj1]),1,3,1)
3×3 SparseArrays.SparseMatrixCSC{Num, Int64} with 9 stored entries:
 A11 / Lj1  A31 / Lj1          0
 A31 / Lj1  A11 / Lj1  A31 / Lj1
         0  A31 / Lj1  A11 / Lj1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcAoLjbm2-Tuple{Array, Matrix, SparseArrays.SparseVector, Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcAoLjbm2-Tuple{Array, Matrix, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbm2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcAoLjbm2(Am::Array, Amatrixindices::Matrix, Ljb::SparseVector, Lmean,
    Nmodes, Nbranches, Nfreq)</code></pre><p>Return the harmonic balance matrix divided by the Josephson inductance.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Amatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]
Amatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 18 stored entries:
 1.0+1.0im  1.0-1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im  0.5-0.5im
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5+0.5im</code></pre><pre><code class="language-julia hljs">Amatrix = ComplexF64[1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im; 1.0 + 1.0im 1.0 + 1.0im]
Amatrixindices = [1 -2 0; 2 1 -2; 0 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,2.0])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 14 stored entries:
 1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅          ⋅    
 1.0+1.0im  1.0+1.0im  1.0-1.0im      ⋅          ⋅          ⋅    
     ⋅      1.0+1.0im  1.0+1.0im      ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5-0.5im      ⋅    
     ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im  0.5-0.5im
     ⋅          ⋅          ⋅          ⋅      0.5+0.5im  0.5+0.5im</code></pre><pre><code class="language-julia hljs">@variables A11 A12 A21 A22 A31 A32 Lj1 Lj2
Amatrix = [A11 A12;A21 A22;A31 A32]
Amatrixindices = [1 -2 -3; 2 1 -2; 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2])
Lmean = 1
Nmodes = 3
Nbranches = 2
JosephsonCircuits.calcAoLjbm2(Amatrix, Amatrixindices, Ljb, Lmean, Nmodes, Nbranches)

# output
6×6 SparseArrays.SparseMatrixCSC{Num, Int64} with 18 stored entries:
 A11 / Lj1  A21 / Lj1  A31 / Lj1          ⋅          ⋅          ⋅
 A21 / Lj1  A11 / Lj1  A21 / Lj1          ⋅          ⋅          ⋅
 A31 / Lj1  A21 / Lj1  A11 / Lj1          ⋅          ⋅          ⋅
         ⋅          ⋅          ⋅  A12 / Lj2  A22 / Lj2  A32 / Lj2
         ⋅          ⋅          ⋅  A22 / Lj2  A12 / Lj2  A22 / Lj2
         ⋅          ⋅          ⋅  A32 / Lj2  A22 / Lj2  A12 / Lj2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcAoLjbmindices-Tuple{Matrix, SparseArrays.SparseVector, Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcAoLjbmindices-Tuple{Matrix, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.calcAoLjbmindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcAoLjbmindices(Amatrixindices, Ljb::SparseVector, Nmodes, Nbranches,
    Nfreq)</code></pre><p>Return the sparse matrix containing the indices from the frequency domain RFFT data as well as the indices of the sparse matrix to conjugate.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
AoLjbmindices

# output
8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:
 1  2  3  4  ⋅  ⋅  ⋅  ⋅
 2  1  2  3  ⋅  ⋅  ⋅  ⋅
 3  2  1  2  ⋅  ⋅  ⋅  ⋅
 4  3  2  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  5  6  7  8
 ⋅  ⋅  ⋅  ⋅  6  5  6  7
 ⋅  ⋅  ⋅  ⋅  7  6  5  6
 ⋅  ⋅  ⋅  ⋅  8  7  6  5</code></pre><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 0; 2 1 -2 -3; 3 2 1 -2; 0 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
AoLjbmindices

# output
8×8 SparseArrays.SparseMatrixCSC{Int64, Int64} with 28 stored entries:
 1  2  3  ⋅  ⋅  ⋅  ⋅  ⋅
 2  1  2  3  ⋅  ⋅  ⋅  ⋅
 3  2  1  2  ⋅  ⋅  ⋅  ⋅
 ⋅  3  2  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  5  6  7  ⋅
 ⋅  ⋅  ⋅  ⋅  6  5  6  7
 ⋅  ⋅  ⋅  ⋅  7  6  5  6
 ⋅  ⋅  ⋅  ⋅  ⋅  7  6  5</code></pre><pre><code class="language-julia hljs">Amatrixindices = [1 -2 -3 -4; 2 1 -2 -3; 3 2 1 -2; 4 3 2 1]
Ljb = JosephsonCircuits.SparseArrays.sparsevec([1,3],[1.0,1.0])
Nmodes = 4
Nbranches = length(Ljb)
Nfreq = 4
AoLjbmindices, conjindicessorted, nentries = JosephsonCircuits.calcAoLjbmindices(
    Amatrixindices,
    Ljb,
    Nmodes,
    Nbranches,
    Nfreq);
for c in conjindicessorted;AoLjbmindices.nzval[c] = -AoLjbmindices.nzval[c];end;AoLjbmindices

# output
12×12 SparseArrays.SparseMatrixCSC{Int64, Int64} with 32 stored entries:
 1  -2  -3  -4  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 2   1  -2  -3  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 3   2   1  -2  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 4   3   2   1  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  ⋅   ⋅   ⋅   ⋅
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  5  -6  -7  -8
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  6   5  -6  -7
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  7   6   5  -6
 ⋅   ⋅   ⋅   ⋅  ⋅  ⋅  ⋅  ⋅  8   7   6   5</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCjIcmean-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector{String}, Dict, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.calcCjIcmean-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector{String}, Dict, Dict}"><code>JosephsonCircuits.calcCjIcmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCjIcmean(componenttypes::Vector{Symbol}, nodeindexarray::Matrix{Int},
    componentvalues::Vector, componentnamedict::Dict,
    mutualinductorbranchnames::Vector{String}, countdict::Dict,
    indexdict::Dict)</code></pre><p>Calculate the junction properties including the max and min critical currents and ratios of critical current to junction capacitance. This is necessary in order to set the junction properties of the JJ model in WRSPICE.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">componenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]
nodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]
componentvalues = Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]
componentnamedict = Dict(&quot;R1&quot; =&gt; 2, &quot;Cc2&quot; =&gt; 6, &quot;Cj2&quot; =&gt; 8, &quot;Cj1&quot; =&gt; 5, &quot;P1&quot; =&gt; 1, &quot;Cc1&quot; =&gt; 3, &quot;Lj2&quot; =&gt; 7, &quot;Lj1&quot; =&gt; 4)
mutualinductorbranchnames = String[]
countdict = Dict((:Lj, 1, 4) =&gt; 1, (:C, 3, 4) =&gt; 1, (:C, 1, 4) =&gt; 1, (:Lj, 1, 3) =&gt; 1, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 1, (:C, 2, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:Lj, 1, 3, 1) =&gt; 4, (:C, 1, 3, 1) =&gt; 5, (:R, 1, 2, 1) =&gt; 2, (:C, 3, 4, 1) =&gt; 6, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 4, 1) =&gt; 8, (:Lj, 1, 4, 1) =&gt; 7)
Cj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,
    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)

# output
(3.1100514732000003e-13, 3.1414661345454545e-7)</code></pre><pre><code class="language-julia hljs">componenttypes = [:P, :R, :C, :Lj, :C, :C, :Lj, :C]
nodeindexarray = [2 2 2 3 3 3 4 4; 1 1 3 1 1 4 1 1]
componentvalues = Real[1, 50.0, 1.0e-13, 2.0e-9, 1.0e-12, 1.0e-13, 1.1e-9, 1.2e-12]
componentnamedict = Dict(&quot;R1&quot; =&gt; 2, &quot;Cc2&quot; =&gt; 6, &quot;Cj2&quot; =&gt; 8, &quot;Cj1&quot; =&gt; 5, &quot;P1&quot; =&gt; 1, &quot;Cc1&quot; =&gt; 3, &quot;Lj2&quot; =&gt; 7, &quot;Lj1&quot; =&gt; 4)
mutualinductorbranchnames = String[]
countdict = Dict((:Lj, 1, 4) =&gt; 1, (:C, 3, 4) =&gt; 1, (:C, 1, 4) =&gt; 1, (:Lj, 1, 3) =&gt; 1, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 1, (:C, 2, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:Lj, 1, 3, 1) =&gt; 4, (:C, 1, 3, 1) =&gt; 5, (:R, 1, 2, 1) =&gt; 2, (:C, 3, 4, 1) =&gt; 6, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 4, 1) =&gt; 8, (:Lj, 1, 4, 1) =&gt; 7)
Cj, Icmean = JosephsonCircuits.calcCjIcmean(componenttypes, nodeindexarray,
    componentvalues, componentnamedict,mutualinductorbranchnames, countdict, indexdict)

# output
(2.2955141825999997e-13, 2.3187011945454544e-7)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>JosephsonCircuits.calcCn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, Nmodes, Nnodes)</code></pre><p>Returns the node capacitance matrix from the capacitance values in <code>componentvalues</code> when <code>componenttypes</code> has the symbol <code>:C</code> with node indices from <code>nodeindices</code>. Other symbols are ignored. Capacitances to ground become diagonal elements. Capacitance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are <code>(Nnodes-1)*Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code> where <code>Nnodes</code> is the number of nodes including ground and <code>Nmodes</code> is the number of different frequencies. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[1.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅ 
  ⋅   2.0

julia&gt; JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.1  -0.1
 -0.1   2.1

julia&gt; JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[1.0,0.1,2.0],2,3)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.1    ⋅   -0.1    ⋅ 
   ⋅    1.1    ⋅   -0.1
 -0.1    ⋅    2.1    ⋅ 
   ⋅   -0.1    ⋅    2.1

julia&gt; @variables Cg1 Cg2;JosephsonCircuits.calcCn([:C,:C],[2 3;1 1],[Cg1,Cg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 Cg1    ⋅
   ⋅  Cg2

julia&gt; @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 Cc + Cg1       -Cc
      -Cc  Cc + Cg1

julia&gt; @variables Cg1 Cc Cg2;JosephsonCircuits.calcCn([:C,:C,:C],[2 2 3;1 3 1],[Cg1, Cc, Cg1],2,3)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 Cc + Cg1         ⋅       -Cc         ⋅
        ⋅  Cc + Cg1         ⋅       -Cc
      -Cc         ⋅  Cc + Cg1         ⋅
        ⋅       -Cc         ⋅  Cc + Cg1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCnoise!-Tuple{AbstractMatrix, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcCnoise!-Tuple{AbstractMatrix, Any}"><code>JosephsonCircuits.calcCnoise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCnoise!(Cnoise, S)</code></pre><p>Calculate the noise wave covariance matrix for a scattering matrix in the field ladder operator basis. Overwrites <code>Cnoise</code> with output.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCnoise!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcCnoise!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcCnoise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCnoise!(Cnoise, S, Snoise)</code></pre><p>Calculate the noise wave covariance matrix for a scattering matrix in the field ladder operator basis. Overwrites <code>Cnoise</code> with output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; C=zeros(Float64,2,2);JosephsonCircuits.calcCnoise!(C,[1 2;3 4],[0.0 0 0;0 0 0]);C
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCnoise-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcCnoise-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>JosephsonCircuits.calcCnoise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCnoise(S::AbstractMatrix{T}) where {T}</code></pre><p>Return the noise wave covariance matrix computed using Bosma&#39;s theorem for a passive linear network with scattering parameter matrix <code>S</code>. The network can be lossy and non-reciprocal.</p><p>This function assumes vacuum fluctuations as input to the ports, but could be extended to allow arbitrary noise temperatures.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcCnoise(JosephsonCircuits.S_splitter!(zeros(Complex{Float64},2,2)))
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im

julia&gt; S = rand(Complex{Float64},3,3);isapprox(JosephsonCircuits.calcCnoise(S),[1.0 0 0;0 1 0;0 0 1].-S*S&#39;)
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcCnoise-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcCnoise-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><code>JosephsonCircuits.calcCnoise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcCnoise(S::AbstractArray{T}, Snoise::AbstractArray{T}) where {T}</code></pre><p>Calculate the noise wave covariance matrix for a scattering matrix in the field ladder operator basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcCnoise([3/5 4/5;4/5 3/5],[0.0 0.0;0.0 0.0])
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0

julia&gt; JosephsonCircuits.calcCnoise(Complex{Float64}[3/5 4/5;4/5 3/5],Complex{Float64}[0.0 0.0;0.0 0.0])
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>JosephsonCircuits.calcGn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcGn(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, Nmodes, Nnodes)</code></pre><p>Returns the node conductance matrix from the resistance values in <code>componentvalues</code> when <code>componenttypes</code> has the symbol <code>:R</code>. The node indices are taken from <code>nodeindices</code>. Conductances to ground are diagonal elements. Conductance between elements is an off-diagonal element with a minus sign and is added to the diagonal with a plus sign. The dimensions of the output are <code>(Nnodes-1)</code> times <code>Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p>We have to calculate the inverse of the individual components so select a type that allows that.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[1.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅ 
  ⋅   0.5

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.01  -0.01
 -0.01   0.51

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[1 3 1;2 2 3],[1.0,100.0,2.0],1,3)
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  1.01  -0.01
 -0.01   0.51

julia&gt; JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[1.0,100.0,2.0],2,3)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.01    ⋅    -0.01    ⋅ 
   ⋅     1.01    ⋅    -0.01
 -0.01    ⋅     0.51    ⋅ 
   ⋅    -0.01    ⋅     0.51

julia&gt; @variables Rg1 Rg2;JosephsonCircuits.calcGn([:R,:R],[2 3;1 1],[Rg1,Rg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 1 / Rg1        ⋅
       ⋅  1 / Rg2

julia&gt; @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],1,3)
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 1 / Rc + 1 / Rg1           -1 / Rc
          -1 / Rc  1 / Rc + 1 / Rg2

julia&gt; @variables Rg1 Rc Rg2;JosephsonCircuits.calcGn([:R,:R,:R],[2 2 3;1 3 1],[Rg1,Rc,Rg2],2,3)
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 8 stored entries:
 1 / Rc + 1 / Rg1                 ⋅           -1 / Rc                 ⋅
                ⋅  1 / Rc + 1 / Rg1                 ⋅           -1 / Rc
          -1 / Rc                 ⋅  1 / Rc + 1 / Rg2                 ⋅
                ⋅           -1 / Rc                 ⋅  1 / Rc + 1 / Rg2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcIb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcIb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcIb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcIb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch current source vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:I,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:I1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ib = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Ib)

# output
sparsevec([1], [1.0e-9], 2)</code></pre><pre><code class="language-julia hljs">@variables I1 C1 L1 C2
Nmodes = 1
Nbranches = 2
componenttypes = [:I,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [I1, C1, L1, C2]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:I1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ib = JosephsonCircuits.calcIb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Ib)

# output
sparsevec([1], Num[I1], 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcLb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcLb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch inductance vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Lb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Lb)

# output
sparsevec([1, 2], [1.0e-9, 4.0e-9], 2)</code></pre><pre><code class="language-julia hljs">@variables L1 K1 L2 C1
Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [L1, K1, L2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Lb = JosephsonCircuits.calcLb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Lb)

# output
sparsevec([1, 2], Num[L1, L2], 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcLjb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcLjb(componenttypes, nodeindices, componentvalues, edge2indexdict,
    Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch Josephson inductance vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:Lj,:C,:Lj,:C]
nodeindices = [2 3 3 3; 1 2 1 1]
componentvalues = [1e-9, 1e-12, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:Cc =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ljb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Ljb)

# output
sparsevec([1, 2], [1.0e-9, 4.0e-9], 2)</code></pre><pre><code class="language-julia hljs">@variables Lj1 K1 Lj2 C1
Nmodes = 1
Nbranches = 2
componenttypes = [:Lj,:K,:Lj,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [Lj1, K1, Lj2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:Lj2 =&gt; 3,:Lj1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Ljb = JosephsonCircuits.calcLjb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Ljb)

# output
sparsevec([1, 2], Num[Lj1, Lj2], 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>JosephsonCircuits.calcLmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcLmean(componenttypes::Vector{Symbol}, componentvalues::Vector)</code></pre><p>Return the mean of the linear and Josephson inductors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[10,4,5,1])
2.5

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[R1, L1, C1, Lj1])
(L1 + Lj1) / 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector{Nothing}}"><a class="docstring-binding" href="#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector{Nothing}}"><code>JosephsonCircuits.calcLmean_inner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcLmean_inner(componenttypes::Vector, componentvalues::Vector,
    valuecomponenttypes::Vector{Nothing})</code></pre><p>Return the mean of the linear and Josephson inductors. Return 0 if the expected return type is Nothing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean_inner([:R,:C,:C,:P],[10,4,5,1],Nothing[])
0

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[R1, L1, C1, Lj1],Nothing[])
0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcLmean_inner-Tuple{Vector, Vector, Vector}"><code>JosephsonCircuits.calcLmean_inner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcLmean_inner(componenttypes::Vector, componentvalues::Vector,
    valuecomponenttypes::Vector)</code></pre><p>Return the mean of the linear and Josephson inductors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcLmean_inner([:R,:L,:C,:Lj],[10,4,5,1],Float64[])
2.5

julia&gt; JosephsonCircuits.calcLmean_inner([:R,:C,:C,:C],[10,4,5,1],Float64[])
0.0

julia&gt; @variables R1 L1 C1 Lj1;JosephsonCircuits.calcLmean([:R,:L,:C,:Lj],[R1, L1, C1, Lj1])
(L1 + Lj1) / 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcMb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcMb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, componentnamedict::Dict,
    mutualinductorbranchnames::Vector, edge2indexdict::Dict, Nmodes,
    Nbranches)</code></pre><p>Returns the branch mutual inductance matrix. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 2e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
mutualinductorbranchnames = [ :L1, :L2]
Mb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)

# output
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
  ⋅           2.82843e-10
 2.82843e-10   ⋅ </code></pre><pre><code class="language-julia hljs">@variables L1 L2 K1 C1
Nmodes = 2
Nbranches = 2
componenttypes = [:L,:K,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [L1, K1, L2, C1]
componentnamedict = Dict{Symbol, Int}(:C1 =&gt; 4,:L2 =&gt; 3,:L1 =&gt; 1,:K1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
mutualinductorbranchnames = [ :L1, :L2]
Mb = JosephsonCircuits.calcMb(componenttypes,nodeindices,componentvalues,componentnamedict,mutualinductorbranchnames,edge2indexdict,Nmodes,Nbranches)

# output
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
              ⋅               ⋅  K1*sqrt(L1*L2)               ⋅
              ⋅               ⋅               ⋅  K1*sqrt(L1*L2)
 K1*sqrt(L1*L2)               ⋅               ⋅               ⋅
              ⋅  K1*sqrt(L1*L2)               ⋅               ⋅</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcVb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcVb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>JosephsonCircuits.calcVb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcVb(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, edge2indexdict::Dict, Nmodes, Nbranches)</code></pre><p>Calculate the sparse branch voltage source vector whose length is <code>Nbranches*Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Nbranches = 2
componenttypes = [:V,:C,:L1,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [1e-9, 0.2, 4e-9, 1e-12]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:V1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Vb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Vb)

# output
sparsevec([1], [1.0e-9], 2)</code></pre><pre><code class="language-julia hljs">@variables V1 C1 L1 C2
Nmodes = 1
Nbranches = 2
componenttypes = [:V,:C,:L,:C]
nodeindices = [2 0 3 3; 1 0 1 1]
componentvalues = [V1, C1, L1, C2]
componentnamedict = Dict{Symbol, Int}(:C2 =&gt; 4,:L1 =&gt; 3,:V1 =&gt; 1,:C1 =&gt; 2)
edge2indexdict = Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1,(3, 1) =&gt; 2,(1, 3) =&gt; 2,(2, 1) =&gt; 1)
Vb = JosephsonCircuits.calcVb(componenttypes,nodeindices,componentvalues,edge2indexdict,Nmodes,Nbranches)
JosephsonCircuits.testshow(stdout,Vb)

# output
sparsevec([1], Num[V1], 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcbranchvector-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Dict, Any, Any, Symbol, Function}"><a class="docstring-binding" href="#JosephsonCircuits.calcbranchvector-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Dict, Any, Any, Symbol, Function}"><code>JosephsonCircuits.calcbranchvector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcbranchvector(componenttypes::Vector{Symbol},
    nodeindices::Matrix{Int}, componentvalues::Vector,
    valuecomponenttypes::Vector, edge2indexdict::Dict, Nmodes, Nbranches,
    component::Symbol, combine::Function)</code></pre><p>Calculate the sparse branch vector whose length is <code>Nbranches*Nmodes</code> for the given component symbol. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node. The <code>combine</code> function determines how elements of the sparse vector will be combined.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccircuitgraph-Tuple{JosephsonCircuits.ParsedSortedCircuit}"><a class="docstring-binding" href="#JosephsonCircuits.calccircuitgraph-Tuple{JosephsonCircuits.ParsedSortedCircuit}"><code>JosephsonCircuits.calccircuitgraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccircuitgraph(parsedsortedcircuit::ParsedSortedCircuit)</code></pre><p>Calculate the superconducting spanning tree, incidence matrix, closure branches, and loops from the parsed and sorted circuit.</p><p>See also <a href="#JosephsonCircuits.CircuitGraph"><code>CircuitGraph</code></a>, <a href="#JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}"><code>calcgraphs</code></a>, and <a href="#JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}"><code>extractbranches</code></a>  for more explanation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
psc = JosephsonCircuits.ParsedSortedCircuit(
    [2 2 2 2 0 3 3; 1 1 1 1 0 1 1],
    [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
    [&quot;L1&quot;, &quot;L2&quot;],
    [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;],
    [:P, :I, :R, :L, :K, :L, :C],
    Num[1, Ipump, Rleft, L1, K1, L2, C2],
    Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5),
    3)
cg = JosephsonCircuits.calccircuitgraph(psc)
# output
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L Lj Cj
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;2&quot;,L))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
# output
JosephsonCircuits.CircuitGraph(Dict((3, 2) =&gt; 3, (1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1, (2, 3) =&gt; 3), sparse([1, 3, 2, 3], [1, 1, 2, 2], [1, -1, 1, 1], 3, 2), [(1, 2), (1, 3)], [(3, 2)], [(1, 2), (1, 3), (2, 3)], [[1, 2, 3]], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm!-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calccm!-NTuple{4, Any}"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm!(cm, S, Snoise, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the field ladder operator basis. Overwrites cm with output.</p><p><strong># Examples</strong></p><p><strong>```jldoctest</strong></p><p><strong>julia&gt; @variables a b c d an bn cn dn;cm = Num[0, 0];JosephsonCircuits.calccm!(cm,Num[a b; c d],[an bn; cn dn],[1, -1]);cm</strong></p><p><strong>2-element Vector{Num}:</strong></p><p><strong>-abs2(bn) + abs2(a) - abs2(b) + abs2(an)</strong></p><p><strong>abs2(c) - abs2(dn) - abs2(d) + abs2(cn)</strong></p><p><strong>```</strong></p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calccm!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm!(cm, S, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the field ladder operator basis. Overwrites cm with output.</p><p><strong># Examples</strong></p><p><strong>```jldoctest</strong></p><p><strong>julia&gt; @variables a b;cm=Num[0,0];JosephsonCircuits.calccm!(cm,[a b; b a],[-1,1]);cm</strong></p><p><strong>2-element Vector{Num}:</strong></p><p><strong>-abs2(a) + abs2(b)</strong></p><p><strong>abs2(a) - abs2(b)</strong></p><p><strong>```</strong></p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any, Any}} where T&lt;:AbstractFloat"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm!(cm::AbstractArray{T}, S, Snoise, w) where {T&lt;:AbstractFloat}</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output.  Use a compensated sum to reduce floating point errors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cm=Float64[0, 0];JosephsonCircuits.calccm!(cm,[1 2;3 4],[1 2 3 4;5 6 7 8],[-1,1]);cm
2-element Vector{Float64}:
 13.0
 33.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#JosephsonCircuits.calccm!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T&lt;:AbstractFloat"><code>JosephsonCircuits.calccm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm!(cm::AbstractArray{T}, S, w) where {T&lt;:AbstractFloat}</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Overwrites cm with output. Use a compensated sum to reduce floating point errors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cm=Float64[0,0];JosephsonCircuits.calccm!(cm,[3/5 4/5;4/5 3/5],[-1,1]);cm
2-element Vector{Float64}:
  0.28000000000000014
 -0.28000000000000014</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Any}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Any}} where T"><code>JosephsonCircuits.calccm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm(S::AbstractArray, Snoise::AbstractArray, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 1 1 1],[1 1e-100 2e-100 1;1 1 1 1],[1, -1])
2-element Vector{Float64}:
 6.0e-200
 0.0

julia&gt; JosephsonCircuits.calccm(Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],Complex{Float64}[1 1e-100 2e-100 1;1 1 1 1],[1, -1])
2-element Vector{Float64}:
 6.0e-200
 0.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calccm-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>JosephsonCircuits.calccm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calccm(S::AbstractArray, w)</code></pre><p>Calculate the bosonic commutation relations for a scattering matrix S in the  field ladder operator basis. Sum the abs2 of each element along the horizontal axis, applying a minus sign if the corresponding frequency is negative. Represents energy conservation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calccm(Complex{Float64}[3/5 4/5;4/5 3/5],[1])
2-element Vector{Float64}:
 1.0
 1.0

julia&gt; JosephsonCircuits.calccm([1 1e-100 2e-100 1;1 0 0 1],[1, -1])
2-element Vector{Float64}:
 3.0e-200
 0.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcdZdroZ2-NTuple{5, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcdZdroZ2-NTuple{5, Any}"><code>JosephsonCircuits.calcdZdroZ2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcdZdroZ2(sensitivityindices, componenttypes, componentvalues, wmodes,
    symfreqvar)</code></pre><p>Calculate 1/Z^2 times the derivative of Z with respect to parameter scaling the value of the circuit component. For example:</p><pre><code class="language-julia hljs">Zc = 1/(im*w*Cg*r)
1/Zc^2*dZc/dr|_{r=1} = -im*Cg*w

Zl = im*w*Lj*r
1/Zl^2*dZl/dr =1/(im*Lj*r^2*w)|_{r=1} = 1/(im*Lj*w)

Zr = R*r
1/Zr^2*dZr/dr|_{r=1} = 1/(r^2*R) = 1/R</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:R], [50.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.02 + 0.0im

julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:C], [2.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.0 - 2.0im

julia&gt; JosephsonCircuits.calcdZdroZ2([1],[:L], [2.0], [1.0],nothing)
1-element Vector{ComplexF64}:
 0.0 - 0.5im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcfj!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 9}}"><a class="docstring-binding" href="#JosephsonCircuits.calcfj!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 9}}"><code>JosephsonCircuits.calcfj!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcfj!(F,J,nodeflux,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,
    Ljbindicesm,Nmodes,Lmean,AoLjbm)</code></pre><p>Calculate the residual and the Jacobian. These are calculated with one function in order to reuse the time domain nonlinearity calculation.</p><p>Leave off the type signatures on F and J because the solver will pass a type of Nothing if it only wants to calculate F or J. </p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcfj2!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 18}}"><a class="docstring-binding" href="#JosephsonCircuits.calcfj2!-Tuple{Any, Any, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, SparseArrays.SparseVector, SparseArrays.SparseVector, Int64, Int64, Any, AbstractVector, Vararg{Any, 18}}"><code>JosephsonCircuits.calcfj2!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcfj2!(F,J,phin,wmodesm,wmodes2m,Rbnm,invLnm,Cnm,Gnm,bm,Ljb,Ljbindices,
    Ljbindicesm,Nmodes,Lmean,AoLjbm)</code></pre><p>Calculate the residual and the Jacobian. These are calculated with one function in order to reuse as much as possible.</p><p>Leave off the type signatures on F and J because the solver will pass <code>nothing</code> if it only wants to calculate F or J.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcfreqs-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}, NTuple{N, Int64}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.calcfreqs-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}, NTuple{N, Int64}}} where N"><code>JosephsonCircuits.calcfreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcfreqs(Nharmonics::NTuple{N,Int}, Nw::NTuple{N,Int}, Nt::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the DFT or RFDT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array. See also <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcfreqsdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><a class="docstring-binding" href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>JosephsonCircuits.calcfreqsdft</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcfreqsdft(Nharmonics::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the DFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain DFT array.</p><p><strong>Arguments</strong></p><ul><li><code>Nharmonics</code>: is a tuple of the number of harmonics to calculate for   each frequency.</li></ul><p><strong>Returns</strong></p><ul><li><code>Frequencies</code>: A simple structure to hold time and frequency domain   information for the signal for a single node. See <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcfreqsrdft((1,))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((2,))
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,))
JosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,3))
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcfreqsrdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><a class="docstring-binding" href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>JosephsonCircuits.calcfreqsrdft</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcfreqsrdft(Nharmonics::NTuple{N,Int})</code></pre><p>Calculate the dimensions of the RDFT in the frequency domain and the time domain given a tuple of the number of harmonics. Eg. 0,w,2w,3w would be 3 harmonics. Also calculate the possible modes and their coordinates in the frequency domain RDFT array.</p><p><strong>Arguments</strong></p><ul><li><code>Nharmonics</code>: is a tuple of the number of harmonics to calculate for   each frequency.</li></ul><p><strong>Returns</strong></p><ul><li><code>Frequencies</code>: A simple structure to hold time and frequency domain   information for the signal for a single node. See <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcfreqsrdft((1,))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((2,))
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,))
JosephsonCircuits.Frequencies{1}((3,), (4,), (6,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,), CartesianIndex(4,)], [(0,), (1,), (2,), (3,)])

julia&gt; JosephsonCircuits.calcfreqsrdft((3,3))
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(4, 2), CartesianIndex(1, 3), CartesianIndex(2, 3)  …  CartesianIndex(3, 5), CartesianIndex(4, 5), CartesianIndex(1, 6), CartesianIndex(2, 6), CartesianIndex(3, 6), CartesianIndex(4, 6), CartesianIndex(1, 7), CartesianIndex(2, 7), CartesianIndex(3, 7), CartesianIndex(4, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1), (0, 2), (1, 2)  …  (2, -3), (3, -3), (0, -2), (1, -2), (2, -2), (3, -2), (0, -1), (1, -1), (2, -1), (3, -1)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.calcgraphs-Tuple{Vector{Tuple{Int64, Int64}}, Int64}"><code>JosephsonCircuits.calcgraphs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcgraphs(Ledgearray::Array{Tuple{Int, Int}, 1}, Nnodes::Int)</code></pre><p>Calculate the superconducting spanning tree, closure branches, and loops. Accepts the graph of linear inductors and Josephson junctions. Outputs lists of edges that can be used to generate graphs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (2, 1), (3, 1)], 3)
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)

julia&gt; JosephsonCircuits.calcgraphs([(4, 3), (3, 6), (5, 3), (3, 7), (2, 4), (6, 8), (2, 5), (8, 7), (2, 8)], 8)
JosephsonCircuits.CircuitGraph(Dict((6, 8) =&gt; 8, (2, 5) =&gt; 2, (3, 7) =&gt; 7, (6, 3) =&gt; 6, (7, 8) =&gt; 9, (3, 4) =&gt; 4, (7, 3) =&gt; 7, (2, 8) =&gt; 3, (4, 2) =&gt; 1, (8, 6) =&gt; 8…), sparse([1, 2, 3, 4, 5, 6, 7, 1, 4, 2, 5, 6, 8, 7, 9, 3, 8, 9], [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7], [-1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1], 9, 7), [(2, 4), (2, 5), (2, 8), (3, 4), (3, 6), (3, 7)], [(5, 3), (8, 6), (8, 7)], [(2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (3, 7), (6, 8), (7, 8)], [[2, 4, 3, 5], [2, 4, 3, 6, 8], [2, 4, 3, 7, 8]], [1], Graphs.SimpleGraphs.SimpleGraph{Int64}(9, [Int64[], [4, 5, 8], [4, 5, 6, 7], [2, 3], [2, 3], [3, 8], [3, 8], [2, 6, 7]]), 9)

julia&gt; JosephsonCircuits.calcgraphs([(2, 1), (2, 1), (3, 1)],4)
JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), sparse([1, 2], [1, 2], [1, 1], 2, 3), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcimpedance-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcimpedance-NTuple{4, Any}"><code>JosephsonCircuits.calcimpedance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcimpedance(c, type, w, symfreqvar)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:R,2.0,w)
60.0 + 0.0im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:C,2.0,w)
0.0 - 0.008333333333333333im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:L,2.0,w)
0.0 + 120.0im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:R,-2.0,w)
-60.0 + 0.0im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:C,-2.0,w)
0.0 - 0.008333333333333333im

julia&gt; @variables w;JosephsonCircuits.calcimpedance(30*w,:L,-2.0,w)
0.0 + 120.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcimpedance-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Any, Any, Any}} where T&lt;:Union{AbstractFloat, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.calcimpedance-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Any, Any, Any}} where T&lt;:Union{AbstractFloat, Integer}"><code>JosephsonCircuits.calcimpedance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcimpedance(c::Union{Integer,T,Complex{T}}, type, w, symfreqvar,
    ) where {T&lt;:AbstractFloat}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcimpedance(30.0,:C,1.0,nothing)
0.0 - 0.03333333333333333im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:L,1.0,nothing)
0.0 + 30.0im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:R,1.0,nothing)
30.0 + 0.0im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:C,-1.0,nothing)
-0.0 + 0.03333333333333333im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:L,-1.0,nothing)
-0.0 - 30.0im

julia&gt; JosephsonCircuits.calcimpedance(30.0,:R,-1.0,nothing)
30.0 + 0.0im
</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcindexdict-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcindexdict-Tuple{Any}"><code>JosephsonCircuits.calcindexdict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcindexdict(N::Int)</code></pre><p>Return a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindexdict(3)
Dict{CartesianIndex{1}, Int64} with 3 entries:
  CartesianIndex(2,) =&gt; 2
  CartesianIndex(3,) =&gt; 3
  CartesianIndex(1,) =&gt; 1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcindexdict-Tuple{Tuple}"><a class="docstring-binding" href="#JosephsonCircuits.calcindexdict-Tuple{Tuple}"><code>JosephsonCircuits.calcindexdict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcindexdict(N::Tuple)</code></pre><p>Return a dictionary of Cartesian indices where the Cartesian index is the key and the index giving the order is the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindexdict((2,3))
Dict{CartesianIndex{2}, Int64} with 6 entries:
  CartesianIndex(2, 3) =&gt; 6
  CartesianIndex(2, 1) =&gt; 2
  CartesianIndex(1, 3) =&gt; 5
  CartesianIndex(1, 1) =&gt; 1
  CartesianIndex(2, 2) =&gt; 4
  CartesianIndex(1, 2) =&gt; 3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcindices-Tuple{Integer}"><a class="docstring-binding" href="#JosephsonCircuits.calcindices-Tuple{Integer}"><code>JosephsonCircuits.calcindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcindices(m::Integer)</code></pre><p>The indices over which to calculate the idlers using the formula ws+2<em>i</em>wp  where i is an index. This could be defined differently without causing any issues.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcindices(7)
-3:3

julia&gt; JosephsonCircuits.calcindices(8)
-4:3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinputcurrentoutputvoltage!-NTuple{8, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcinputcurrentoutputvoltage!-NTuple{8, Any}"><code>JosephsonCircuits.calcinputcurrentoutputvoltage!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinputcurrentoutputvoltage!(inputcurrent, outputvoltage, nodeflux,
    bnm, inputportindices, outputportindices, nodeindices, wmodes)</code></pre><p>Calculate the elements of the Z matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]
symfreqvar = nothing
JosephsonCircuits.calcinputcurrentoutputvoltage!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,nodeindices,wmodes)
println(outputwave)

# output
ComplexF64[-100.0 + 0.0im;;]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinputoutput!-NTuple{12, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcinputoutput!-NTuple{12, Any}"><code>JosephsonCircuits.calcinputoutput!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinputoutput!(inputwave, outputwave, phin, bnm, inputportindices,
    outputportindices, inputportimpedances, outputportimpedances,
    nodeindices, componenttypes, wmodes, symfreqvar)</code></pre><p>Return the input and output waves for the system linearized around the strong pump.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[0;0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(outputwave)

# output
ComplexF64[-3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [2 2 2 2 0 3 3; 1 1 1 1 0 1 1]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[50/(im*wmodes[1]);0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(outputwave)

# output
ComplexF64[3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[1; 0;;]
portimpedanceindices = [3]
portimpedances = ComplexF64[50]
nodeindices = [1 1 1 1 0 1 1; 2 2 2 2 0 3 3;]
componenttypes = [:P, :I, :R, :L, :K, :L, :C]
wmodes = [1]
phin = ComplexF64[50/(im*wmodes[1]);0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(outputwave)

# output
ComplexF64[-3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[0;0;;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(outputwave)

# output
ComplexF64[3.5355339059327378 + 0.0im;;]</code></pre><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
outputwave = ComplexF64[0;;]
bnm = ComplexF64[-1; 1;;]
portimpedanceindices = [2]
portimpedances = ComplexF64[50.0 + 0.0im]
nodeindices = [2 2 2 2 3; 3 3 1 1 1]
componenttypes = [:P, :R, :L, :C, :C]
wmodes = [1]
phin = ComplexF64[-50/(im*wmodes[1]);50/(im*wmodes[1]);;]
symfreqvar = nothing
JosephsonCircuits.calcinputoutput!(inputwave,outputwave,phin,bnm,portimpedanceindices,
    portimpedanceindices,portimpedances,portimpedances,nodeindices,componenttypes,
    wmodes,symfreqvar)
println(outputwave)

# output
ComplexF64[-10.606601717798213 + 0.0im;;]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinputoutput_inner!-NTuple{13, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcinputoutput_inner!-NTuple{13, Any}"><code>JosephsonCircuits.calcinputoutput_inner!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinputoutput_inner!(inputwave, outputwave, phin, bnm, inputportindices,
    outputportindices, inputportimpedances, outputportimpedances,
    nodeindices, componenttypes, wmodes, symfreqvar, nosource)</code></pre><p>Calculate the input and output power waves as defined in (except in units of sqrt(photons/second) instead of sqrt(power) K. Kurokawa, &quot;Power Waves and the Scattering Matrix&quot;, IEEE Trans. Micr. Theory and Tech. 13, 194–202 (1965)  doi: 10.1109/TMTT.1965.1125964 inputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * (portvoltage + portimpedance * portcurrent) we can simplify the above to: inputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * portimpedance * sourcecurrent outputwave[(i-1)<em>Nmodes+j,k] = 1/2</em>kval * (portvoltage - conj(portimpedance) * portcurrent) .</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinputoutputnoise!-NTuple{12, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcinputoutputnoise!-NTuple{12, Any}"><code>JosephsonCircuits.calcinputoutputnoise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinputoutputnoise!(S, inputwave, outputwave, phin, bnm,
    inputportindices, outputportindices, inputportimpedances,
    outputportimpedances, nodeindices, componenttypes, wmodes, symfreqvar)</code></pre><p>Return the input and output waves for the system linearized around the strong pump.</p><p>This is a bit of a hack but I ran into issues with complex capacitance when the capacitor was at the same branch as a current source. The calcS function would use that current source in calculating the output waves, which it should not do.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inputwave = JosephsonCircuits.LinearAlgebra.Diagonal(ComplexF64[0])
noiseoutputwave = ComplexF64[0;;]
phin = ComplexF64[-2.5000000000007394e-10 - 0.000795774715459398im; 1.983790476804266e-20 + 3.141592641138603e-16im;;]
bnm = ComplexF64[1.0 + 0.0im; 0.0 + 0.0im;;]
portimpedanceindices = [2]
noiseportimpedanceindices = [6]
portimpedances = [50]
noiseportimpedances = [1]
nodeindices = [2 2 2 3 3 3; 1 1 3 1 1 1]
componenttypes = [:P, :R, :C, :Lj, :C, :R]
wmodes = [2*pi*5e9]
symfreqvar = nothing
JosephsonCircuits.calcinputoutputnoise!(inputwave,noiseoutputwave,
    phin,bnm,portimpedanceindices,noiseportimpedanceindices,
    portimpedances,noiseportimpedances,nodeindices,
    componenttypes,wmodes,symfreqvar)
println(noiseoutputwave)

# output
ComplexF64[-5.568327974762547e-11 + 3.516177070001411e-15im;;]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>JosephsonCircuits.calcinvLn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinvLn(Lb::SparseVector, Rbn::SparseMatrixCSC, Nmodes)</code></pre><p>Returns the nodal inverse inductance matrix. Accepts the vector of branch inductances <code>Lb</code> and the incidence matrix <code>Rbn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0e9   ⋅ 
  ⋅     2.5e8</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
2×2 SparseArrays.SparseMatrixCSC{Num, Int64} with 2 stored entries:
 1 / L1       ⋅
      ⋅  1 / L2</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 2
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes)

# output
4×4 SparseArrays.SparseMatrixCSC{Num, Int64} with 4 stored entries:
 1 / L1       ⋅       ⋅       ⋅
      ⋅  1 / L1       ⋅       ⋅
      ⋅       ⋅  1 / L2       ⋅
      ⋅       ⋅       ⋅  1 / L2</code></pre><pre><code class="language-julia hljs">Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([],Nothing[])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval

# output
Nothing[]</code></pre><p>```jldoctest @syms L1 L2 Nmodes = 1 Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]) Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1]) JosephsonCircuits.calcinvLn(Lb,Rbn,Nmodes).nzval</p><p><strong>output</strong></p><p>2-element Vector{Any}:  1 / L1  1 / L2</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Int64}"><code>JosephsonCircuits.calcinvLn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcinvLn(Lb::SparseVector, Mb::SparseMatrixCSC,
    Rbn::SparseMatrixCSC, Nmodes)</code></pre><p>Returns the nodal inverse inductance matrix. Accepts the vector of branch inductances <code>Lb</code>, the branch mutual inductance matrix <code>Mb</code>, and the incidence matrix <code>Rbn</code>.</p><p>Using ldiv instead of an inverse: (where the extra div is an escape sequence) Can solve A x = B with: x = A \ B or x = invA * B, so we can perform the inverse here with: s = RbnT * invL * Rbn or s = RbnT * (L \ Rbn), the latter of which should be faster and more numerically stable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nmodes = 2
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[1e-9,4e-9])
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [4e-10,4e-10])
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes)

# output
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  1.04167e9    ⋅         -1.04167e8    ⋅ 
   ⋅          1.04167e9    ⋅         -1.04167e8
 -1.04167e8    ⋅          2.60417e8    ⋅ 
   ⋅         -1.04167e8    ⋅          2.60417e8</code></pre><pre><code class="language-julia hljs">@variables L1 L2 Lm
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm^2) / (L1*(L2 + (-(Lm^2)) / L1))) / L1, (-Lm) / (L1*(L2 + (-(Lm^2)) / L1)), (-Lm) / (L1*(L2 + (-(Lm^2)) / L1)), 1 / (L2 + (-(Lm^2)) / L1)], 2, 2)</code></pre><pre><code class="language-julia hljs">@variables L1 L2
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([], [], Nothing[]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2], [1, 2], Num[1 / L1, 1 / L2], 2, 2)</code></pre><pre><code class="language-julia hljs">@syms L1 L2 Lm
Nmodes = 1
Lb = JosephsonCircuits.SparseArrays.sparsevec([1,2],[L1,L2]);
Mb = JosephsonCircuits.SparseArrays.sparse([2,1], [1,2], [Lm,Lm]);
Rbn = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1.0,1.0])
println(JosephsonCircuits.calcinvLn(Lb,Mb,Rbn,Nmodes))

# output
sparse([1, 2, 1, 2], [1, 1, 2, 2], Num[(1.0 + (Lm^2) / (L1*(L2 + (-(Lm^2)) / L1))) / L1, (-Lm) / (L1*(L2 + (-(Lm^2)) / L1)), (-Lm) / (L1*(L2 + (-(Lm^2)) / L1)), 1 / (L2 + (-(Lm^2)) / L1)], 2, 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcmodefreqs-Union{Tuple{N}, Tuple{NTuple{N, Any}, Array{NTuple{N, Int64}, 1}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.calcmodefreqs-Union{Tuple{N}, Tuple{NTuple{N, Any}, Array{NTuple{N, Int64}, 1}}} where N"><code>JosephsonCircuits.calcmodefreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcmodefreqs(w::NTuple{N},modes::Vector{NTuple{N,Int}})</code></pre><p>Calculate the frequencies of the modes given a tuple of fundamental frequencies and a vector of tuples containing the mixing products and harmonics.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables wp1 wp2;JosephsonCircuits.calcmodefreqs((wp1, wp2),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])
6-element Vector{Num}:
          0
        wp1
       2wp1
        wp2
  wp1 + wp2
 2wp1 + wp2

julia&gt; JosephsonCircuits.calcmodefreqs((1., 1.1),[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)])
6-element Vector{Float64}:
 0.0
 1.0
 2.0
 1.1
 2.1
 3.1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcnodematrix-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Any, Any, Symbol, Bool}"><a class="docstring-binding" href="#JosephsonCircuits.calcnodematrix-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector, Any, Any, Symbol, Bool}"><code>JosephsonCircuits.calcnodematrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcnodematrix(componenttypes::Vector{Symbol}, nodeindices::Matrix{Int},
    componentvalues::Vector, valuecomponenttypes::Vector, Nmodes, Nnodes,
    component::Symbol, invert::Bool)</code></pre><p>Returns either the capacitance or conductance matrix depending on the values of <code>component</code> and <code>invert</code>. <code>:C</code> and <code>false</code> for capacitance and <code>:R</code> and <code>true</code> for conductance. The dimensions of the output are <code>(Nnodes-1)</code> times <code>Nmodes</code> by <code>(Nnodes-1)</code> times <code>Nmodes</code>. Note that <code>nodeindices</code> is &quot;one indexed&quot; so 1 is the ground node.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcnodes-Tuple{Int64, Int64, Vector{Symbol}, Matrix, Dict, Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.calcnodes-Tuple{Int64, Int64, Vector{Symbol}, Matrix, Dict, Vector{String}}"><code>JosephsonCircuits.calcnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcnodes(nodeindex::Int, mutualinductorindex::Int,
    componenttypes::Vector{Symbol}, nodeindexarray::Matrix,
    componentnamedict::Dict, mutualinductorbranchnames::Vector{String})</code></pre><p>Calculate the two nodes (or mutual inductor indices) given the index in the typvector and the component type. For component types where order matters, such as mutual inductors, the nodes are not sorted. For other component types where order does not matter, the nodes are sorted. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables R Cc L1 L2 Cj1 Cj2 I1 V1
@variables Ipump Rleft L1 K1 K2 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;,K2))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = JosephsonCircuits.parsesortcircuit(circuit)
println(JosephsonCircuits.calcnodes(1,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))
println(JosephsonCircuits.calcnodes(5,1,psc.componenttypes,psc.nodeindices, psc.componentnamedict,psc.mutualinductorbranchnames))

# output
(1, 2)
(4, 7)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcnodesorting-Tuple{Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.calcnodesorting-Tuple{Vector{String}}"><code>JosephsonCircuits.calcnodesorting</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcnodesorting(uniquenodevector::Vector{String};sorting=:number)</code></pre><p>Sort the unique node names in <code>uniquenodevector</code> according to the specified sorting scheme, always placing the ground node at the beginning. Return the indices which sort <code>uniquenodevector</code>.</p><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:name)
4-element Vector{Int64}:
 3
 2
 4
 1

julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:number)
4-element Vector{Int64}:
 3
 4
 2
 1

julia&gt; JosephsonCircuits.calcnodesorting([&quot;30&quot;,&quot;11&quot;,&quot;0&quot;,&quot;2&quot;];sorting=:none)
4-element Vector{Int64}:
 3
 1
 2
 4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcnoiseportimpedanceindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcnoiseportimpedanceindices(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int}, mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Find the resistors (not located at a port) or lossy capacitors or lossy inductors and return their indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
1-element Vector{Int64}:
 1</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
Int64[]</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,(30+1im)*1e-15])

# output
2-element Vector{Int64}:
 1
 4</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcnoiseportimpedanceindices(
    [:R,:C,:L,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,(1+1im)*1e-12,30e-15])

# output
2-element Vector{Int64}:
 1
 3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcphiindices-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, Dict{CartesianIndex{N}, CartesianIndex{N}}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.calcphiindices-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, Dict{CartesianIndex{N}, CartesianIndex{N}}}} where N"><code>JosephsonCircuits.calcphiindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcphiindices(frequencies::Frequencies{N},
    conjsymdict::Dict{CartesianIndex{N},CartesianIndex{N}})</code></pre><p>Return the indices which map the elements of the frequency domain vector to the corresponding elements of the frequency domain array. Also return the indices <code>conjsourceindices</code> whose data should be copied from the vector to <code>conjtargetindices</code> in the array then complex conjugated.</p><p><strong>Arguments</strong></p><ul><li><code>Nt</code>: tuple with dimensions of signal in time domain </li><li><code>dropdict</code>: dictionary of elements of frequency domain signal to drop where   the key is the Cartesian index and the value is the value. </li></ul><p><strong>Returns</strong></p><ul><li><code>indexmap</code>: the indices which map the elements of the frequency domain   vector elements to the corresponding elements of the frequency domain array</li><li><code>conjsourceindices</code>: data should be copied from here</li><li><code>conjtargetindices</code>: data should be copied to here and conjugated</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freq = JosephsonCircuits.Frequencies{2}((4, 3), (5, 7), (8, 7), CartesianIndex{2}[CartesianIndex(2, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(3, 2), CartesianIndex(2, 3), CartesianIndex(1, 4), CartesianIndex(2, 6), CartesianIndex(3, 7)], [(1, 0), (3, 0), (0, 1), (2, 1), (1, 2), (0, 3), (1, -2), (2, -1)])
conjsymdict = Dict{CartesianIndex{2}, CartesianIndex{2}}(CartesianIndex(5, 4) =&gt; CartesianIndex(5, 5), CartesianIndex(1, 3) =&gt; CartesianIndex(1, 6), CartesianIndex(5, 2) =&gt; CartesianIndex(5, 7), CartesianIndex(1, 4) =&gt; CartesianIndex(1, 5), CartesianIndex(1, 2) =&gt; CartesianIndex(1, 7), CartesianIndex(5, 3) =&gt; CartesianIndex(5, 6))
JosephsonCircuits.calcphiindices(freq, conjsymdict)

# output
([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])</code></pre><pre><code class="language-julia hljs">freq = JosephsonCircuits.calcfreqsrdft((4,3));
truncfreq = JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=3)
noconjtruncfreq = JosephsonCircuits.removeconjfreqs(truncfreq)
conjsymdict = JosephsonCircuits.conjsym(noconjtruncfreq)
JosephsonCircuits.calcphiindices(noconjtruncfreq,conjsymdict)

# output
([2, 4, 6, 8, 12, 16, 27, 33], [6, 16], [31, 21])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcportimpedanceindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcportimpedanceindices(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Find the resistors located at a port and return their indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
1-element Vector{Int64}:
 2</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
Int64[]</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 3 2 3 3 3 2; 1 1 3 1 1 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15,2,50.0])

# output
2-element Vector{Int64}:
 7
 2</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15,2,50.0])

# output
2-element Vector{Int64}:
 2
 7</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportimpedanceindices(
    [:P,:R,:C,:Lj,:C,:P,:R],
    [2 2 2 3 3 3 3; 1 1 3 1 1 1 1],
    [],
    [2,50,5e-15,1e-12,30e-15,1,50.0])

# output
2-element Vector{Int64}:
 7
 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>JosephsonCircuits.calcportindicesnumbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcportindicesnumbers(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int},mutualinductorbranchnames::Vector,
    componentvalues::Vector)</code></pre><p>Return vectors containing the indices of the ports and their numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:C],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,30e-15])

# output
([1], [1])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:P],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [1,50,5e-15,1e-12,2])

# output
([1, 5], [1, 2])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:P,:R,:C,:Lj,:P],
    [2 2 2 3 3; 1 1 3 1 1],
    [],
    [2,50,5e-15,1e-12,1])

# output
([5, 1], [1, 2])</code></pre><pre><code class="language-julia hljs">JosephsonCircuits.calcportindicesnumbers(
    [:R,:C,:Lj,:C],
    [2 2 3 3; 1 3 1 1],
    [],
    [50,5e-15,1e-12,30e-15])

# output
(Int64[], Int64[])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcqe!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcqe!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe!(qe, S, Snoise)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qe=Float64[1 2;3 4];JosephsonCircuits.calcqe!(qe,[1 2;3 4],[1 2 3;4 5 6]);qe
2×2 Matrix{Float64}:
 0.0526316  0.210526
 0.0882353  0.156863</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe!-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcqe!-Tuple{Any, Any}"><code>JosephsonCircuits.calcqe!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe!(qe, S)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis. Overwrites qe with output.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcqe-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>JosephsonCircuits.calcqe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe(S::AbstractArray)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcqe-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><code>JosephsonCircuits.calcqe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe(S::AbstractArray, Snoise::AbstractArray)</code></pre><p>Calculate the quantum efficiency matrix for a scattering matrix in the field ladder operator basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqe([3/5 4/5;4/5 3/5],[0.0 0.0;0.0 0.0])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36

julia&gt; JosephsonCircuits.calcqe(Complex{Float64}[3/5 4/5;4/5 3/5],Complex{Float64}[0.0 0.0;0.0 0.0])
2×2 Matrix{Float64}:
 0.36  0.64
 0.64  0.36</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe_S_Cnoise!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcqe_S_Cnoise!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcqe_S_Cnoise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe_S_Cnoise!(qe, S, Cnoise)</code></pre><p>Calculate the quantum efficiency matrix from the scattering parameter matrix and the noise wave covariance matrix, both in the field ladder operator (sqrt photon number) basis. Overwrites qe with output.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqe_S_Cnoise-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcqe_S_Cnoise-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><code>JosephsonCircuits.calcqe_S_Cnoise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqe_S_Cnoise(S::AbstractArray, Cnoise::AbstractArray)</code></pre><p>Calculate the noise wave covariance matrix from the scattering parameter matrix and the noise covariance matrix, both in the field ladder operator (sqrt photon number) basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = JosephsonCircuits.ABCDtoS(JosephsonCircuits.ABCD_attenuator_T(50,10));isapprox(JosephsonCircuits.calcqe_S_Cnoise(S,JosephsonCircuits.calcCnoise(S)),[0 0.1;0.1 0])
true

julia&gt; S = JosephsonCircuits.ABCDtoS(JosephsonCircuits.ABCD_attenuator_T(50,10).+0im);isapprox(JosephsonCircuits.calcqe_S_Cnoise(S,JosephsonCircuits.calcCnoise(S)),[0 0.1;0.1 0])
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqeideal!-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcqeideal!-Tuple{Any, Any}"><code>JosephsonCircuits.calcqeideal!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqeideal!(qeideal,S)</code></pre><p>See <a href="#JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>calcqeideal</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.calcqeideal-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>JosephsonCircuits.calcqeideal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcqeideal(S::AbstractArray)</code></pre><p>Calculate the ideal (best possible) quantum efficiency for each element of a scattering matrix. See also <a href="#JosephsonCircuits.calcqeideal!-Tuple{Any, Any}"><code>calcqeideal!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcqeideal([3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0

julia&gt; JosephsonCircuits.calcqeideal(Complex{Float64}[3/5 4/5;4/5 3/5])
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  1.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave, outputwave)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=[1.0 0.0;0.0 1.0];outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.707107+0.0im
 0.707107+0.0im            0.0+0.707107im

julia&gt; inputwave = rand(Complex{Float64},2,2);outputwave = rand(Complex{Float64},2,2);S=zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);isapprox(S*inputwave,outputwave)
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, LinearAlgebra.Diagonal, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, LinearAlgebra.Diagonal, Any}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave::Diagonal, outputwave)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=JosephsonCircuits.LinearAlgebra.Diagonal([1.0,1.0]);outputwave=[im/sqrt(2) 1/sqrt(2);1/sqrt(2) im/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.707107+0.0im
 0.707107+0.0im            0.0+0.707107im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Vector, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.calcscatteringmatrix!-Tuple{Any, Vector, Vector}"><code>JosephsonCircuits.calcscatteringmatrix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcscatteringmatrix!(S, inputwave::Vector, outputwave::Vector)</code></pre><p>The scattering matrix is defined as <code>outputwave = S * inputwave</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inputwave=[1.0,0.0];outputwave=[im/sqrt(2), 1/sqrt(2)];S = zeros(Complex{Float64},2,2);JosephsonCircuits.calcscatteringmatrix!(S,inputwave,outputwave);S
2×2 Matrix{ComplexF64}:
      0.0+0.707107im  0.0+0.0im
 0.707107+0.0im       0.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcsources-NTuple{10, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcsources-NTuple{10, Any}"><code>JosephsonCircuits.calcsources</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcsources(modes, sources, portindices, portnumbers, nodeindices,
    edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)</code></pre><p>Calculate the source terms in the branch basis. See also <a href="#JosephsonCircuits.addsources!-NTuple{11, Any}"><code>addsources!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">modes = [(0,), (1,)]
sources = [(mode = (0,), port = 1, current = 0.0005), (mode = (1,), port = 1, current = 1.0e-10)]
portindices = [1]
portnumbers = [1]
nodeindices = [2 2 2 2 0 2 3 4 3 3; 1 1 1 1 0 3 4 1 1 1]
edge2indexdict = Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (4, 1) =&gt; 3, (2, 1) =&gt; 1, (1, 4) =&gt; 3, (3, 4) =&gt; 4, (4, 3) =&gt; 4)
Lmean = 1.005e-9 + 0.0im
Nnodes = 4
Nbranches = 4
Nmodes = 2
JosephsonCircuits.calcsources(modes, sources, portindices, portnumbers,
    nodeindices, edge2indexdict, Lmean, Nnodes, Nbranches, Nmodes)

# output
8-element Vector{ComplexF64}:
     1526.863796602709 + 0.0im
 0.0003053727593205418 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im
                   0.0 + 0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcspicesortperms-Tuple{Dict{String, Vector{String}}}"><a class="docstring-binding" href="#JosephsonCircuits.calcspicesortperms-Tuple{Dict{String, Vector{String}}}"><code>JosephsonCircuits.calcspicesortperms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcspicesortperms(variabledict::Dict{String,Vector{String}})</code></pre><p>Calculate the sortperms which will sort the variable and node names.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcspicesortperms(Dict(&quot;V&quot; =&gt; [&quot;v(1)&quot;, &quot;v(2)&quot;, &quot;v(3)&quot;], &quot;Hz&quot; =&gt; [&quot;frequency&quot;]))
Dict{String, Vector{Int64}} with 2 entries:
  &quot;V&quot;  =&gt; [1, 2, 3]
  &quot;Hz&quot; =&gt; [1]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcvaluetype-Tuple{Vector{Symbol}, Vector, Vector{Symbol}}"><a class="docstring-binding" href="#JosephsonCircuits.calcvaluetype-Tuple{Vector{Symbol}, Vector, Vector{Symbol}}"><code>JosephsonCircuits.calcvaluetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcvaluetype(componenttypes::Vector{Symbol},componentvalues::Vector,
    components::Vector{Symbol};checkinverse::Bool=true)</code></pre><p>Returns a zero length vector with the (computer science) type which will hold a set of circuit components of the (electrical engineering) types given in <code>components</code>. This function is not type stable by design, but exists to make the later function calls type stable.</p><p><strong>Arguments</strong></p><ul><li><code>componenttypes::Vector{Symbol}</code>: the component (electrical engineering) types.</li><li><code>componentvalues::Vector</code>: the component values.</li><li><code>components::Vector{Symbol}</code>: find a (computer science) type which will   hold the component (electrical engineering) types in this vector.</li></ul><p><strong>Keywords</strong></p><ul><li><code>checkinverse = true</code>: also check the inverse of each element. This is   useful if the type would be integer but we later want to take the inverse   and want an array with a type that supports this operation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3],[:R])
Float64[]

julia&gt; JosephsonCircuits.calcvaluetype([:R,:C,:R],[1,2,3+0.0im],[:R])
ComplexF64[]

julia&gt; @variables R1 C1 R2;JosephsonCircuits.calcvaluetype([:R,:C,:R],[R1,C1,R2],[:R])
Num[]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcw!-Tuple{Any, AbstractVector, Any, AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.calcw!-Tuple{Any, AbstractVector, Any, AbstractVector}"><code>JosephsonCircuits.calcw!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcw!(ws, i, wp, w)</code></pre><p>Generate the signal and idler frequencies using the formula ws + 2<em>i</em>wp. Overwrites w with output.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.calcw-Tuple{Any, Integer, Any}"><a class="docstring-binding" href="#JosephsonCircuits.calcw-Tuple{Any, Integer, Any}"><code>JosephsonCircuits.calcw</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calcw(ws::Number, i::Integer, wp::Number)</code></pre><p>Generate the signal and idler frequencies using the formula ws + 2<em>i</em>wp.</p><p>Should I switch this to ws+i*wp so it can handle three wave mixing then  always double i for four wave mixing?</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.calcw(2*pi*4.0e9,-1,2*pi*5.0e9)/(2*pi*1.0e9)
-5.999999999999999

julia&gt; JosephsonCircuits.calcw(2*pi*4.0e9,[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)
3-element Vector{Float64}:
 -5.999999999999999
  4.0
 14.0

julia&gt; JosephsonCircuits.calcw([2*pi*4.0e9,2*pi*4.1e9],[-1,0,1],2*pi*5.0e9)/(2*pi*1.0e9)
2×3 Matrix{Float64}:
 -6.0  4.0  14.0
 -5.9  4.1  14.1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.cascadeS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.cascadeS!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>JosephsonCircuits.cascadeS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cascadeS!(S, Sa, Sb)</code></pre><p>See <a href="#JosephsonCircuits.cascadeS-Tuple{Any, Any}"><code>cascadeS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.cascadeS-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.cascadeS-Tuple{Any, Any}"><code>JosephsonCircuits.cascadeS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cascadeS(Sa, Sb)</code></pre><p>Cascade the scattering parameter matrix <code>Sa</code> with the scattering matrix <code>Sb</code> and return the combined scattering matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Sa = [0.0 0.5;0.5 0.0];Sb = [0.0 0.1;0.1 0.0];JosephsonCircuits.cascadeS(Sa,Sb)
2×2 Matrix{Float64}:
 0.0   0.05
 0.05  0.0

julia&gt; Sa=rand(Complex{Float64},2,2);Sb=rand(Complex{Float64},2,2);isapprox(JosephsonCircuits.cascadeS(Sa,Sb),JosephsonCircuits.AtoS(JosephsonCircuits.StoA(Sa)*JosephsonCircuits.StoA(Sb)))
true

julia&gt; Sa=[rand(Complex{Float64},2,2) for i in 1:10];Sb=[rand(Complex{Float64},2,2) for i in 1:10];isapprox(JosephsonCircuits.cascadeS.(Sa,Sb),JosephsonCircuits.AtoS.(JosephsonCircuits.StoA.(Sa).*JosephsonCircuits.StoA.(Sb)))
true</code></pre><p><strong>References</strong></p><p>D. J. R. Stock and L. J. Kaplan, &quot;A Comment on the Scattering Matrix of  Cascaded 2n-Ports (Correspondence),&quot; in IRE Transactions on Microwave  Theory and Techniques, vol. 9, no. 5, pp. 454-454, September 1961, doi: 10.1109/TMTT.1961.1125369 .</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.checkcomponenttypes-Tuple{Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.checkcomponenttypes-Tuple{Vector{String}}"><code>JosephsonCircuits.checkcomponenttypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkcomponenttypes(allowedcomponents::Vector{String})</code></pre><p>Check that each element in <code>allowedcomponents</code> is found at the correct place. This will detect the case where a two letter component appears in  <code>allowedcomponents</code> after a one letter component with the same starting letter. The function parsecomponenttype() will match on the first value and this function will throw an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.checkcomponenttypes([&quot;Lj&quot;,&quot;NL&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;])
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.checkissymbolic-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.checkissymbolic-Tuple{Any}"><code>JosephsonCircuits.checkissymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkissymbolic(a)</code></pre><p>Check if <code>a</code> is a symbolic variable. Define a function to do this because a different function call is required for <code>@syms</code> vs <code>@variables</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;JosephsonCircuits.checkissymbolic(w)
true

julia&gt; JosephsonCircuits.checkissymbolic(1.0)
false</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.checkissymbolic-Tuple{Num}"><a class="docstring-binding" href="#JosephsonCircuits.checkissymbolic-Tuple{Num}"><code>JosephsonCircuits.checkissymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkissymbolic(a::Num)</code></pre><p>Check if <code>a</code> is a symbolic variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;JosephsonCircuits.checkissymbolic(w)
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.comparearray-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><a class="docstring-binding" href="#JosephsonCircuits.comparearray-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T"><code>JosephsonCircuits.comparearray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">comparearray(x::AbstractArray{T},y::AbstractArray{T}) where T</code></pre><p>Compare two arrays for testing purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.comparearray([1,2],[1,2,3])
false

julia&gt; JosephsonCircuits.comparearray([1,2],[1,2,])
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.comparestruct-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.comparestruct-Tuple{Any, Any}"><code>JosephsonCircuits.comparestruct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">comparestruct(x,y)</code></pre><p>Compare two structures for testing purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.comparestruct(JosephsonCircuits.warmupnumericmatrices(),JosephsonCircuits.warmupnumericmatrices())
true

julia&gt; JosephsonCircuits.comparestruct(JosephsonCircuits.warmup(),JosephsonCircuits.warmup())
true

julia&gt; JosephsonCircuits.comparestruct(nothing,nothing)
true

julia&gt; JosephsonCircuits.compare(nothing,nothing)
true

julia&gt; cg = JosephsonCircuits.CircuitGraph(Dict((1, 2) =&gt; 1, (3, 1) =&gt; 2, (1, 3) =&gt; 2, (2, 1) =&gt; 1), JosephsonCircuits.SparseArrays.sparse([1, 2], [1, 2], [1, 1], 2, 2), [(1, 2), (1, 3)], Tuple{Int64, Int64}[], [(1, 2), (1, 3)], Vector{Int64}[], Int64[], JosephsonCircuits.Graphs.SimpleGraphs.SimpleGraph{Int64}(2, [[2, 3], [1], [1]]), 2);JosephsonCircuits.compare(cg,cg)
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.componentdictionaries-Tuple{Vector{Symbol}, Matrix{Int64}, Dict, Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.componentdictionaries-Tuple{Vector{Symbol}, Matrix{Int64}, Dict, Vector{String}}"><code>JosephsonCircuits.componentdictionaries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">componentdictionaries(componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int}, componentnamedict::Dict,
    mutualinductorbranchnames::Vector)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = parsesortcircuit(circuit)
countdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)

println(countdict)
println(indexdict)

# output
Dict((:L, 1, 3) =&gt; 1, (:K, 4, 6) =&gt; 1, (:R, 1, 2) =&gt; 1, (:I, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:L, 1, 2) =&gt; 1)
Dict((:C, 1, 3, 1) =&gt; 7, (:I, 1, 2, 1) =&gt; 2, (:R, 1, 2, 1) =&gt; 3, (:L, 1, 3, 1) =&gt; 6, (:C, 1, 3, 2) =&gt; 8, (:L, 1, 2, 1) =&gt; 4, (:P, 1, 2, 1) =&gt; 1, (:K, 4, 6, 1) =&gt; 5)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 K2 L2 C2 C3
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;,K2))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
psc = parsesortcircuit(circuit)
countdict, indexdict = JosephsonCircuits.componentdictionaries(psc.componenttypes,psc.nodeindices,psc.componentnamedict,psc.mutualinductorbranchnames)

println(countdict)
println(indexdict)

# output
Dict((:L, 1, 3) =&gt; 1, (:K, 4, 7) =&gt; 2, (:R, 1, 2) =&gt; 1, (:I, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:L, 1, 2) =&gt; 1)
Dict((:C, 1, 3, 1) =&gt; 8, (:I, 1, 2, 1) =&gt; 2, (:R, 1, 2, 1) =&gt; 3, (:K, 4, 7, 1) =&gt; 5, (:K, 4, 7, 2) =&gt; 6, (:L, 1, 2, 1) =&gt; 4, (:L, 1, 3, 1) =&gt; 7, (:P, 1, 2, 1) =&gt; 1, (:C, 1, 3, 2) =&gt; 9)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.componentvaluestonumber-Tuple{Vector, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.componentvaluestonumber-Tuple{Vector, Dict}"><code>JosephsonCircuits.componentvaluestonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">componentvaluestonumber(componentvalues::Vector,circuitdefs::Dict)</code></pre><p>Convert the array of component values to numbers, if defined in <code>circuitdefs</code>.  This function is not type stable by design because we want the output array  to use a concrete type if all of the values are evaluated to numbers. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.componentvaluestonumber([:Lj1,:Lj2],Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
2-element Vector{Float64}:
 1.0e-12
 2.0e-12

julia&gt; @variables Lj1 Lj2;JosephsonCircuits.componentvaluestonumber([Lj1,Lj1+Lj2],Dict(Lj1=&gt;1e-12,Lj2=&gt;2e-12))
2-element Vector{Float64}:
 1.0e-12
 3.0e-12</code></pre><pre><code class="language-julia hljs"># define a frequency dependent impedance function
Zfun(w,R) = ifelse(w&gt;10,R,100*R);
# create symbolic variables including a two argument function
@variables w R
@register_symbolic Zfun(w,R)
# substitute in numerical values and functions for everything but w
out=JosephsonCircuits.componentvaluestonumber([R,Zfun(w,R)],Dict(R=&gt;50));
println(out)
# evaluate with w = 2
println(JosephsonCircuits.Symbolics.value.(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=&gt;2),);fold=Val(true))))
# evaluate with w = 11
println(JosephsonCircuits.Symbolics.value.(JosephsonCircuits.Symbolics.substitute.(out,(Dict(w=&gt;11),);fold=Val(true))))

# output
Any[50, Zfun(w, 50)]
[50, 5000]
[50, 50]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.conjnegfreq!-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.conjnegfreq!-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.conjnegfreq!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conjnegfreq!(A, wmodes)</code></pre><p>Take the complex conjugate of any element of <code>A</code> which would be negative when multipled from the right by a diagonal matrix consisting of <code>wmodes</code> replicated along the diagonal. Overwrite <code>A</code> with the output.</p><p>Each axis of <code>A</code> should be an integer multiple of the length of <code>wmodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq!(A,[-1,1]);A
2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:
 1-1im  1+1im
 1-1im  1+1im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.conjnegfreq-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.conjnegfreq-Tuple{SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.conjnegfreq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conjnegfreq(A, wmodes)</code></pre><p>Take the complex conjugate of any element of <code>A</code> which would be negative when multipled from the right by a diagonal matrix consisting of <code>wmodes</code> replicated along the diagonal.</p><p>Each axis of <code>A</code> should be an integer multiple of the length of <code>wmodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1+1im,1+1im,1+1im,1+1im],2,2);JosephsonCircuits.conjnegfreq(A,[-1,1])
2×2 SparseArrays.SparseMatrixCSC{Complex{Int64}, Int64} with 4 stored entries:
 1-1im  1+1im
 1-1im  1+1im

julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1,2], [1,1,2,2], [1im,1im,1im,1im],2,2);all(A*JosephsonCircuits.LinearAlgebra.Diagonal([-1,1]) .== JosephsonCircuits.conjnegfreq(A,[-1,1]))
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.conjsym-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.conjsym-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}}} where N"><code>JosephsonCircuits.conjsym</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conjsym(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})</code></pre><p>Calculate the conjugate symmetries in the multi-dimensional frequency domain data.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,)))
Dict{CartesianIndex{1}, CartesianIndex{1}}()

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,)))
Dict{CartesianIndex{1}, CartesianIndex{1}} with 2 entries:
  CartesianIndex(2,) =&gt; CartesianIndex(5,)
  CartesianIndex(3,) =&gt; CartesianIndex(4,)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1)))
Dict{CartesianIndex{2}, CartesianIndex{2}} with 2 entries:
  CartesianIndex(1, 2) =&gt; CartesianIndex(1, 3)
  CartesianIndex(3, 2) =&gt; CartesianIndex(3, 3)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsdft((2,1)))
Dict{CartesianIndex{2}, CartesianIndex{2}} with 7 entries:
  CartesianIndex(2, 3) =&gt; CartesianIndex(5, 2)
  CartesianIndex(2, 1) =&gt; CartesianIndex(5, 1)
  CartesianIndex(3, 3) =&gt; CartesianIndex(4, 2)
  CartesianIndex(3, 1) =&gt; CartesianIndex(4, 1)
  CartesianIndex(2, 2) =&gt; CartesianIndex(5, 3)
  CartesianIndex(1, 2) =&gt; CartesianIndex(1, 3)
  CartesianIndex(3, 2) =&gt; CartesianIndex(4, 3)

julia&gt; JosephsonCircuits.conjsym(JosephsonCircuits.calcfreqsrdft((2,1,1)))
Dict{CartesianIndex{3}, CartesianIndex{3}} with 8 entries:
  CartesianIndex(1, 2, 1) =&gt; CartesianIndex(1, 3, 1)
  CartesianIndex(1, 2, 3) =&gt; CartesianIndex(1, 3, 2)
  CartesianIndex(1, 2, 2) =&gt; CartesianIndex(1, 3, 3)
  CartesianIndex(3, 2, 1) =&gt; CartesianIndex(3, 3, 1)
  CartesianIndex(1, 1, 2) =&gt; CartesianIndex(1, 1, 3)
  CartesianIndex(3, 2, 3) =&gt; CartesianIndex(3, 3, 2)
  CartesianIndex(3, 2, 2) =&gt; CartesianIndex(3, 3, 3)
  CartesianIndex(3, 1, 2) =&gt; CartesianIndex(3, 1, 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.connectS!-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, AbstractVector{&lt;:AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{&lt;:AbstractArray{Tuple{T, Int64}, 1}}, AbstractVector{N}, AbstractVector{N}}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.connectS!-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, AbstractVector{&lt;:AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{&lt;:AbstractArray{Tuple{T, Int64}, 1}}, AbstractVector{N}, AbstractVector{N}}} where {T, N}"><code>JosephsonCircuits.connectS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connectS!(g::Graphs.SimpleGraphs.SimpleDiGraph{Int},
    fconnectionlist::AbstractVector{&lt;:AbstractVector{Tuple{T,T,Int,Int}}},
    fweightlist::AbstractVector{&lt;:AbstractVector{Int}},
    ports::AbstractVector{&lt;:AbstractVector{Tuple{T,Int}}},
    networkdata::AbstractVector{N};
    nbatches::Int = Base.Threads.nthreads()) where {T,N}</code></pre><p>Return the non-empty elements of the updated <code>networkdata</code> and <code>ports</code> after applying all of the connections in the connection forward adjacency list <code>fconnectionlist</code> to the graph <code>g</code>, the forward adjacency weight list <code>fweightlist</code>, the vector of ports <code>ports</code>, and the vector of scattering parameter matrices <code>networkdata</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])];
connections = [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]];
init = JosephsonCircuits.connectS_initialize(networks, connections);
JosephsonCircuits.connectS!(init...)

# output
(S = [[0.5 0.5; 0.5 0.5]], ports = [[(&quot;S1&quot;, 2), (&quot;S2&quot;, 1)]])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.connectS-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.connectS-Tuple{Any, Any}"><code>JosephsonCircuits.connectS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connectS(networks, connections; small_splitters::Bool = true,
    nbatches::Int = Base.Threads.nthreads())</code></pre><p>Return the network and ports resulting from connecting the networks in <code>networks</code> according to the connections in <code>connections</code>. <code>networks</code> is a vector of tuples of the network name and scattering parameter matrix such as [(&quot;network1name&quot;,rand(Complex{Float64},2,2), (&quot;network2name&quot;,rand(Complex{Float64},2,2)]. <code>connections</code> is a vector of vectors of tuples of networks names and ports such as [[(&quot;network1name&quot;,1), (&quot;network2name&quot;,2)]] where network1 and network2 are the two networks being connected and 1 and 2 are integers describing the ports to connect.</p><p>This function supports connections between more than two ports by automatically adding splitters.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])];
connections = [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]];
JosephsonCircuits.connectS(networks,connections)

# output
(S = [[0.5 0.5; 0.5 0.5]], ports = [[(&quot;S1&quot;, 2), (&quot;S2&quot;, 1)]])</code></pre><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5],[(&quot;S3&quot;,5),(&quot;S3&quot;,6)])];
connections = [(&quot;S1&quot;,&quot;S3&quot;,1,6)];
JosephsonCircuits.connectS(networks,connections)

# output
(S = [[0.5 0.5; 0.5 0.5]], ports = [[(&quot;S1&quot;, 2), (&quot;S3&quot;, 5)]])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.connectS_initialize-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.connectS_initialize-Tuple{AbstractVector, AbstractVector}"><code>JosephsonCircuits.connectS_initialize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connectS_initialize(networks::AbstractVector, connections::AbstractVector;
small_splitters::Bool = true)</code></pre><p>Return a directed graph of connections between the networks.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])];
connections = [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]];
JosephsonCircuits.connectS_initialize(networks,connections)

# output
(Graphs.SimpleGraphs.SimpleDiGraph{Int64}(2, [[2], Int64[]], [Int64[], [1]]), [[(&quot;S1&quot;, &quot;S2&quot;, 1, 2)], Tuple{String, String, Int64, Int64}[]], [[1], Int64[]], [[(&quot;S1&quot;, 1), (&quot;S1&quot;, 2)], [(&quot;S2&quot;, 1), (&quot;S2&quot;, 2)]], [[0.0 1.0; 1.0 0.0], [0.5 0.5; 0.5 0.5]], [[0.0 0.0; 0.0 0.0], [0.0 0.0; 0.0 0.0]])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.connectS_initialize-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.connectS_initialize-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><code>JosephsonCircuits.connectS_initialize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connectS_initialize(networks::AbstractVector{Tuple{T,N,Vector{Tuple{T, Int}}}},
    connections::AbstractVector{Tuple{T,T,Int,Int}}) where {T,N}</code></pre><p>Return a directed graph of connections between the networks.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;, [0.0 1.0; 1.0 0.0], [(&quot;S1&quot;, 1), (&quot;S1&quot;, 2)]), (&quot;S2&quot;, [0.5 0.5; 0.5 0.5], [(&quot;S2&quot;, 1), (&quot;S2&quot;, 2)])];
connections = [(&quot;S1&quot;,&quot;S2&quot;,1,2)];
JosephsonCircuits.connectS_initialize(networks,connections)

# output
(Graphs.SimpleGraphs.SimpleDiGraph{Int64}(2, [[2], Int64[]], [Int64[], [1]]), [[(&quot;S1&quot;, &quot;S2&quot;, 1, 2)], Tuple{String, String, Int64, Int64}[]], [[1], Int64[]], [[(&quot;S1&quot;, 1), (&quot;S1&quot;, 2)], [(&quot;S2&quot;, 1), (&quot;S2&quot;, 2)]], [[0.0 1.0; 1.0 0.0], [0.5 0.5; 0.5 0.5]], [[0.0 0.0; 0.0 0.0], [0.0 0.0; 0.0 0.0]])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.coupling_to_even_odd-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.coupling_to_even_odd-Tuple{Any, Any}"><code>JosephsonCircuits.coupling_to_even_odd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coupling_to_even_odd(couplingdB, Z0)</code></pre><p>Return the even and odd mode impedances <code>Zeven</code> and <code>Zodd</code> for a directional coupler made from two coupled transmission lines with coupling in dB <code>couplingdB</code> and system characteristic impedance <code>Z0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.coupling_to_even_odd(20.0,50.0)
(Zeven = 55.27707983925667, Zodd = 45.22670168666455)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagcombine-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractArray"><a class="docstring-binding" href="#JosephsonCircuits.diagcombine-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractArray"><code>JosephsonCircuits.diagcombine</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagcombine(x::Vector{T}) where T&lt;:AbstractArray</code></pre><p>Accept a vector of abstract arrays <code>x</code> where each element is a matrix or array of scattering parameters for one mode. Returns a single matrix or array of the  multi-mode scattering parameter matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagcombine([[111 121;211 221],[112 122;212 222],[113 123;213 223]])
6×6 Matrix{Int64}:
 111    0    0  121    0    0
   0  112    0    0  122    0
   0    0  113    0    0  123
 211    0    0  221    0    0
   0  212    0    0  222    0
   0    0  213    0    0  223

julia&gt; JosephsonCircuits.diagcombine([[111 121;211 221;;;],[112 122;212 222;;;],[113 123;213 223;;;]])
6×6×1 Array{Int64, 3}:
[:, :, 1] =
 111    0    0  121    0    0
   0  112    0    0  122    0
   0    0  113    0    0  123
 211    0    0  221    0    0
   0  212    0    0  222    0
   0    0  213    0    0  223</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat!-Tuple{AbstractVecOrMat, AbstractVecOrMat, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat!-Tuple{AbstractVecOrMat, AbstractVecOrMat, Integer}"><code>JosephsonCircuits.diagrepeat!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat!(out::AbstractVecOrMat, A::AbstractVecOrMat, Nmodes::Integer)</code></pre><p>Overwrite <code>out</code> with the elements of <code>A</code> duplicated <code>Nmodes</code> times along the diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2;3 4];out = zeros(eltype(A),4,4);JosephsonCircuits.diagrepeat!(out,A,2);out
4×4 Matrix{Int64}:
 1  0  2  0
 0  1  0  2
 3  0  4  0
 0  3  0  4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat-Tuple{AbstractArray, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat-Tuple{AbstractArray, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat(A::AbstractArray, Nmodes::Integer)</code></pre><p>Return a array with each element of the first two axes of <code>A</code> duplicated along the diagonal <code>Nmodes</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat([1 2;3 4;;;],2)
4×4×1 Array{Int64, 3}:
[:, :, 1] =
 1  0  2  0
 0  1  0  2
 3  0  4  0
 0  3  0  4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat-Tuple{AbstractVecOrMat, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat-Tuple{AbstractVecOrMat, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat(A::AbstractVecOrMat, Nmodes::Integer)</code></pre><p>Return a matrix with each element of <code>A</code> duplicated along the diagonal <code>Nmodes</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat([1 2;3 4],2)
4×4 Matrix{Int64}:
 1  0  2  0
 0  1  0  2
 3  0  4  0
 0  3  0  4

julia&gt; JosephsonCircuits.diagrepeat([1,2],2)
4-element Vector{Int64}:
 1
 1
 2
 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat-Tuple{LinearAlgebra.Diagonal, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat-Tuple{LinearAlgebra.Diagonal, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat(A::Diagonal, Nmodes::Integer)</code></pre><p>Return a diagonal matrix with each element of <code>A</code> duplicated along the diagonal <code>Nmodes</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.LinearAlgebra.Diagonal([1,2]),2)
4×4 LinearAlgebra.Diagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅  ⋅
 ⋅  1  ⋅  ⋅
 ⋅  ⋅  2  ⋅
 ⋅  ⋅  ⋅  2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseMatrixCSC, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseMatrixCSC, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat(A::SparseMatrixCSC, Nmodes::Integer)</code></pre><p>Return a sparse matrix with each element of <code>A</code> duplicated along the diagonal  <code>Nmodes</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,1,2,2], [1,2,1,2], [1,2,3,4],2,2),2)
4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 1  ⋅  2  ⋅
 ⋅  1  ⋅  2
 3  ⋅  4  ⋅
 ⋅  3  ⋅  4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseVector, Integer}"><a class="docstring-binding" href="#JosephsonCircuits.diagrepeat-Tuple{SparseArrays.SparseVector, Integer}"><code>JosephsonCircuits.diagrepeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagrepeat(A::SparseVector, Nmodes::Integer)</code></pre><p>Return a sparse vector with each element of <code>A</code> duplicated along the diagonal  <code>Nmodes</code> times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparsevec([1,2],[1,2]),2)
4-element SparseArrays.SparseVector{Int64, Int64} with 4 stored entries:
  [1]  =  1
  [2]  =  1
  [3]  =  2
  [4]  =  2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.edge2index-Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}}"><a class="docstring-binding" href="#JosephsonCircuits.edge2index-Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}}"><code>JosephsonCircuits.edge2index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge2index(graph::Graphs.SimpleDiGraph{Int})</code></pre><p>Generate a dictionary where the tuple of nodes defining an edge of a graph is the key and the value is an index. The index gives the order the edge is found when iterating over the edges of the graph. The same index is used for both orderings of source and destination nodes on the edge. We don&#39;t care about the ordering of the indices as long as they are sequential and unique.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.edge2index(JosephsonCircuits.Graphs.path_digraph(4))
Dict{Tuple{Int64, Int64}, Int64} with 6 entries:
  (3, 2) =&gt; 2
  (1, 2) =&gt; 1
  (2, 1) =&gt; 1
  (3, 4) =&gt; 3
  (4, 3) =&gt; 3
  (2, 3) =&gt; 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.even_odd_to_coupling-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.even_odd_to_coupling-Tuple{Any, Any}"><code>JosephsonCircuits.even_odd_to_coupling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">even_odd_to_coupling(Zeven, Zodd)</code></pre><p>Return the coupling in dB <code>couplingdB</code> and system characteristic impedance <code>Z0</code> for a directional coupler made from two coupled transmission lines with with even and odd mode impedances <code>Zeven</code> and <code>Zodd</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.even_odd_to_coupling(55.0,45.0)
(couplingdB = 20.0, Z0 = 49.749371855331)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.even_odd_to_maxwell-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.even_odd_to_maxwell-NTuple{4, Any}"><code>JosephsonCircuits.even_odd_to_maxwell</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">even_odd_to_maxwell(Zeven, Zodd, neven, nodd)</code></pre><p>Return the inductance matrix and Maxwell capacitance matrix for two coupled transmission lines with even and odd mode impedances <code>Zeven</code>, <code>Zodd</code> and even and odd mode indices <code>neven</code>, <code>nodd</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">L1 = [1.1 0.1;0.1 1.1]
C1 = [2.0 -0.4;-0.4 2.0]
L2, C2 = JosephsonCircuits.even_odd_to_maxwell(JosephsonCircuits.maxwell_to_even_odd(L1,C1)...)
isapprox(L1,L2) &amp;&amp; isapprox(C1,C2)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.even_odd_to_mutual-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.even_odd_to_mutual-NTuple{4, Any}"><code>JosephsonCircuits.even_odd_to_mutual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">even_odd_to_mutual(Zeven, Zodd, neven, nodd)</code></pre><p>Return the inductance matrix and mutual capacitance matrix for two coupled transmission lines with even and odd mode impedances <code>Zeven</code>, <code>Zodd</code> and even and odd mode indices <code>neven</code>, <code>nodd</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">L1 = [1.1 0.1;0.1 1.1]
C1 = [1.6 0.4;0.4 1.6]
L2, C2 = JosephsonCircuits.even_odd_to_mutual(JosephsonCircuits.mutual_to_even_odd(L1,C1)...)
isapprox(L1,L2) &amp;&amp; isapprox(C1,C2)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.export_netlist!-Tuple{IO, AbstractVector, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.export_netlist!-Tuple{IO, AbstractVector, Dict}"><code>JosephsonCircuits.export_netlist!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_netlist!(io::IO, circuit, circuitdefs)</code></pre><p>Export the netlist in <code>circuit</code> to the IOBuffer or IOStream <code>io</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();JosephsonCircuits.export_netlist!(io, [(&quot;P&quot;,&quot;1&quot;,&quot;0&quot;,1),(&quot;R&quot;,&quot;1&quot;,&quot;0&quot;,50.0)],Dict());println(String(take!(io)))
P 1 0 1
R 1 0 50.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.export_netlist-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.export_netlist-Tuple{Any, Any, Any}"><code>JosephsonCircuits.export_netlist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_netlist(filename, circuit, circuitdefs)</code></pre><p>Export the netlist in <code>circuit</code> to the file with name and path <code>filename</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.export_netlist-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.export_netlist-Tuple{Any, Any}"><code>JosephsonCircuits.export_netlist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_netlist(filename, circuit)</code></pre><p>Export the netlist in <code>circuit</code> to the file with name and path <code>filename</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.exportnetlist-Tuple{Vector, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.exportnetlist-Tuple{Vector, Dict}"><code>JosephsonCircuits.exportnetlist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">exportnetlist(circuit::Vector,circuitdefs::Dict,port::Int = true,
    jj::Bool = true)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables R Cc Lj Cj I
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc),
    (&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj)]

circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    R =&gt; 50.0)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 674.18508376f
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
Lj1 2 0 1000.0000000000001p
C2 2 0 1000.0f</code></pre><pre><code class="language-julia hljs">@variables R Cc L1 L2 Cj1 Cj2 I1 V1
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc),
    (&quot;L1&quot;,&quot;2&quot;,&quot;0&quot;,L1),
    (&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj1),
    (&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,Cj2),
    (&quot;I1&quot;,&quot;2&quot;,&quot;0&quot;,I1)]

circuitdefs = Dict(
    L1 =&gt;2000.0e-12,
    L2 =&gt;2000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj1 =&gt; 500.0e-15,
    Cj2 =&gt; 500.0e-15,
    R =&gt; 50.0,
    I1 =&gt;0.1)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
L1 2 0 1000.0000000000001p
C2 2 0 1000.0f

* SPICE Simulation
R1 1 0 50.0
C1 1 2 100.0f
L1 2 0 1000.0000000000001p
C2 2 0 1000.0f</code></pre><pre><code class="language-julia hljs">@variables Rleft L1 K1 L2 C2 C3 Lj1
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
circuitdefs = Dict(
    Rleft =&gt; 50.0,
    L1 =&gt; 1000.0e-12,
    Lj1 =&gt; 1000.0e-12,
    K1 =&gt; 0.1,
    L2 =&gt; 1000.0e-12,
    C2 =&gt; 1000.0e-15,
    C3 =&gt; 1000.0e-15)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 1674.18508376f
K1 L1 L2 0.1
L2 2 0 1000.0000000000001p
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
Lj1 2 0 1000.0000000000001p
K1 L1 L2 0.1
L2 2 0 1000.0000000000001p
C2 2 0 2000.0f</code></pre><pre><code class="language-julia hljs">@variables Rleft L1 K1 L2 C2 C3 Lj1
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj1))
push!(circuit,(&quot;K1&quot;,&quot;L2&quot;,&quot;L1&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
push!(circuit,(&quot;C3&quot;,&quot;2&quot;,&quot;0&quot;,C3))
circuitdefs = Dict(
    Rleft =&gt; 50.0,
    L1 =&gt; 1000.0e-12,
    Lj1 =&gt; 1000.0e-12,
    K1 =&gt; 0.1,
    L2 =&gt; 1000.0e-12,
    C2 =&gt; 1000.0e-15,
    C3 =&gt; 1000.0e-15)

println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = true).netlist)
println(&quot;&quot;)
println(JosephsonCircuits.exportnetlist(circuit, circuitdefs;port = 1, jj = false).netlist)

# output
* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
B1 2 0 3 jjk ics=0.32910597599999997u
C2 2 0 1674.18508376f
K1 L2 L1 0.1
L2 2 0 1000.0000000000001p
.model jjk jj(rtype=0,cct=1,icrit=0.32910597599999997u,cap=325.81491624f,force=1,vm=9.9

* SPICE Simulation
R1 1 0 50.0
L1 1 0 1000.0000000000001p
Lj1 2 0 1000.0000000000001p
K1 L2 L1 0.1
L2 2 0 1000.0000000000001p
C2 2 0 2000.0f</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.extractbranches!-Tuple{Vector, Vector{Symbol}, Matrix{Int64}}"><a class="docstring-binding" href="#JosephsonCircuits.extractbranches!-Tuple{Vector, Vector{Symbol}, Matrix{Int64}}"><code>JosephsonCircuits.extractbranches!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extractbranches!(branchvector::Vector,componenttypes::Vector{Symbol},
    nodeindexarray::Matrix{Int})</code></pre><p>Append tuples consisting of a pair of node indices (branches) which we will use to calculate the incidence matrix. Appends the tuples to branchvector.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}"><a class="docstring-binding" href="#JosephsonCircuits.extractbranches-Tuple{Vector{Symbol}, Matrix{Int64}}"><code>JosephsonCircuits.extractbranches</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extractbranches(componenttypes::Vector{Symbol},nodeindexarray::Matrix{Int})</code></pre><p>Return an array of tuples of pairs of node indices (branches) which we will use to calculate the incidence matrix.</p><p>This will contain duplicates if multiple components are on the same branch. All checking for duplicate branches will occur in the graph procesing code.</p><p>NOTE: the list of component types considered to lie on branches is hardcoded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.extractbranches([:P,:I,:R,:C,:Lj,:C],[2 2 2 2 3 3; 1 1 1 3 1 1])
3-element Vector{Tuple{Int64, Int64}}:
 (2, 1)
 (2, 1)
 (3, 1)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.find_duplicate_connections-Union{Tuple{AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.find_duplicate_connections-Union{Tuple{AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, Tuple{T}} where T"><code>JosephsonCircuits.find_duplicate_connections</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_duplicate_connections(
    connections::AbstractVector{Tuple{T,T,Int,Int}}) where {T}</code></pre><p>Return a vector of tuples of (connection, counts) where counts is the number of times a given connection appears.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.find_duplicate_network_names-Union{Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.find_duplicate_network_names-Union{Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}"><code>JosephsonCircuits.find_duplicate_network_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_duplicate_network_names(
    networks::AbstractVector{Tuple{T,N,Vector{Tuple{T, Int}}}}) where {T,N}</code></pre><p>Return a vector of tuples of (networkname, counts) where counts is the number of times a given network name appears.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.findgroundnodeindex-Tuple{Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.findgroundnodeindex-Tuple{Vector{String}}"><code>JosephsonCircuits.findgroundnodeindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">findgroundnodeindex(uniquenodevector::Vector{String})</code></pre><p>Find the index of the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.findgroundnodeindex([&quot;1&quot;,&quot;0&quot;,&quot;2&quot;])
2

julia&gt; JosephsonCircuits.findgroundnodeindex([&quot;1&quot;,&quot;2&quot;])
0

julia&gt; JosephsonCircuits.findgroundnodeindex(String[])
0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}"><a class="docstring-binding" href="#JosephsonCircuits.fourierindices-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.fourierindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fourierindices(freq::Frequencies)</code></pre><p>Generate the indices used in the RDFT or DFT and inverse RDFT or DFT and converting between a node flux vector for solving system and the matrices for the Fourier analysis. See also <a href="#JosephsonCircuits.FourierIndices"><code>FourierIndices</code></a>, <a href="#JosephsonCircuits.Frequencies"><code>Frequencies</code></a>, <a href="#JosephsonCircuits.calcfreqsrdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsrdft</code></a> and <a href="#JosephsonCircuits.calcfreqsdft-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>calcfreqsdft</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.freqsubst-Tuple{SparseArrays.SparseMatrixCSC, Vector, Any}"><a class="docstring-binding" href="#JosephsonCircuits.freqsubst-Tuple{SparseArrays.SparseMatrixCSC, Vector, Any}"><code>JosephsonCircuits.freqsubst</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">freqsubst(A::SparseMatrixCSC, wmodes::Vector, symfreqvar)</code></pre><p>Substitute the frequency dependent elements of <code>A</code> using the vector of mode frequencies <code>wmodes</code> and the symbolic frequency variable <code>symfreqvar</code>. Returns a sparse matrix with type <code>Complex{Float64}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables w
wmodes = [-1,2];
A = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,2*w,3*w],2,2),2);
JosephsonCircuits.freqsubst(A,wmodes,w)

# output
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:
 -1.0+0.0im      ⋅      -3.0+0.0im      ⋅    
      ⋅      2.0+0.0im       ⋅      6.0+0.0im
      ⋅          ⋅      -2.0+0.0im      ⋅    
      ⋅          ⋅           ⋅      4.0+0.0im</code></pre><pre><code class="language-julia hljs">wmodes = [-1,2];
A = JosephsonCircuits.diagrepeat(JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,3],2,2),2);
JosephsonCircuits.freqsubst(A,wmodes,nothing)

# output
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:
 1.0+0.0im      ⋅      3.0+0.0im      ⋅    
     ⋅      1.0+0.0im      ⋅      3.0+0.0im
     ⋅          ⋅      2.0+0.0im      ⋅    
     ⋅          ⋅          ⋅      2.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.get_ports-Union{Tuple{Tuple{T, N, Array{Tuple{T, Int64}, 1}}}, Tuple{N}, Tuple{T}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.get_ports-Union{Tuple{Tuple{T, N, Array{Tuple{T, Int64}, 1}}}, Tuple{N}, Tuple{T}} where {T, N}"><code>JosephsonCircuits.get_ports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ports(network::Tuple{T, N, Vector{Tuple{T, Int}}}) where {T,N}</code></pre><p>Return the ports for a network <code>network</code>. The ports are already present in the network.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.get_ports((:S1,[0.0 1.0;1.0 0.0],[(:S1,1),(:S2,3)]))
2-element Vector{Tuple{Symbol, Int64}}:
 (:S1, 1)
 (:S2, 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.get_ports-Union{Tuple{Tuple{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.get_ports-Union{Tuple{Tuple{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>JosephsonCircuits.get_ports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ports(network::Tuple{T, N}) where {T,N}</code></pre><p>Return the ports for a network <code>network</code>. The ports are generated based on the network name.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.get_ports((:S1,[0.0 1.0;1.0 0.0]))
2-element Vector{Tuple{Symbol, Int64}}:
 (:S1, 1)
 (:S1, 2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><a class="docstring-binding" href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>JosephsonCircuits.hblinsolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hblinsolve(w, circuit,circuitdefs; Nmodulationharmonics = (0,),
    nonlinear=nothing, symfreqvar=nothing, threewavemixing=false,
    fourwavemixing=true, maxintermodorder=Inf,
    nbatches::Integer = Base.Threads.nthreads(), returnS = true,
    returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnnodefluxadjoint = false,
    returnvoltage = false,
    )</code></pre><p>Harmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around <code>nonlinear</code>, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones) from <code>hbnlsolve</code>.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: the small signal frequency or frequencies.</li><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.</li><li><code>circuitdefs</code>: a dictionary where the keys are symbols or symbolic   variables for component values and the values are the numerical values   for the components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>Nmodulationharmonics::NTuple{M,Int}</code>: a tuple of integers describing how   many signal and idler modes.</li><li><code>nonlinear=nothing</code>: solution to the nonlinear system from <code>hbnlsolve</code>.</li><li><code>symfreqvar = nothing</code>: the symbolic frequency variable, eg <code>w</code>.</li><li><code>threewavemixing = false</code>: simulate three wave mixing processes. </li><li><code>fourwavemixing = true</code>: simulate four wave mixing processes.</li><li><code>maxintermodorder=Inf</code>: the maximum intermod order as defined by the sum of   the absolute values of the integers multiplying each of the frequencies   being less than or equal to <code>maxintermodorder</code>. This performs a diamond   truncation of the discrete Fourier space.</li><li><code>nbatches = Base.Threads.nthreads()</code>: the number of batches to split the   signal frequencies into for multi-threading. Set to 1 for singled threaded   evaluation.</li><li><code>sorting = :number</code>: sort the nodes by:   <code>:name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.   <code>:number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).   <code>:none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li><li><code>returnS = true</code>: return the scattering parameters from the linearized   simulations.</li><li><code>returnSnoise = false</code>: return the noise scattering parameters from the   linearized simulations.</li><li><code>returnQE = true</code>: return the quantum efficiency from the linearized   simulations.</li><li><code>returnCM = true</code>: return the commutation relations from the linearized   simulations.</li><li><code>returnnodeflux = false</code>: return the node fluxes from the linearized   simulations.</li><li><code>returnvoltage = false</code>: return the node voltages from the linearized   simulations.</li><li><code>returnnodefluxadjoint = false</code>: return the node fluxes from the linearized   adjoint simulations.</li><li><code>returnvoltageadjoint = false</code>: return the node voltages from the linearized   adjoint simulations.</li><li><code>keyedarrays::Val{K} = Val(true)</code>: when Val(true) return the output matrices   and vectors as keyed arrays for more intuitive indexing. When Val(false)   return normal matrices and vectors.</li><li><code>sensitivitynames::Vector{String} = String[]</code>: the component names for which   to return the sensitivities (in progress).</li><li><code>returnSsensitivity = false</code>: return the scattering parameter sensitivity   matrix from the linearized simulations (in progress).</li><li><code>returnZ = false</code>: return the impedance matrix from the linearized   simulations.</li><li><code>returnZadjoint = false</code>: return the impedance matrix from the linearized   adjoint simulations.</li><li><code>returnZsensitivity = false</code>: return the Z parameter sensitivity   matrix from the linearized simulations (in progress).</li><li><code>returnZsensitivityadjoint = false</code>: return the Z parameter sensitivity   matrix from the linearized adjoint simulations (in progress).</li><li><code>factorization = KLUfactorization()</code>: the type of factorization to use for   the nonlinear and the linearized simulations.</li></ul><p><strong>Returns</strong></p><ul><li><code>LinearizedHB</code>: A simple structure to hold the harmonic balance solutions.   See <a href="#JosephsonCircuits.LinearizedHB"><code>LinearizedHB</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 1e-6*0
Ip=5.0e-6
wp=2*pi*5e9
ws=2*pi*5.2e9
symfreqvar = nothing

# modulation settings
Npumpharmonics = (16,)
Nmodulationharmonics = (2,)
threewavemixing=false
fourwavemixing=true

nonlinear=hbnlsolve(
    (wp,),
    Npumpharmonics,
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    circuit,circuitdefs;dc=true,odd=fourwavemixing,even=threewavemixing)

linearized = JosephsonCircuits.hblinsolve(ws,
    circuit, circuitdefs; Nmodulationharmonics = Nmodulationharmonics,
    nonlinear = nonlinear, symfreqvar=nothing, threewavemixing=false,
    fourwavemixing=true, returnnodeflux=true, keyedarrays = Val(false))
isapprox(linearized.nodeflux,
    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],
    atol = 1e-6)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{N}, Tuple{Any, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, Any, JosephsonCircuits.Frequencies{N}}} where {N, K}"><a class="docstring-binding" href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{N}, Tuple{Any, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, Any, JosephsonCircuits.Frequencies{N}}} where {N, K}"><code>JosephsonCircuits.hblinsolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hblinsolve(w, psc::ParsedSortedCircuit,
    cg::CircuitGraph, circuitdefs, signalfreq::Frequencies{N};
    nonlinear=nothing, symfreqvar=nothing,
    nbatches::Integer = Base.Threads.nthreads(), sorting = :number,
    returnS = true, returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnnodefluxadjoint = false,
    returnvoltage = false,
    )</code></pre><p>Harmonic balance solver supporting an arbitrary number of small signals (weak tones) linearized around <code>pump</code>, the solution of the nonlinear system consisting of an arbitrary number of large signals (strong tones).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 1e-6*0
Ip = 5.0e-6
wp = 2*pi*5e9
ws = 2*pi*5.2e9
Npumpharmonics = (2,)
Nmodulationharmonics = (2,)
threewavemixing = false
fourwavemixing = true

frequencies = JosephsonCircuits.removeconjfreqs(
    JosephsonCircuits.truncfreqs(
        JosephsonCircuits.calcfreqsrdft(Npumpharmonics),
        dc = true, odd = true, even = false, maxintermodorder = Inf,
    )
)
fi = JosephsonCircuits.fourierindices(frequencies)
Nmodes = length(frequencies.modes)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
nm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)
nonlinear = hbnlsolve(
    (wp,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    frequencies, fi, psc, cg, nm)
signalfreq =JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsdft(Nmodulationharmonics),
    dc = true, odd = threewavemixing, even = fourwavemixing,
    maxintermodorder = Inf,
)
linearized = JosephsonCircuits.hblinsolve(ws, psc, cg, circuitdefs,
    signalfreq;nonlinear = nonlinear, returnnodeflux=true, keyedarrays = Val(false))
isapprox(linearized.nodeflux,
    ComplexF64[9.901008591291e-12 - 6.40587007644028e-14im 2.164688307719963e-14 - 2.90852607344097e-16im 6.671563044645655e-14 - 8.585524364135119e-16im; 2.1633104519765224e-14 - 8.251861334047893e-16im 1.0099063486905209e-11 - 1.948847859339803e-13im -8.532003011745068e-15 + 3.234788465760295e-16im; 6.671648606599472e-14 + 7.892709980649199e-16im -8.53757633177974e-15 - 9.748395563374129e-17im 9.856580758892428e-12 + 5.859984004390703e-14im; 1.5888896262186103e-11 - 1.0303480614499543e-13im -2.557126237504446e-12 + 1.759201163407723e-14im -8.475819811683215e-12 + 5.3531443609574795e-14im; -2.5781681021577177e-13 + 4.757590640631487e-15im 2.36818731889176e-12 - 4.569646499606389e-14im 1.116372367616482e-13 - 2.039935997276492e-15im; -1.0210743447568219e-11 - 5.905490368441375e-14im 1.3377918536056493e-12 + 7.190105205618706e-15im 2.5392856657302323e-11 + 1.5143842454586225e-13im; 2.4781693042536835e-11 - 1.6057018472176702e-13im -2.5342360504077476e-12 + 1.7306764301173096e-14im -8.40554044664581e-12 + 5.269404591748149e-14im; -2.348528974341763e-13 + 3.949450668269274e-15im 1.1449271118157543e-11 - 2.2093702114766968e-13im 1.0261871618968225e-13 - 1.7240213938923877e-15im; -1.0140560031409567e-11 - 5.828587508192886e-14im 1.3288225860409326e-12 + 7.0954601524623594e-15im 3.423954321087654e-11 + 2.0403371894291513e-13im],
    atol = 1e-6)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hblinsolve_inner!-NTuple{41, Any}"><a class="docstring-binding" href="#JosephsonCircuits.hblinsolve_inner!-NTuple{41, Any}"><code>JosephsonCircuits.hblinsolve_inner!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hblinsolve_inner!(S, Snoise, QE, CM, nodeflux, voltage, Asparse,
    AoLjnm, invLnm, Cnm, Gnm, bnm,
    AoLjnmindexmap, invLnmindexmap, Cnmindexmap, Gnmindexmap,
    Cnmfreqsubstindices, Gnmfreqsubstindices, invLnmfreqsubstindices,
    portindices, portimpedanceindices, noiseportimpedanceindices,
    portimpedances, noiseportimpedances, nodeindices, componenttypes,
    w, indices, wp, Nmodes, Nnodes, symfreqvar, wi, factorization)</code></pre><p>Solve the linearized harmonic balance problem for a subset of the frequencies given by <code>wi</code>. This function is thread safe in that different frequencies can be computed in parallel on separate threads.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><a class="docstring-binding" href="#JosephsonCircuits.hblinsolveold-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>JosephsonCircuits.hblinsolveold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hblinsolveold(w, circuit, circuitdefs; wp = 0.0, Nmodes = 1,
    Am = zeros(Complex{Float64},0,0), symfreqvar = nothing,
    nbatches = Base.Threads.nthreads(), sorting = :number, returnS = true,
    returnSnoise = false, returnQE = true, returnCM = true,
    returnnodeflux = false, returnvoltage = false)</code></pre><p>Linearized harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p>Returns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: signal frequency or vector of signal frequencies in radians/second.</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values. </li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>wp = 0.0</code>: pump frequency in radians/second. This function only supports a   single pump frequency.</li><li><code>Nmodes = 1</code>: number of signal and idler modes.</li><li><code>Am = zeros(Complex{Float64},0,0)</code>: </li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to <code>nothing</code>   by default but should be set equal to the frequency variable like <code>w</code> if    there is frequency dependence.</li><li><code>nbatches = Base.Threads.nthreads()</code>: for the linearized harmonic balance   solution, split the solutions for different frequencies into this many   batches. Set equal to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. </li><li><code>sorting = :number</code>: sort the ports by turning them into integers and   sorting those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this   fails.</li><li><code>returnS = true</code>: if <code>true</code>, return the scattering parameters for each set   of ports and signal and idler frequencies.</li><li><code>returnSnoise = false</code>: if <code>true</code>, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. </li><li><code>returnQE = true</code>: if <code>true</code>, return the quantum efficiency for each signal   and idler at each combinaton of ports.</li><li><code>returnCM = true</code>: if <code>true</code>, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).</li><li><code>returnnodeflux = false</code>: if <code>true</code>, return the node fluxes for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li><li><code>returnnodefluxadjoint = false</code>: if <code>true</code>, return the node fluxes adjoint   for each signal and idler at each node. Set to <code>false</code> by default to   reduce memory usage.</li><li><code>returnvoltage = false</code>: if <code>true</code>, return the node voltages for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
w = 2*pi*(4.5:0.01:5.0)*1e9
result=JosephsonCircuits.hblinsolveold(w, circuit, circuitdefs)
using Plots;plot(w/(2*pi*1e9),angle.(result.S[:]))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbmatind-Union{Tuple{JosephsonCircuits.Frequencies{N}}, Tuple{N}} where N"><a class="docstring-binding" href="#JosephsonCircuits.hbmatind-Union{Tuple{JosephsonCircuits.Frequencies{N}}, Tuple{N}} where N"><code>JosephsonCircuits.hbmatind</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbmatind(truncfrequencies::Frequencies{N})</code></pre><p>Returns a matrix describing which indices of the frequency domain matrix (from the RFFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; freq = JosephsonCircuits.calcfreqsrdft((5,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=false,odd=true,even=false,maxintermodorder=2)))[2]
3×3 Matrix{Int64}:
 1  -3  -5
 3   1  -3
 5   3   1

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((3,));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]
4×4 Matrix{Int64}:
 1  -2  -3  -4
 2   1  -2  -3
 3   2   1  -2
 4   3   2   1

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[1]
7×7 Matrix{Tuple{Int64, Int64}}:
 (0, 0)   (-1, 0)  (-2, 0)   (0, -1)  (-1, -1)  (0, -2)  (-1, 1)
 (1, 0)   (0, 0)   (-1, 0)   (1, -1)  (0, -1)   (1, -2)  (0, 1)
 (2, 0)   (1, 0)   (0, 0)    (2, -1)  (1, -1)   (2, -2)  (1, 1)
 (0, 1)   (-1, 1)  (-2, 1)   (0, 0)   (-1, 0)   (0, -1)  (-1, 2)
 (1, 1)   (0, 1)   (-1, 1)   (1, 0)   (0, 0)    (1, -1)  (0, 2)
 (0, 2)   (-1, 2)  (-2, 2)   (0, 1)   (-1, 1)   (0, 0)   (-1, 3)
 (1, -1)  (0, -1)  (-1, -1)  (1, -2)  (0, -2)   (1, -3)  (0, 0)

julia&gt; freq = JosephsonCircuits.calcfreqsrdft((2,2));JosephsonCircuits.hbmatind(JosephsonCircuits.removeconjfreqs(JosephsonCircuits.truncfreqs(freq;dc=true,odd=true,even=true,maxintermodorder=2)))[2]
7×7 Matrix{Int64}:
  1   -2   -3  13   -5  10  -14
  2    1   -2  14   13  11    4
  3    2    1  15   14  12    5
  4  -14  -15   1   -2  13  -11
  5    4  -14   2    1  14    7
  7  -11  -12   4  -14   1    0
 14   13   -5  11   10   0    1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbmatind-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, JosephsonCircuits.Frequencies{N}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.hbmatind-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, JosephsonCircuits.Frequencies{N}}} where N"><code>JosephsonCircuits.hbmatind</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbmatind(frequencies::Frequencies{N},
    truncfrequencies::Frequencies{N})</code></pre><p>Returns a matrix describing which indices of the frequency domain matrix (from the RFFT or FFT) to pull out and use in the harmonic balance matrix. A negative index means we take the complex conjugate of that element. A zero index means that term is not present, so skip it. The harmonic balance matrix describes the coupling between different frequency modes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pumpfreq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((4,)))
signalfreq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsdft((4,));
    dc=false,odd=true,even=false,maxintermodorder=2,
)
JosephsonCircuits.hbmatind(pumpfreq, signalfreq)[2]

# output
4×4 Matrix{Int64}:
  1  -3  5   3
  3   1  0   5
 -5   0  1  -3
 -3  -5  3   1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><a class="docstring-binding" href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><code>JosephsonCircuits.hbnlsolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbnlsolve(w::NTuple{N,Number}, sources, frequencies::Frequencies{N},
    indices::FourierIndices{N}, psc::ParsedSortedCircuit, cg::CircuitGraph,
    nm::CircuitMatrices; iterations = 1000, x0 = nothing,
    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,
    symfreqvar = nothing)</code></pre><p>New version of the nonlinear harmonic balance solver suitable for arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 50e-5
Ip=0.0001e-6
wp=2*pi*5e9
Nharmonics = (2,)
frequencies = JosephsonCircuits.removeconjfreqs(
    JosephsonCircuits.truncfreqs(
        JosephsonCircuits.calcfreqsrdft(Nharmonics),
        dc=true, odd=true, even=false, maxintermodorder=Inf,
    )
)
fi = JosephsonCircuits.fourierindices(frequencies)
Nmodes = length(frequencies.modes)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
nm = JosephsonCircuits.numericmatrices(psc, cg, circuitdefs, Nmodes = Nmodes)

out=hbnlsolve(
    (wp,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    frequencies, fi, psc, cg, nm)
isapprox(out.nodeflux[:],
    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],
    atol = 1e-6)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, NTuple{N, Int64}, Any, Any, Any}} where {N, K}"><a class="docstring-binding" href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, NTuple{N, Int64}, Any, Any, Any}} where {N, K}"><code>JosephsonCircuits.hbnlsolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbnlsolve(w::NTuple{N,Number}, Nharmonics::NTuple{N,Int}, sources,
    circuit, circuitdefs; iterations = 1000,
    maxintermodorder = Inf, dc = false, odd = true, even = false,
    x0 = nothing, ftol = 1e-8, switchofflinesearchtol = 1e-5,
    alphamin = 1e-4, symfreqvar = nothing, sorting= :number)</code></pre><p>Harmonic balance solver supporting an arbitrary number of large signals (strong tones or pumps) and arbitrary numbers of ports, sources, and drives including direct current (zero frequency) or flux pumping using a current source and a mutual inductor. Use <code>hblinsolve</code> to linearize the system of equations about the operating point found with <code>hbnlsolve</code>.</p><p><strong>Arguments</strong></p><ul><li><code>w::NTuple{N,Number}</code>: a tuple containing the angular frequencies of the   strong tones (or pumps) such as (2*pi*5.0e9,) for a single tone at 5   GHz and (2*pi*5.0e9,2*pi*6.0e9) for a tone at 5 GHz and a tone at   6 GHz. The frequencies should be non-commensurate. For commensurate   frequencies, the lowest frequency should be provided here, and the other   added to <code>sources</code> with a mode index equal to the ratio.</li><li><code>Nharmonics::NTuple{N,Int}</code>: a tuple of integers describing how many   harmonics to simulate for each of the tones. The length of the tuple must   equal the number of non-commensurate tones.</li><li><code>sources::Vector</code>: a vector of named tuples specifying the mode index,   port, and current for each source. The named tuple(s) have names   mode, port, and current. mode is a tuple specifying the mode or harmonic   indices of the pumps, port is an integer specifying the port, and current   is a number specifying the current. Note that the current is a complex   number    For example:   [(mode=(1,0),port=1,current=Ip1),(mode=(0,1),port=1,current=Ip2)]   specifies two pumps where the frequency of the first pump would be   1*wp1 + 0*wp2 and the second 0*wp1+1*wp2 where wp1 is the first   pump frequency and wp2 is the second pump frequency. Both of the pumps are   applied to port 1 with currents Ip1 and Ip2, respectively. </li><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.</li><li><code>circuitdefs</code>: a dictionary where the keys are symbols or symbolic   variables for component values and the values are the numerical values   for the components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>iterations = 1000</code>: the number of iterations before the nonlinear solver   returns an error.</li><li><code>maxintermodorder = Inf</code>: the maximum intermod order as defined by the sum of   the absolute values of the integers multiplying each of the frequencies   being less than or equal to <code>maxintermodorder</code>. This performs a diamond   truncation of the discrete Fourier space.</li><li><code>dc = false</code>: include 0 frequency terms in the harmonic balance analysis.</li><li><code>odd = true</code>: include odd terms in the harmonic balance analysis.</li><li><code>even = false</code>: include even terms in the harmonic balance analysis.</li><li><code>x0 = nothing</code>: initial value for the nodeflux.</li><li><code>ftol = 1e-8</code>: the function tolerance defined we considered converged,   defined as norm(F)/norm(x) &lt; ftol or norm(F,Inf) &lt;= ftol.</li><li><code>switchofflinesearchtol = 1e-5</code>:</li><li><code>alphamin = 1e-4</code>: the function tolerance at which we switch   from Newton with linesearch to only Newton. For easily converging   functions, setting this to zero can speed up simulations.</li><li><code>symfreqvar = nothing</code>: the symbolic frequency variable, eg <code>w</code>.</li><li><code>sorting = :number</code>: sort the nodes by:   <code>:name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.   <code>:number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).   <code>:none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>NonlinearHB</code>: A simple structure to hold the harmonic balance solutions.   See <a href="#JosephsonCircuits.NonlinearHB"><code>NonlinearHB</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">circuit = Tuple{String,String,String,Union{Complex{Float64},Symbol,Int64}}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:Lm)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc)) 
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;3&quot;,:Lm)) 
push!(circuit,(&quot;Lj3&quot;,&quot;3&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;Lj4&quot;,&quot;2&quot;,&quot;0&quot;,:Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
circuitdefs = Dict{Symbol,Complex{Float64}}(
    :Lj =&gt;2000e-12,
    :Lm =&gt;10e-12,
    :Cc =&gt; 200.0e-15,
    :Cj =&gt; 900e-15,
    :Rleft =&gt; 50.0,
    :Rright =&gt; 50.0,
    :K1 =&gt; 0.9,
)

Idc = 50e-5
Ip=0.0001e-6
wp=2*pi*5e9
Npumpmodes = 2
out=hbnlsolve(
    (wp,),
    (Npumpmodes,),
    [
        (mode=(0,),port=1,current=Idc),
        (mode=(1,),port=1,current=Ip),
    ],
    circuit,circuitdefs;dc=true,odd=true,even=false)
isapprox(out.nodeflux[:],
    ComplexF64[15.190314040027522 - 8.56492651167657e-24im, 2.991103820177504e-6 - 1.8501001011477133e-8im, -6.835392148510984 - 1.0356102442254259e-14im, 7.396422335315908e-6 - 4.5749403967992827e-8im, 6.835392148539885 - 1.0356102451770844e-14im, 1.008026285172782e-5 - 6.23498762664213e-8im],
    atol = 1e-6)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbnlsolveold-Union{Tuple{K}, NTuple{5, Any}} where K"><a class="docstring-binding" href="#JosephsonCircuits.hbnlsolveold-Union{Tuple{K}, NTuple{5, Any}} where K"><code>JosephsonCircuits.hbnlsolveold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbnlsolveold(wp, Ip, Nmodes, circuit, circuitdefs; ports = [1],
    iterations = 1000, ftol = 1e-8, symfreqvar = nothing,
    sorting = :number)</code></pre><p>Nonlinear harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p><strong>Arguments</strong></p><ul><li><code>wp</code>: pump frequency in radians/second. This function only supports a single   pump frequency.</li><li><code>Ip</code>: pump current or vector of pump currents in amps. Length of <code>Ip</code> must   be equal to length of <code>ports</code>.</li><li><code>Nmodes</code>: number of modes (harmonics).</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values.</li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>ports = [1]</code>: vector of drive port numbers. Default is a single drive at port 1.</li><li><code>iterations = 1000</code>: number of iterations at which the nonlinear solver stops   even if convergence criteria not reached.</li><li><code>ftol = 1e-8</code>: relative or absolute tolerance at which nonlinear solver stops   (whichever is reached first).</li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to <code>nothing</code>   by default but should be set equal to the frequency variable like <code>w</code> if   there is frequency dependence.</li><li><code>sorting = :number</code>: sort the ports by turning them into integers and sorting   those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this fails.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
wp = 2*pi*4.75001*1e9
Ip = 0.00565e-6
Nmodes = 8
hbnlsolve(wp, Ip, Nmodes, circuit, circuitdefs, ports=[1])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{M}, Tuple{N}, Tuple{Any, NTuple{N, Number}, Vector, NTuple{M, Int64}, NTuple{N, Int64}, Any, Any}} where {N, M, K}"><a class="docstring-binding" href="#JosephsonCircuits.hbsolve-Union{Tuple{K}, Tuple{M}, Tuple{N}, Tuple{Any, NTuple{N, Number}, Vector, NTuple{M, Int64}, NTuple{N, Int64}, Any, Any}} where {N, M, K}"><code>JosephsonCircuits.hbsolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbsolve(ws, wp::NTuple{N,Number}, sources::Vector,
    Nmodulationharmonics::NTuple{M,Int}, Npumpharmonics::NTuple{N,Int},
    circuit, circuitdefs;dc = false, threewavemixing = false,
    fourwavemixing = true, maxintermodorder=Inf, iterations = 1000,
    ftol = 1e-8, switchofflinesearchtol = 1e-5, alphamin = 1e-4,
    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),
    sorting = :number, returnS = true, returnSnoise = false, returnQE = true,
    returnCM = true, returnnodeflux = false, returnvoltage = false,
    returnnodefluxadjoint = false, returnvoltageadjoint = false,
    keyedarrays::Val{K} = Val(true), sensitivitynames::Vector{String} = String[],
    returnSsensitivity = false, returnZ = false, returnZadjoint = false,
    returnZsensitivity = false, returnZsensitivityadjoint = false,
    factorization = KLUfactorization()) where {N,M,K}</code></pre><p>Calls the harmonic balance solvers, <a href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><code>hbnlsolve</code></a> and <a href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolve</code></a>, which work for an arbitrary number of modes and ports, and for both three and four wave mixing processes. See also <a href="#JosephsonCircuits.hbnlsolve-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Number}, Any, JosephsonCircuits.Frequencies{N}, JosephsonCircuits.FourierIndices{N}, JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph, JosephsonCircuits.CircuitMatrices}} where {N, K}"><code>hbnlsolve</code></a> and <a href="#JosephsonCircuits.hblinsolve-Union{Tuple{K}, Tuple{Any, Any, Any}} where K"><code>hblinsolve</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>ws</code>: the angular frequency or frequencies of the signal in Hz such as   2*pi*5.0e9 or 2*pi*(4.5:0.001:5.0)*1e9.</li><li><code>wp::NTuple{N,Number}</code>: a tuple containing the angular frequencies of the   strong tones (or pumps) such as (2*pi*5.0e9,) for a single pump at 5 GHz   (2*pi*5.0e9,2*pi*6.0e9) for a pump at 5 GHz and a pump at 6 GHz. The   frequencies should be non-commensurate. For commensurate pumps, the lowest   pump frequency should be provided here, and the other pumps added to   <code>sources</code> with a mode index equal to the ratio.</li><li><code>sources::Vector</code>: a vector of named tuples specifying the mode index,   port, and current for each source. The named tuple(s) have names   mode, port, and current. mode is a tuple specifying the mode or harmonic   indices of the pumps, port is an integer specifying the port, and current   is a number specifying the current. Note that the current is a complex   number    For example:   [(mode=(1,0),port=1,current=Ip1),(mode=(0,1),port=1,current=Ip2)]   specifies two pumps where the frequency of the first pump would be   1*wp1 + 0*wp2 and the second 0*wp1+1*wp2 where wp1 is the first   pump frequency and wp2 is the second pump frequency. Both of the pumps are   applied to port 1 with currents Ip1 and Ip2, respectively. </li><li><code>Nmodulationharmonics::NTuple{M,Int}</code>: a tuple of integers describing how   many signal and idler modes.</li><li><code>Npumpharmonics::NTuple{N,Int}</code>: a tuple of integers describing how many   harmonics to simulate for each of the pumps. The length of the tuple must   equal the number of non-commensurate pumps.</li><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.</li><li><code>circuitdefs</code>: a dictionary where the keys are symbols or symbolic   variables for component values and the values are the numerical values   for the components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>dc = false</code>: include 0 frequency terms in the harmonic balance analysis.</li><li><code>threewavemixing = false</code>: simulate three wave mixing processes. </li><li><code>fourwavemixing = true</code>: simulate four wave mixing processes.</li><li><code>maxintermodorder=Inf</code>: the maximum intermod order as defined by the sum of   the absolute values of the integers multiplying each of the frequencies   being less than or equal to <code>maxintermodorder</code>. This performs a diamond   truncation of the discrete Fourier space.</li><li><code>iterations = 1000</code>: the number of iterations before the nonlinear solver   returns an error.</li><li><code>ftol = 1e-8</code>: the function tolerance defined we considered converged,   defined as norm(F)/norm(x) &lt; ftol or norm(F,Inf) &lt;= ftol.</li><li><code>switchofflinesearchtol = 1e-5</code>: the function tolerance at which we switch   from Newton with linesearch to only Newton. For easily converging   functions, setting this to zero can speed up simulations.</li><li><code>alphamin = 1e-4</code>: the minimum step size relative to 1 for the linesearch.</li><li><code>symfreqvar = nothing</code>: the symbolic frequency variable, eg <code>w</code>.</li><li><code>nbatches = Base.Threads.nthreads()</code>: the number of batches to split the   signal frequencies into for multi-threading. Set to 1 for singled threaded   evaluation.</li><li><code>sorting = :number</code>: sort the nodes by:   <code>:name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.   <code>:number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).   <code>:none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li><li><code>returnS = true</code>: return the scattering parameters from the linearized   simulations.</li><li><code>returnSnoise = false</code>: return the noise scattering parameters from the   linearized simulations.</li><li><code>returnQE = true</code>: return the quantum efficiency from the linearized   simulations.</li><li><code>returnCM = true</code>: return the commutation relations from the linearized   simulations.</li><li><code>returnnodeflux = false</code>: return the node fluxes from the linearized   simulations.</li><li><code>returnvoltage = false</code>: return the node voltages from the linearized   simulations.</li><li><code>returnnodefluxadjoint = false</code>: return the node fluxes from the linearized   adjoint simulations.</li><li><code>returnvoltageadjoint = false</code>: return the node voltages from the linearized   adjoint simulations.</li><li><code>keyedarrays::Val{K} = Val(true)</code>: when Val(true) return the output matrices   and vectors as keyed arrays for more intuitive indexing. When Val(false)   return normal matrices and vectors.</li><li><code>sensitivitynames::Vector{String} = String[]</code>: the component names for which   to return the sensitivities (in progress).</li><li><code>returnSsensitivity = false</code>: return the scattering parameter sensitivity   matrix from the linearized simulations (in progress).</li><li><code>returnZ = false</code>: return the impedance matrix from the linearized   simulations.</li><li><code>returnZadjoint = false</code>: return the impedance matrix from the linearized   adjoint simulations.</li><li><code>returnZsensitivity = false</code>: return the Z parameter sensitivity   matrix from the linearized simulations (in progress).</li><li><code>returnZsensitivityadjoint = false</code>: return the Z parameter sensitivity   matrix from the linearized adjoint simulations (in progress).</li><li><code>factorization = KLUfactorization()</code>: the type of factorization to use for   the nonlinear and the linearized simulations.</li></ul><p><strong>Returns</strong></p><ul><li><code>HB</code>: A simple structure to hold the harmonic balance solutions. See   <a href="#JosephsonCircuits.HB"><code>HB</code></a>.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K"><a class="docstring-binding" href="#JosephsonCircuits.hbsolveold-Union{Tuple{K}, NTuple{7, Any}} where K"><code>JosephsonCircuits.hbsolveold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs;
    pumpports = [1], iterations = 1000, ftol = 1e-8,
    symfreqvar = nothing, nbatches = Base.Threads.nthreads(),
    sorting = :number, returnS = true, returnSnoise = false,
    returnQE = true, returnCM = true, returnnodeflux = false,
    returnvoltage = false)</code></pre><p>Harmonic balance solver for single-pump four wave mixing processes in circuits containing Josephson junctions, capacitors, inductors, and resistors. Dissipation can be included through frequency dependent resistors or complex capacitance.</p><p>Returns user specified scattering parameters, quantum efficiency, and node fluxes or voltages.</p><p><strong>Arguments</strong></p><ul><li><code>ws</code>: signal frequency or vector of signal frequencies in radians/second.</li><li><code>wp</code>: pump frequency in radians/second. This function only supports a single   pump frequency.</li><li><code>Ip</code>: pump current or vector of pump currents in amps. Length of <code>Ip</code> must   be equal to length of <code>pumpports</code>.</li><li><code>Nsignalmodes</code>: number of signal and idler modes.</li><li><code>Npumpmodes</code>: number of pump modes (pump harmonics).</li><li><code>circuit</code>: vector of tuples containing component names, nodes, and values.</li><li><code>circuitdefs</code>: dictionary defining the numerical values of circuit components.</li></ul><p><strong>Keywords</strong></p><ul><li><code>pumpports = [1]</code>: vector of pump port numbers. Default is a single pump at   port 1.</li><li><code>iterations = 1000</code>: number of iterations at which the nonlinear solver   stops even if convergence criteria not reached. </li><li><code>ftol = 1e-8</code>: relative or absolute tolerance at which nonlinear solver   stops (whichever is reached first).</li><li><code>symfreqvar = nothing</code>: symbolic frequency variable which is set to   <code>nothing</code> by default but should be set equal to the frequency variable   like <code>w</code> if there is frequency dependence.</li><li><code>nbatches = Base.Threads.nthreads()</code>: for the linearized harmonic balance   solution,split the solutions for different frequencies into this many   batches. Set equalt to the number of threads. Recommend configuring Julia   to use Sys.CPU_THREADS/2 threads. </li><li><code>sorting = :number</code>: sort the ports by turning them into integers and   sorting those integers. See <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for other options if this   fails.</li><li><code>returnS = true</code>: if <code>true</code>, return the scattering parameters for each set   of ports and signal and idler frequencies.</li><li><code>returnSnoise = false</code>: if <code>true</code>, return the scattering parameters   corresponding to inputs at the noise ports (lossy components) and outputs   at the physical ports for the signal and idler frequencies. </li><li><code>returnQE = true</code>: if <code>true</code>, return the quantum efficiency for each signal   and idler at each combinaton of ports.</li><li><code>returnCM = true</code>: if <code>true</code>, return the commutation relations for each   signal and idler at each combinaton of ports (should equal ±1).</li><li><code>returnnodeflux = false</code>: if <code>true</code>, return the node fluxes for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li><li><code>returnnodefluxadjoint = false</code>: if <code>true</code>, return the node fluxes adjoint   for each signal and idler at each node. Set to <code>false</code> by default to   reduce memory usage.</li><li><code>returnvoltage = false</code>: if <code>true</code>, return the node voltages for each signal   and idler at each node. Set to <code>false</code> by default to reduce memory usage.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Rleft Cc Lj Cj w L1
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(
    Lj =&gt;1000.0e-12,
    Cc =&gt; 100.0e-15,
    Cj =&gt; 1000.0e-15,
    Rleft =&gt; 50.0,
)
ws = 2*pi*(4.5:0.01:5.0)*1e9
wp = 2*pi*4.75001*1e9
Ip = 0.00565e-6
Nsignalmodes = 8
Npumpmodes = 8
result=JosephsonCircuits.hbsolveold(ws, wp, Ip, Nsignalmodes, Npumpmodes, circuit, circuitdefs,pumpports=[1])
using Plots;plot(ws/(2*pi*1e9),10*log10.(abs2.(result.signal.S[result.signal.signalindex,result.signal.signalindex,:])))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.import_netlist!-Tuple{IO, AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.import_netlist!-Tuple{IO, AbstractVector}"><code>JosephsonCircuits.import_netlist!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">import_netlist!(io::IO, circuit)</code></pre><p>Import the netlist from the IOBuffer or IOStream <code>io</code> to the vector of tuples <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();circuit1=[(&quot;P&quot;,&quot;1&quot;,&quot;0&quot;,1),(&quot;R&quot;,&quot;1&quot;,&quot;0&quot;,50.0)];JosephsonCircuits.export_netlist!(io,circuit1,Dict());circuit2 = Tuple{String,String,String,Num}[];JosephsonCircuits.import_netlist!(io,circuit2);circuit2
2-element Vector{Tuple{String, String, String, Num}}:
 (&quot;P&quot;, &quot;1&quot;, &quot;0&quot;, 1.0)
 (&quot;R&quot;, &quot;1&quot;, &quot;0&quot;, 50.0)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.import_netlist-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.import_netlist-Tuple{Any}"><code>JosephsonCircuits.import_netlist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">import_netlist(filename)</code></pre><p>Import the netlist from the IOBuffer or IOStream <code>io</code> and return a vector of tuples representing the circuit.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS!-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS!-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64}"><code>JosephsonCircuits.interconnectS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS!(Sout, Cout, Sa, Sb, Ca, Cb, k, l)</code></pre><p>See <a href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>interconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS!-Tuple{Any, Any, Any, Int64, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS!-Tuple{Any, Any, Any, Int64, Int64}"><code>JosephsonCircuits.interconnectS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS!(Sout, Sa, Sb, k, l)</code></pre><p>See <a href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>interconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>JosephsonCircuits.interconnectS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS(Sa::AbstractArray, Sb::AbstractArray, Ca::AbstractArray,
    Cb::AbstractArray,k::Int, l::Int;
    nbatches::Int = Base.Threads.nthreads())</code></pre><p>Connect port <code>k</code> on an <code>m</code> port network, represented by the scattering parameter matrix <code>Sa</code>, to port <code>l</code> on an <code>n</code> port network, represented by the scattering parameter matrix <code>Sb</code>, resulting in a single <code>(m+n-2)</code> port network, as illustrated below:</p><p>Input network:</p><pre><code class="language-julia hljs">      m |        | k+1                       | 2
        |        |                           |
        |   ...  |                     ...   |
        |________|                  _________|________
        |        |                  |        |       1
        |   Sa   |                  |   Sb   |
        |  m x m |                  |  n x n |
    ____|________|__________________|________|
    1   |   ...     k           l   |   ...  |
        |                           |        |
        |                           |        |
      2 |                       l+1 |        | n</code></pre><p>Output network:</p><pre><code class="language-julia hljs">    m-1 |        | k      | m+1    
        |        |        |        
        |   ...  |   ...  |        
        |________|________|________
        |                 |     m  
        |        S        |        
        |  m+n-2 x m+n-2  |        
    ____|_________________|        
    1   |   ...  |   ...  |        
        |        |        |        
        |        |        |        
      2 |        |        |  m+n-2 
                m-1+l              </code></pre><p><strong>Arguments</strong></p><ul><li><code>Sa::Array</code>: Array of scattering parameters representing the first network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>Sb::Array</code>: Array of scattering parameters representing the second network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>Ca::Array</code>: Array of noise correlation parameters of the same dimensions as   <code>Sa</code>.</li><li><code>Cb::Array</code>: Array of noise correlation parameters of the same dimensions as   <code>Sb</code>.</li><li><code>k::Int</code>: Port on first network, with one based indexing.</li><li><code>l::Int</code>: Port on second network, with one based indexing.</li></ul><p><strong>References</strong></p><p>S. W. Wedge, &quot;Computer-aided design of low noise microwave circuits,&quot; PhD thesis (1991). R. C. Compton and D. B. Rutledge, &quot;Perspectives in Microwave Circuit Analysis,&quot; Proceedings of the 32nd Midwest Symposium on Circuits and Systems, vol. 2, pp. 716–718, Aug. 1989. doi: 10.1109/MWSCAS.1989.101955 V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>JosephsonCircuits.interconnectS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS(Sa::AbstractArray, Sb::AbstractArray, k::Int, l::Int;
    nbatches::Int = Base.Threads.nthreads())</code></pre><p>Connect port <code>k</code> on an <code>m</code> port network, represented by the scattering parameter matrix <code>Sa</code>, to port <code>l</code> on an <code>n</code> port network, represented by the scattering parameter matrix <code>Sb</code>, resulting in a single <code>(m+n-2)</code> port network, as illustrated below:</p><p>Input network:</p><pre><code class="language-julia hljs">      m |        | k+1                       | 2
        |        |                           |
        |   ...  |                     ...   |
        |________|                  _________|________
        |        |                  |        |       1
        |   Sa   |                  |   Sb   |
        |  m x m |                  |  n x n |
    ____|________|__________________|________|
    1   |   ...     k           l   |   ...  |
        |                           |        |
        |                           |        |
      2 |                       l+1 |        | n</code></pre><p>Output network:</p><pre><code class="language-julia hljs">    m-1 |        | k      | m+1    
        |        |        |        
        |   ...  |   ...  |        
        |________|________|________
        |                 |     m  
        |        S        |        
        |  m+n-2 x m+n-2  |        
    ____|_________________|        
    1   |   ...  |   ...  |        
        |        |        |        
        |        |        |        
      2 |        |        |  m+n-2 
                m-1+l              </code></pre><p><strong>Arguments</strong></p><ul><li><code>Sa::Array</code>: Array of scattering parameters representing the first network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>Sb::Array</code>: Array of scattering parameters representing the second network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>k::Int</code>: Port on first network, with one based indexing.</li><li><code>l::Int</code>: Port on second network, with one based indexing.</li></ul><p><strong>References</strong></p><p>V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS_inner!-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS_inner!-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, AbstractArray}"><code>JosephsonCircuits.interconnectS_inner!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS_inner!(Sout, Cout, Sa, Sb, Ca, Cb, k::Int, l::Int,
    batch::AbstractArray)</code></pre><p>See <a href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>interconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectS_inner!-Tuple{Any, Any, Any, Int64, Int64, AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.interconnectS_inner!-Tuple{Any, Any, Any, Int64, Int64, AbstractArray}"><code>JosephsonCircuits.interconnectS_inner!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectS_inner!(Sout,Sa,Sb,k::Int,l::Int,batch::AbstractArray)</code></pre><p>See <a href="#JosephsonCircuits.interconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>interconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.interconnectSports-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, Int64}, 1}, AbstractArray{Tuple{T, Int64}, 1}, Int64, Int64}} where T"><a class="docstring-binding" href="#JosephsonCircuits.interconnectSports-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, Int64}, 1}, AbstractArray{Tuple{T, Int64}, 1}, Int64, Int64}} where T"><code>JosephsonCircuits.interconnectSports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interconnectSports(portsa::AbstractVector{Tuple{T,Int}},
    portsb::AbstractVector{Tuple{T,Int}}, k::Int, l::Int) where T</code></pre><p>Return a vector of tuples of (networkname, portindex) with <code>portsa</code> from the first network and <code>portsb</code> from the second network after ports <code>k</code> and <code>l</code> from the first and second networks have been connected. If the first network has <code>n</code> ports and the second network has <code>m</code> ports, then the combined network has <code>(m+n-2)</code> ports. See <a href="#JosephsonCircuits.connectS-Tuple{Any, Any}"><code>connectS</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.interconnectSports([(:S1,1),(:S1,2),(:S1,3),(:S1,4),(:S1,5)],[(:S2,1),(:S2,2),(:S2,3),(:S2,4),(:S2,5)],3,4)
8-element Vector{Tuple{Symbol, Int64}}:
 (:S1, 1)
 (:S1, 2)
 (:S1, 4)
 (:S1, 5)
 (:S2, 1)
 (:S2, 2)
 (:S2, 3)
 (:S2, 5)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectS!-Tuple{Any, Any, Any, Any, Int64, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectS!-Tuple{Any, Any, Any, Any, Int64, Int64}"><code>JosephsonCircuits.intraconnectS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectS!(Sout, Cout, Sa, Ca, k::Int, l::Int; nbatches::Int = Base.Threads.nthreads())</code></pre><p>See <a href="#JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>intraconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectS!-Tuple{Any, Any, Int64, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectS!-Tuple{Any, Any, Int64, Int64}"><code>JosephsonCircuits.intraconnectS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectS!(Sout, Sa, k::Int, l::Int; nbatches::Int = Base.Threads.nthreads())</code></pre><p>See <a href="#JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>intraconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>JosephsonCircuits.intraconnectS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectS(Sa::AbstractArray, Ca::AbstractArray, k::Int, l::Int;
    nbatches::Int = Base.Threads.nthreads())</code></pre><p>Connect ports <code>k</code> and <code>l</code> on the same <code>m</code> port microwave network represented by the scattering parameter matrix <code>Sa</code>, and noise correlation matrix <code>Ca</code>  resulting in an <code>(m-2)</code> port network, as illustrated below:</p><p>Input network:</p><pre><code class="language-julia hljs">      m |         | l+1    
        |   ...   |         l
        |_________|__________ 
        |         |          |
        |   Sa    |  ...     |
        |  m x m  |          |
    ____|_________|_____ k+1 |
    1   |   ...   |          |
        |         | k        |
      2 |         |__________|</code></pre><p>Output network:</p><pre><code class="language-julia hljs">    m-2 |         | l-1     
        |         |         
        |   ...   |         
        |_________|         
        |         |         
        |    S    |  ...    
        |m-2 x m-2|         
    ____|_________|_________
    1   |   ...         k   
        |                   
        |                   
      2 |                   </code></pre><p><strong>Arguments</strong></p><ul><li><code>Sa::Array</code>: Array of scattering parameters representing the network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>Ca::Array</code>: Array of noise correlation parameters of the same dimensions as   <code>Sa</code>.</li><li><code>k::Int</code>: First port to connect, with one based indexing.</li><li><code>l::Int</code>: Second port to connect, with one based indexing.</li></ul><p><strong>References</strong></p><p>S. W. Wedge, &quot;Computer-aided design of low noise microwave circuits,&quot; PhD thesis (1991). R. C. Compton and D. B. Rutledge, &quot;Perspectives in Microwave Circuit Analysis,&quot; Proceedings of the 32nd Midwest Symposium on Circuits and Systems, vol. 2, pp. 716–718, Aug. 1989. doi: 10.1109/MWSCAS.1989.101955 V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Int64, Int64}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>JosephsonCircuits.intraconnectS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectS(Sa::AbstractArray, k::Int, l::Int;
    nbatches::Int = Base.Threads.nthreads())</code></pre><p>Connect ports <code>k</code> and <code>l</code> on the same <code>m</code> port microwave network represented by the scattering parameter matrix <code>Sa</code>, resulting in an <code>(m-2)</code> port network, as illustrated below:</p><p>Input network:</p><pre><code class="language-julia hljs">      m |         | l+1    
        |   ...   |         l
        |_________|__________ 
        |         |          |
        |   Sa    |  ...     |
        |  m x m  |          |
    ____|_________|_____ k+1 |
    1   |   ...   |          |
        |         | k        |
      2 |         |__________|</code></pre><p>Output network:</p><pre><code class="language-julia hljs">    m-2 |         | l-1     
        |         |         
        |   ...   |         
        |_________|         
        |         |         
        |    S    |  ...    
        |m-2 x m-2|         
    ____|_________|_________
    1   |   ...         k   
        |                   
        |                   
      2 |                   </code></pre><p><strong>Arguments</strong></p><ul><li><code>Sa::Array</code>: Array of scattering parameters representing the network   with ports along first two dimensions, followed by an arbitrary number   of other dimensions (eg. frequency).</li><li><code>k::Int</code>: First port to connect, with one based indexing.</li><li><code>l::Int</code>: Second port to connect, with one based indexing.</li></ul><p><strong>References</strong></p><p>R. C. Compton and D. B. Rutledge, &quot;Perspectives in Microwave Circuit Analysis,&quot; Proceedings of the 32nd Midwest Symposium on Circuits and Systems, vol. 2, pp. 716–718, Aug. 1989. doi: 10.1109/MWSCAS.1989.101955 V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectS_inner!-Tuple{Any, Any, Int64, Int64, AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectS_inner!-Tuple{Any, Any, Int64, Int64, AbstractArray}"><code>JosephsonCircuits.intraconnectS_inner!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectS_inner!(Sout, Sa, k::Int, l::Int, batch::AbstractArray)</code></pre><p>See <a href="#JosephsonCircuits.intraconnectS-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Int64, Int64}} where {T, N}"><code>intraconnectS</code></a> for description.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.intraconnectSports-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, Int64}, 1}, Int64, Int64}} where T"><a class="docstring-binding" href="#JosephsonCircuits.intraconnectSports-Union{Tuple{T}, Tuple{AbstractArray{Tuple{T, Int64}, 1}, Int64, Int64}} where T"><code>JosephsonCircuits.intraconnectSports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intraconnectSports(portsa::AbstractVector{Tuple{T,Int}},k::Int,l::Int) where T</code></pre><p>Return a vector of tuples of (networkname, portindex) from <code>portsa</code> after ports <code>k</code> and <code>l</code> have been connected. See <a href="#JosephsonCircuits.connectS-Tuple{Any, Any}"><code>connectS</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.intraconnectSports([(:S1,1),(:S1,2),(:S1,3),(:S1,4),(:S1,5)],3,4)
3-element Vector{Tuple{Symbol, Int64}}:
 (:S1, 1)
 (:S1, 2)
 (:S1, 5)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><code>JosephsonCircuits.keepfreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keepfreqs(frequencies::Frequencies{N},
    keepcoords::AbstractVector{CartesianIndex{N}})</code></pre><p>Return a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,)], [(0,)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{NTuple{N, Int64}, 1}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.keepfreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{NTuple{N, Int64}, 1}}} where N"><code>JosephsonCircuits.keepfreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keepfreqs(frequencies::Frequencies{N},
    keepmodes::AbstractVector{NTuple{N,Int}})</code></pre><p>Return a new Frequencies struct with all coordinates and modes except the ones in keepmodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),[(0,0),(1,0),(0,1),(1,1)])
JosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(1, 2), CartesianIndex(2, 2)], [(0, 0), (1, 0), (0, 1), (1, 1)])

julia&gt; JosephsonCircuits.keepfreqs(JosephsonCircuits.calcfreqsrdft((2,2)),Tuple{Int64,Int64}[])
JosephsonCircuits.Frequencies{2}((2, 2), (3, 5), (4, 5), CartesianIndex{2}[], Tuple{Int64, Int64}[])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.ldiv_2x2-Tuple{Union{LinearAlgebra.LU, StaticArrays.LU}, AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.ldiv_2x2-Tuple{Union{LinearAlgebra.LU, StaticArrays.LU}, AbstractVector}"><code>JosephsonCircuits.ldiv_2x2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ldiv_2x2(fact,b)</code></pre><p>Solve the linear system A*x = b for x using left division when given <code>fact</code>  which is the LU factorization of <code>A</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.linesearch-NTuple{4, Any}"><a class="docstring-binding" href="#JosephsonCircuits.linesearch-NTuple{4, Any}"><code>JosephsonCircuits.linesearch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linesearch(f, fp, dfdalpha, alphamin)</code></pre><p>Quadratic linesearch based on Nocedal and Wright, chapter 3 section 5. <code>f</code> is the value at the first point alpha=0.0, <code>fp</code> is the value at the second point, alpha=1.0, <code>dfdalpha</code> is the derivative at the first point, and <code>alphamin</code> is the minimum value of <code>dfdalpha</code> below which we will take a full step. The linesearch will return the fitted minimum of the function with respect to alpha as (alpha at which minimum occurs, minimum value of function).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.lu_2x2-Tuple{AbstractArray}"><a class="docstring-binding" href="#JosephsonCircuits.lu_2x2-Tuple{AbstractArray}"><code>JosephsonCircuits.lu_2x2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lu_2x2(A)</code></pre><p>Return the LU factorization of a 2 by 2 matrix as a StaticArrays.LU struct. Perform the LU factorization even if <code>A</code> is singular.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.make_connection!-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, AbstractVector{&lt;:AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{&lt;:AbstractArray{Tuple{T, Int64}, 1}}, AbstractVector{N}, AbstractVector{N}, Int64, Int64, Int64, AbstractVector{Bool}, Dict{Int64, N}, Dict{Int64, N}, Bool}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.make_connection!-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, AbstractVector{&lt;:AbstractArray{Tuple{T, T, Int64, Int64}, 1}}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{&lt;:AbstractArray{Tuple{T, Int64}, 1}}, AbstractVector{N}, AbstractVector{N}, Int64, Int64, Int64, AbstractVector{Bool}, Dict{Int64, N}, Dict{Int64, N}, Bool}} where {T, N}"><code>JosephsonCircuits.make_connection!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_connection!(g,fconnectionlist,fweightlist,ports,networkdata,src_node,
connection_index)</code></pre><p>Apply the connection specified by the source node <code>src_node</code> and the index of the connection in the forward adjacency list <code>connection_index</code>. Modify the arguments and return nothing.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.maxwell_combine-Union{Tuple{T}, Tuple{N}, Tuple{Int64, Dict{NTuple{N, Int64}, T}}} where {N, T&lt;:(AbstractMatrix)}"><a class="docstring-binding" href="#JosephsonCircuits.maxwell_combine-Union{Tuple{T}, Tuple{N}, Tuple{Int64, Dict{NTuple{N, Int64}, T}}} where {N, T&lt;:(AbstractMatrix)}"><code>JosephsonCircuits.maxwell_combine</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxwell_combine(n::Int, d::Dict{NTuple{N, Int}, T}) where {N,T&lt;:AbstractMatrix}</code></pre><p>Return the Maxwell capacitance matrix for an <code>n</code> terminal system from the Maxwell capacitance matrices for sets of terminals stored in the dictionary <code>d</code>. The dictionary keys are tuples of the terminal numbers for the capacitance matrices and the values are the capacitance matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables C11, C12, C13, C21, C22, C23, C31, C32, C33;JosephsonCircuits.maxwell_combine(3, Dict((1,2)=&gt;[C11 C12;C21 C22],(1,3)=&gt;[C11 C13;C31 C33],(2,3)=&gt;[C22 C23;C32 C33]))
3×3 Matrix{Num}:
 C11  C12  C13
 C21  C22  C23
 C31  C32  C33

julia&gt; @variables C11, C12, C13, C21, C22, C23, C31, C32, C33;JosephsonCircuits.maxwell_combine(3, Dict((1,2,3)=&gt;[C11 C12 C13;C21 C22 C23; C31 C32 C33]))
3×3 Matrix{Num}:
 C11  C12  C13
 C21  C22  C23
 C31  C32  C33</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.maxwell_to_even_odd-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.maxwell_to_even_odd-Tuple{Any, Any}"><code>JosephsonCircuits.maxwell_to_even_odd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxwell_to_even_odd(L, Cmaxwell)</code></pre><p>Return the even and odd mode impedances and the even and odd mode indices from the inductance matrix <code>L</code> and the Maxwell capacitance matrix <code>Cmaxwell</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables C11, C12, L11, L12
C = [C11 C12;C12 C11]
L = [L11 L12;L12 L11]
Zeven, Zodd, neven, nodd = JosephsonCircuits.maxwell_to_even_odd(L,C)
@show Zeven
@show Zodd
@show neven
@show nodd
;

# output
Zeven = sqrt((L11 + L12) / (C11 + C12))
Zodd = sqrt((L11 - L12) / (C11 - C12))
neven = 2.99792458e8sqrt((C11 + C12)*(L11 + L12))
nodd = 2.99792458e8sqrt((C11 - C12)*(L11 - L12))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.maxwell_to_mutual-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.maxwell_to_mutual-Tuple{AbstractMatrix}"><code>JosephsonCircuits.maxwell_to_mutual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxwell_to_mutual(Cmaxwell::AbstractMatrix)</code></pre><p>Return the mutual capacitance matrix from the Maxwell capacitance matrix <code>Cmaxwell</code>.</p><p>The Maxwell capacitance <code>Cmaxwell</code> is the relationship between charge and voltage on each node, Q = C V or dQi/dVj = C_ij where <code>C</code> is the Maxwell capacitance matrix.</p><p>Each element of the mutual capacitance matrix <code>Cmutual</code> is the value of a physical capacitor placed between two nodes in a circuit or between a node and ground.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables C11, C12, C21, C22;C = [C11 C12;C21 C22];JosephsonCircuits.maxwell_to_mutual(C)
2×2 Matrix{Num}:
 C11 + C12       -C12
      -C21  C21 + C22

julia&gt; C = [1.0 -0.1;-0.1 2.0];JosephsonCircuits.maxwell_to_mutual(C)
2×2 Matrix{Float64}:
 0.9  0.1
 0.1  1.9</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.move_bedge!-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.move_bedge!-NTuple{6, Any}"><code>JosephsonCircuits.move_bedge!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move_bedge!(g,dst_node,dst_node_new,edge_index,fadjlist1,fadjlist2)</code></pre><p>Move an edge from graph <code>g</code> at destination node <code>dst_node</code> to the new destination node <code>dst_node_new</code> with the edge index <code>edge_index</code> in the backwards adjacency list. Also perform the same operations on the forward adjacency lists <code>fadjlist1</code> and <code>fadjlist2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.move_bedge!(g,1,2,1,deepcopy(g.fadjlist),deepcopy(g.fadjlist));g.badjlist
3-element Vector{Vector{Int64}}:
 [2]
 [1]
 [2]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.move_bedges!-NTuple{5, Any}"><a class="docstring-binding" href="#JosephsonCircuits.move_bedges!-NTuple{5, Any}"><code>JosephsonCircuits.move_bedges!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move_bedges!(g,dst_node,dst_node_new,fadjlist1,fadjlist2)</code></pre><p>Move the edges from graph <code>g</code> at destination node <code>dst_node</code> to the new destination node <code>dst_node_new</code> in the backwards adjacency list. Also perform the same operations on the forward adjacency lists <code>fadjlist1</code> and <code>fadjlist2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.move_bedges!(g,1,2,deepcopy(g.fadjlist),deepcopy(g.fadjlist));g.badjlist
3-element Vector{Vector{Int64}}:
 []
 [2, 1]
 [2]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.move_edges!-NTuple{5, Any}"><a class="docstring-binding" href="#JosephsonCircuits.move_edges!-NTuple{5, Any}"><code>JosephsonCircuits.move_edges!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move_edges!(g,node,node_new,fadjlist1,fadjlist2)</code></pre><p>Move the edges from graph <code>g</code> at node <code>node</code> to the new node <code>node_new</code>. Also perform the same operations on the forward adjacency lists <code>fadjlist1</code> and <code>fadjlist2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.move_edges!(g,1,2,deepcopy(g.fadjlist),deepcopy(g.fadjlist));g.fadjlist
3-element Vector{Vector{Int64}}:
 []
 [3, 2, 2]
 []</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.move_fedge!-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.move_fedge!-NTuple{6, Any}"><code>JosephsonCircuits.move_fedge!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move_fedge!(g,src_node,src_node_new,edge_index,fadjlist1,fadjlist2)</code></pre><p>Move an edge from graph <code>g</code> at source node <code>src_node</code> to the new source node <code>src_node_new</code> with the edge index <code>edge_index</code> in the forward adjacency list. Also perform the same operations on the forward adjacency lists <code>fadjlist1</code> and <code>fadjlist2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.move_fedge!(g,1,2,1,deepcopy(g.fadjlist),deepcopy(g.fadjlist));g.fadjlist
3-element Vector{Vector{Int64}}:
 []
 [1, 3, 1]
 []</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.move_fedges!-NTuple{5, Any}"><a class="docstring-binding" href="#JosephsonCircuits.move_fedges!-NTuple{5, Any}"><code>JosephsonCircuits.move_fedges!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">move_fedges!(g,src_node,src_node_new,fadjlist1,fadjlist2)</code></pre><p>Move the edges from graph <code>g</code> at source node <code>src_node</code> to the new source node <code>src_node_new</code> in the forward adjacency list. Also perform the same operations on the forward adjacency lists <code>fadjlist1</code> and <code>fadjlist2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.move_fedges!(g,1,2,deepcopy(g.fadjlist),deepcopy(g.fadjlist));g.fadjlist
3-element Vector{Vector{Int64}}:
 []
 [1, 3, 1]
 []</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.mutual_to_even_odd-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.mutual_to_even_odd-Tuple{Any, Any}"><code>JosephsonCircuits.mutual_to_even_odd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mutual_to_even_odd(L, Cmutual)</code></pre><p>Return the even and odd mode impedances and the even and odd mode indices from the inductance matrix <code>L</code> and the mutual capacitance matrix <code>Cmutual</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Cg, Cm, Ls, Lm
C = [Cg Cm; Cm Cg]
L = [Ls Lm; Lm Ls]
Zeven, Zodd, neven, nodd = JosephsonCircuits.mutual_to_even_odd(L,C)
@show Zeven
@show Zodd
@show neven
@show nodd
;

# output
Zeven = sqrt((Lm + Ls) / Cg)
Zodd = sqrt((-Lm + Ls) / (Cg + 2Cm))
neven = 2.99792458e8sqrt(Cg*(Lm + Ls))
nodd = 2.99792458e8sqrt((Cg + 2Cm)*(-Lm + Ls))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.mutual_to_maxwell-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.mutual_to_maxwell-Tuple{AbstractMatrix}"><code>JosephsonCircuits.mutual_to_maxwell</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxwell_to_mutual(Cmutual::AbstractMatrix)</code></pre><p>Return the Maxwell capacitance matrix from the mutual capacitance matrix <code>Cmutual</code>.</p><p>The Maxwell capacitance <code>Cmaxwell</code> is the relationship between charge and voltage on each node, Q = C V or dQi/dVj = C_ij where <code>C</code> is the Maxwell capacitance matrix.</p><p>Each element of the mutual capacitance matrix <code>Cmutual</code> is the value of a physical capacitor placed between two nodes in a circuit or between a node and ground.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Cg, Cm;C = [Cg Cm;Cm Cg];JosephsonCircuits.mutual_to_maxwell(C)
2×2 Matrix{Num}:
 Cg + Cm      -Cm
     -Cm  Cg + Cm

julia&gt; C = [0.9 0.1;0.1 1.9];JosephsonCircuits.mutual_to_maxwell(C)
2×2 Matrix{Float64}:
  1.0  -0.1
 -0.1   2.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.nlsolve!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractArray{T}, Vector{T}}} where T"><a class="docstring-binding" href="#JosephsonCircuits.nlsolve!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractArray{T}, Vector{T}}} where T"><code>JosephsonCircuits.nlsolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nlsolve!(fj!::Function, F::AbstractVector{T}, J::AbstractArray{T},
    x::Vector{T}; iterations=1000, ftol=1e-8, switchofflinesearchtol = 1e-5,
    alphamin = 1e-4,factorization = KLUfactorization())</code></pre><p>A simple nonlinear solver using Newton&#39;s method with linesearch based on Nocedal and Wright, chapter 3 section 5.</p><p>This solver attempts to find x such that f(x) == 0, where f is a nonlinear function with Jacobian J.</p><p>A few points to note: (1) It uses KLU factorization, so only works on sparse matrices. (2) The Jacobian J cannot change sparsity structure. (3) This function attempts to reuse the symbolic factorization which can     sometimes result in a SingularException, which we catch, then create a     new factorization object.</p><p><strong>Arguments</strong></p><ul><li><code>fj!</code>: a function to compute a vector-valued objective function and</li></ul><p>its Jacobian.</p><ul><li><code>F</code>: matrix for holding intermediate results. Initial values may be overwritten and can be bogus values.</li><li><code>J</code>: sparse matrix with with the desired sparsity structure of the Jacobian. Initial values may be overwritten and can be bogus values, as long as the sparsity structure is correct.</li><li><code>x</code>: initial guess for x.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">function fj!(F, J, x)
    if !isnothing(F)
        F[1] = (x[1]+3)*(x[2]^3-7)+18
        F[2] = sin(x[2]*exp(x[1])-1)
    end
    if !isnothing(J)
        J[1, 1] = x[2]^3-7
        J[1, 2] = 3*x[2]^2*(x[1]+3)
        u = exp(x[1])*cos(x[2]*exp(x[1])-1)
        J[2, 1] = x[2]*u
        J[2, 2] = u
    end
    return nothing
end
x = [ 0.1, 1.2]
F = [0.0, 0.0]
J = JosephsonCircuits.sparse([1, 1, 2, 2],[1, 2, 1, 2],[1.3, 0.5, 0.1, 1.2])
JosephsonCircuits.nlsolve!(fj!, F, J, x)
isapprox([0.0,1.0],x)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.nodevariabletokeyed-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.nodevariabletokeyed-NTuple{6, Any}"><code>JosephsonCircuits.nodevariabletokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodevariabletokeyed(nodevariable, outputmodes, nodenames, inputmodes,
    inputportnumbers, w)</code></pre><p>Convert a node variable array <code>nodevariable</code> (such as node flux or node voltage) vs frequency <code>w</code> to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.nodevariabletokeyed([1 2;3 4;;;],[(0,),(1,)],[&quot;0&quot;,&quot;1&quot;],[(0,),(1,)],[1],[1.0])
5-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 2-element Vector{Tuple{Int64}}
→   node ∈ 1-element Vector{String}
◪   inputmode ∈ 2-element Vector{Tuple{Int64}}
▨   inputport ∈ 1-element Vector{Int64}
▨   freqindex ∈ 1-element UnitRange{Int64}
And data, 2×1×2×1×1 Array{Int64, 5}:
[:, :, 1, 1, 1] ~ (:, :, (0,), 1, 1):
          (&quot;1&quot;)
   (0,)    1
   (1,)    3

[:, :, 2, 1, 1] ~ (:, :, (1,), 1, 1):
          (&quot;1&quot;)
   (0,)    2
   (1,)    4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.nodevariabletokeyed-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.nodevariabletokeyed-Tuple{Any, Any, Any}"><code>JosephsonCircuits.nodevariabletokeyed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodevariabletokeyed(nodevariable, outputmodes, nodenames)</code></pre><p>Convert a node variable array <code>nodevariable</code> (such as node flux or node voltage) to a keyed array. Return the keyed array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.nodevariabletokeyed([1 2;3 4],[(0,),(1,)],[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;])
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   outputmode ∈ 2-element Vector{Tuple{Int64}}
→   node ∈ 2-element Vector{String}
And data, 2×2 Matrix{Int64}:
          (&quot;1&quot;)  (&quot;2&quot;)
   (0,)    1      2
   (1,)    3      4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><code>JosephsonCircuits.numericmatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">numericmatrices(circuit, circuitdefs; Nmodes = 1, sorting = :number)</code></pre><p>Return the numeric matrices describing the circuit properties.</p><p>See also <a href="#JosephsonCircuits.CircuitMatrices"><code>CircuitMatrices</code></a>, <a href="#JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><code>numericmatrices</code></a>, <a href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcCn</code></a>, <a href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcGn</code></a>, <a href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLb</code></a>,<a href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLjb</code></a>, <a href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>calcMb</code></a>, <a href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>calcinvLn</code></a>, <a href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>calcLmean</code></a>, <a href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportindicesnumbers</code></a>, <a href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportimpedanceindices</code></a>, and <a href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcnoiseportimpedanceindices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(Lj =&gt;1000.0e-12,Cc =&gt; 100.0e-15,Cj =&gt; 1000.0e-15,Rleft =&gt; 50.0,Ipump =&gt; 1.0e-8)
JosephsonCircuits.testshow(stdout,numericmatrices(circuit,circuitdefs))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
circuitdefs = Dict(Lj =&gt;1000.0e-12,Cc =&gt; 100.0e-15,Cj =&gt; 1000.0e-15,Rleft =&gt; 50.0,Ipump =&gt; 1.0e-8)
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
JosephsonCircuits.testshow(stdout,numericmatrices(psc, cg, circuitdefs))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], 1.0e-9, Real[1, 1.0e-8, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.parse_connections_sparse-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><a class="docstring-binding" href="#JosephsonCircuits.parse_connections_sparse-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{JosephsonCircuits.LinearNetwork{T, N}, 1}, AbstractArray{Tuple{T, T, Int64, Int64}, 1}}} where {T, N}"><code>JosephsonCircuits.parse_connections_sparse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_connections_sparse(networks::AbstractVector{Tuple{T,N}},
    connections::AbstractVector{Tuple{T,T,Int,Int}}) where {T,N}</code></pre><p>Return the indices of the internal ports <code>porti_indices</code>, the external ports <code>porte_indices</code>, the vector of port tuples <code>ports</code>, the vector of scattering parameter data <code>networkdata</code>, the connection matrix <code>gamma</code>, the sparse matrix containing indices in networkdata <code>Sindices</code>, and an empty sparse matrix of scattering parameter data <code>S</code>. The scattering parameter data consists of the input networks assembled as a block diagonal matrix.</p><p><strong>References</strong></p><p>V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.parsecircuit-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>JosephsonCircuits.parsecircuit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsecircuit(circuit)</code></pre><p>Parse <code>circuit</code> which is a vector where each element contains a tuple with the component name, the first node, the second node, and the component value. Component values can be numbers, symbols, or symbolic variables (including symbolic functions).</p><p>The nodes can be arbitrary strings for SPICE compatibility. Integers are also supported but are converted internally to strings. The ground node is &quot;0&quot; and is required. Specifying the type of the vector <code>circuit</code> is optional; although, typically a vector with a type union is preferable to an array of type Any.</p><p><strong>Arguments</strong></p><ul><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft L1 K1 L2 C2
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, K1, L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 L2 C2
Kfun(L) = sin(L);@register_symbolic Kfun(L1)
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,Kfun(L1)))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;One&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;One&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;One&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;One&quot;,&quot;Two&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;Two&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;Two&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;One&quot;, &quot;0&quot;, &quot;Two&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = []
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 3, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Any[1, :Ipump, :Rleft, :Cc, :Lj, :Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">circuit = Vector{Tuple{String,String,String,Union{Complex{Float64}, Symbol,Int}}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,:Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,:L1))
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,:K1))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,:L2))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:C2))
parsecircuit(circuit)

# output
JosephsonCircuits.ParsedCircuit([1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2], [&quot;1&quot;, &quot;0&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Union{Int64, Symbol, ComplexF64}[1, :Ipump, :Rleft, :L1, :K1, :L2, :C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.parsecomponenttype-Tuple{String, Vector{String}}"><a class="docstring-binding" href="#JosephsonCircuits.parsecomponenttype-Tuple{String, Vector{String}}"><code>JosephsonCircuits.parsecomponenttype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsecomponenttype(name::String,allowedcomponents::Vector{String})</code></pre><p>The first one or two characters of the component name in the string <code>name</code> should match one of the strings in the vector <code>allowedcomponents</code>. Return the  index first of the match found.</p><p>NOTE: if a two letter component appears in allowedcomponents after a one  letter component with the same starting letter this function will match on the first value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsecomponenttype(&quot;L10&quot;,[&quot;Lj&quot;,&quot;NL&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;])
3

julia&gt; [JosephsonCircuits.parsecomponenttype(c,[&quot;Lj&quot;,&quot;NL&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;]) for c in [&quot;Lj&quot;,&quot;NL&quot;,&quot;L&quot;,&quot;C&quot;,&quot;K&quot;,&quot;I&quot;,&quot;R&quot;,&quot;P&quot;]]
8-element Vector{Int64}:
 1
 2
 3
 4
 5
 6
 7
 8</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.parsesortcircuit-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.parsesortcircuit-Tuple{Any}"><code>JosephsonCircuits.parsesortcircuit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsesortcircuit(circuit; sorting = :name)</code></pre><p>Parse and sort the circuit. See <a href="#JosephsonCircuits.parsecircuit-Tuple{Any}"><code>parsecircuit</code></a>, <a href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>sortnodes</code></a> for more explanation.</p><p><strong>Arguments</strong></p><ul><li><code>circuit</code>: vector of tuples each of which contain the component name, the   first node, the second node, and the component value. The first three must   be strings.</li></ul><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first. In other words, order the nodes in the order they are found in   <code>circuit</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc))
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj))
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
println(parsesortcircuit(circuit))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 3 3; 1 1 1 3 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], String[], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;C1&quot;, &quot;Lj1&quot;, &quot;C2&quot;], [:P, :I, :R, :C, :Lj, :C], Num[1, Ipump, Rleft, Cc, Lj, Cj], Dict(&quot;I1&quot; =&gt; 2, &quot;C1&quot; =&gt; 4, &quot;C2&quot; =&gt; 6, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;Lj1&quot; =&gt; 5), 3)</code></pre><pre><code class="language-julia hljs">@variables Ipump Rleft L1 L2 C2
Kfun(L) = sin(L);@register_symbolic Kfun(L1)
circuit = Tuple{String,String,String,Num}[]
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;L1&quot;,&quot;1&quot;,&quot;0&quot;,L1)) 
push!(circuit,(&quot;K1&quot;,&quot;L1&quot;,&quot;L2&quot;,Kfun(L1)))
push!(circuit,(&quot;L2&quot;,&quot;2&quot;,&quot;0&quot;,L2)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,C2))
println(parsesortcircuit(circuit))

# output
JosephsonCircuits.ParsedSortedCircuit([2 2 2 2 0 3 3; 1 1 1 1 0 1 1], [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], [&quot;L1&quot;, &quot;L2&quot;], [&quot;P1&quot;, &quot;I1&quot;, &quot;R1&quot;, &quot;L1&quot;, &quot;K1&quot;, &quot;L2&quot;, &quot;C2&quot;], [:P, :I, :R, :L, :K, :L, :C], Num[1, Ipump, Rleft, L1, Kfun(L1), L2, C2], Dict(&quot;L1&quot; =&gt; 4, &quot;I1&quot; =&gt; 2, &quot;L2&quot; =&gt; 6, &quot;C2&quot; =&gt; 7, &quot;R1&quot; =&gt; 3, &quot;P1&quot; =&gt; 1, &quot;K1&quot; =&gt; 5), 3)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.parsespicevariable-Tuple{String}"><a class="docstring-binding" href="#JosephsonCircuits.parsespicevariable-Tuple{String}"><code>JosephsonCircuits.parsespicevariable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsespicevariable(variable::String)</code></pre><p>Parse a variable name string into the variable name and node number. Will this work with arbitrary node strings?</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.parsespicevariable(&quot;V1(5)&quot;)
(&quot;V1&quot;, 5)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;V1&quot;)
(&quot;V&quot;, 1)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;V-1&quot;)
(&quot;V&quot;, 1)

julia&gt; JosephsonCircuits.parsespicevariable(&quot;frequency&quot;)
(&quot;frequency&quot;, &quot;frequency&quot;)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.phimatrixtovector!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.phimatrixtovector!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><code>JosephsonCircuits.phimatrixtovector!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phimatrixtovector!(phivector::Vector, phimatrix::Array,
    indexmap::Vector{Int}, conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int}, Nbranches::Int)</code></pre><p>The harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts an array to a vector with the above properties.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]
conjsourceindices = [16, 6]
conjtargetindices = [21, 31]
Nbranches = 1

phivector = zeros(Complex{Float64}, Nbranches*length(freqindexmap))
phimatrix = [0.0 + 0.0im 0.0 + 3.0im 0.0 + 0.0im 0.0 + 6.0im 0.0 - 6.0im 0.0 + 0.0im 0.0 - 3.0im; 0.0 + 1.0im 0.0 + 0.0im 0.0 + 5.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 7.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 4.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 8.0im; 0.0 + 2.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im;;;]

JosephsonCircuits.phimatrixtovector!(phivector,
    phimatrix,
    freqindexmap,
    conjsourceindices,
    conjtargetindices,
    Nbranches,
)
phivector

# output
8-element Vector{ComplexF64}:
 0.0 + 1.0im
 0.0 + 2.0im
 0.0 + 3.0im
 0.0 + 4.0im
 0.0 + 5.0im
 0.0 + 6.0im
 0.0 + 7.0im
 0.0 + 8.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.phivectortomatrix!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.phivectortomatrix!-Tuple{AbstractVector, AbstractArray, Vector{Int64}, Vector{Int64}, Vector{Int64}, Int64}"><code>JosephsonCircuits.phivectortomatrix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phivectortomatrix!(phivector::AbstractVector,phimatrix::AbstractArray,
    indexmap::Vector{Int},conjsourceindices::Vector{Int},
    conjtargetindices::Vector{Int},Nbranches::Int)</code></pre><p>The harmonic balance method requires a vector with all of the conjugate symmetric terms removed and potentially other terms dropped if specified by the user ( for example, intermodulation products which are not of interest) whereas the Fourier transform operates on multidimensional arrays with the proper conjugate symmetries and with dropped terms set to zero. This function converts a vector to an array with the above properties.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">freqindexmap = [2, 4, 6, 8, 12, 16, 27, 33]
conjsourceindices = [16, 6]
conjtargetindices = [21, 31]
Nbranches = 1

phivector = 1im.*Complex.(1:Nbranches*length(freqindexmap));
phimatrix=zeros(Complex{Float64},5,7,1)

JosephsonCircuits.phivectortomatrix!(phivector,
    phimatrix,
    freqindexmap,
    conjsourceindices,
    conjtargetindices,
    Nbranches,
)
phimatrix

# output
5×7×1 Array{ComplexF64, 3}:
[:, :, 1] =
 0.0+0.0im  0.0+3.0im  0.0+0.0im  0.0+6.0im  0.0-6.0im  0.0+0.0im  0.0-3.0im
 0.0+1.0im  0.0+0.0im  0.0+5.0im  0.0+0.0im  0.0+0.0im  0.0+7.0im  0.0+0.0im
 0.0+0.0im  0.0+4.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+8.0im
 0.0+2.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.pivot_rows-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.pivot_rows-Tuple{Any, Any}"><code>JosephsonCircuits.pivot_rows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pivot_rows(A11,A21)</code></pre><p>Return true if pivoting during LU decomposition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables A21;JosephsonCircuits.pivot_rows(0,A21)
true

julia&gt; @variables A11 A21;JosephsonCircuits.pivot_rows(A11,A21)
false</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.pivot_rows-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Union{Complex{T}, T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#JosephsonCircuits.pivot_rows-Union{Tuple{T}, Tuple{Union{Complex{T}, T}, Union{Complex{T}, T}}} where T&lt;:AbstractFloat"><code>JosephsonCircuits.pivot_rows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pivot_rows(A11::Union{T,Complex{T}},
A21::Union{T,Complex{T}}) where {T&lt;:AbstractFloat}</code></pre><p>Return true if pivoting during LU decomposition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.pivot_rows(0.1+0.0im,0.9+0.1im)
true

julia&gt; JosephsonCircuits.pivot_rows(0.9+0.1im,0.1+0.0im)
false</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.plan_applynl-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T"><code>JosephsonCircuits.plan_applynl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plan_applynl(fd::Array{Complex{T}})</code></pre><p>Creates an empty time domain data array and the inverse and forward plans for the RFFT of an array of frequency domain data. See also <a href="#JosephsonCircuits.applynl!-Union{Tuple{T}, Tuple{Array{Complex{T}}, Array{T}, Any, Any, Any}} where T"><code>applynl!</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}"><a class="docstring-binding" href="#JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.printsymmetries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printsymmetries(freq::Frequencies)</code></pre><p>See  <a href="#JosephsonCircuits.printsymmetries-Tuple{JosephsonCircuits.Frequencies}"><code>printsymmetries</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,)))
3-element Vector{Int64}:
 0
 0
 0

julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsdft((2,)))
5-element Vector{Int64}:
  0
  1
  2
 -2
 -1

julia&gt; JosephsonCircuits.printsymmetries(JosephsonCircuits.calcfreqsrdft((2,2)))
3×5 Matrix{Int64}:
 0  1  3  -3  -1
 0  0  0   0   0
 0  2  4  -4  -2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.printsymmetries-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.printsymmetries-Union{Tuple{N}, Tuple{NTuple{N, Int64}, NTuple{N, Int64}}} where N"><code>JosephsonCircuits.printsymmetries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printsymmetries(Nw::NTuple{N, Int}, Nt::NTuple{N, Int})</code></pre><p>Print the conjugate symmetries in the multi-dimensional DFT or RDFT from the dimensions of the signal in the frequency domain and the time domain. Negative numbers indicate that element is the complex conjugate of the corresponding positive number. A zero indicates that element has no corresponding complex conjugate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.printsymmetries((3,),(4,))
3-element Vector{Int64}:
 0
 0
 0

julia&gt; JosephsonCircuits.printsymmetries((4,),(4,))
4-element Vector{Int64}:
  0
  1
  0
 -1

julia&gt; JosephsonCircuits.printsymmetries((3,3),(4,3))
3×3 Matrix{Int64}:
 0  1  -1
 0  0   0
 0  2  -2

julia&gt; JosephsonCircuits.printsymmetries((4,3),(4,3))
4×3 Matrix{Int64}:
  0   2  -2
  1   3   5
  0   4  -4
 -1  -5  -3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, Any}"><a class="docstring-binding" href="#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, Any}"><code>JosephsonCircuits.processnode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processnode(uniquenodedict::Dict{String, Int},
    uniquenodevector::Vector{String},node)</code></pre><p>Return the node index when given a node. Add the node string to the vector <code>uniquenodevector</code> and the dictionary <code>uniquenodedict</code> with the node string as the key and the node index (index at which it appears in  <code>uniquenodevector</code>) as the value. If &quot;node&quot; is not a string, make it a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,15))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;15&quot;]
Dict(&quot;10&quot; =&gt; 1, &quot;15&quot; =&gt; 2)</code></pre><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,:A))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;A&quot;]
Dict(&quot;A&quot; =&gt; 2, &quot;10&quot; =&gt; 1)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, String}"><a class="docstring-binding" href="#JosephsonCircuits.processnode-Tuple{Dict{String, Int64}, Vector{String}, String}"><code>JosephsonCircuits.processnode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processnode(uniquenodedict::Dict{String, Int},
    uniquenodevector::Vector{String},node::String)</code></pre><p>Return the node index when given a node. Add the node string to the vector <code>uniquenodevector</code> and the dictionary <code>uniquenodedict</code> with the node string as the key and the node index (index at which it appears in <code>uniquenodevector</code>) as the value.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,&quot;15&quot;))
println(uniquenodevector)
println(uniquenodedict)

# output
2
[&quot;10&quot;, &quot;15&quot;]
Dict(&quot;10&quot; =&gt; 1, &quot;15&quot; =&gt; 2)</code></pre><pre><code class="language-julia hljs">uniquenodedict = Dict(&quot;10&quot; =&gt;1)
uniquenodevector = [&quot;10&quot;]
println(JosephsonCircuits.processnode(uniquenodedict,uniquenodevector,&quot;10&quot;))
println(uniquenodevector)
println(uniquenodedict)

# output
1
[&quot;10&quot;]
Dict(&quot;10&quot; =&gt; 1)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.pushval!-Tuple{Vector, Any, Any, Bool}"><a class="docstring-binding" href="#JosephsonCircuits.pushval!-Tuple{Vector, Any, Any, Bool}"><code>JosephsonCircuits.pushval!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pushval!(V::Vector, val, c, invert::Bool)</code></pre><p>Append the value <code>val</code> of capacitance or conductance to the vector <code>V</code>. Scale the value by <code>c</code>. If <code>invert = true</code>, append <code>c/val</code> otherwise append <code>c*val</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,false);V
1-element Vector{Float64}:
 -2.0

julia&gt; V = Array{Float64, 1}(undef, 0);JosephsonCircuits.pushval!(V,2.0,-1.0,true);V
1-element Vector{Float64}:
 -0.5</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.remove_edge!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.remove_edge!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.remove_edge!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_edge!(g,src_node,edge_index)</code></pre><p>Remove an edge from graph <code>g</code> specified by the source node <code>src_node</code> and the edge index <code>edge_index</code> in the forward adjacency list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g=JosephsonCircuits.Graphs.SimpleDiGraphFromIterator(JosephsonCircuits.tuple2edge([(1,1),(2,1),(2,3)]));JosephsonCircuits.remove_edge!(g,1,1)
1</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.removeconjfreqs-Tuple{JosephsonCircuits.Frequencies}"><a class="docstring-binding" href="#JosephsonCircuits.removeconjfreqs-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.removeconjfreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">removeconjfreqs(frequencies::Frequencies{N})</code></pre><p>Return a new Frequencies struct with the conjugate symmetric terms in the DFT or RDFT removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removeconjfreqs(JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)]))
JosephsonCircuits.Frequencies{1}((1,), (2,), (3,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; frequencies = JosephsonCircuits.Frequencies{2}((2,2), (3, 5), (4, 5), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(3, 2), CartesianIndex(1, 3), CartesianIndex(2, 3), CartesianIndex(3, 3), CartesianIndex(1, 4), CartesianIndex(2, 4), CartesianIndex(3, 4), CartesianIndex(1, 5), CartesianIndex(2, 5), CartesianIndex(3, 5)], [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2), (0, -2), (1, -2), (2, -2), (0, -1), (1, -1), (2, -1)]);JosephsonCircuits.removeconjfreqs(frequencies).modes
11-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (0, 1)
 (1, 1)
 (2, 1)
 (0, 2)
 (1, 2)
 (2, 2)
 (1, -2)
 (1, -1)

julia&gt; JosephsonCircuits.removeconjfreqs(JosephsonCircuits.calcfreqsrdft((2,2))).modes
11-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (0, 1)
 (1, 1)
 (2, 1)
 (0, 2)
 (1, 2)
 (2, 2)
 (1, -2)
 (1, -1)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{CartesianIndex{N}, 1}}} where N"><code>JosephsonCircuits.removefreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">removefreqs(frequencies::Frequencies{N},
    removecoords::AbstractVector{CartesianIndex{N}})</code></pre><p>Return a new Frequency struct with the coordinates and modes for the modes in removemodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(2,), CartesianIndex(3,)], [(1,), (2,)])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[CartesianIndex(1,),CartesianIndex(2,),CartesianIndex(3,),CartesianIndex(4,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),CartesianIndex{1}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{NTuple{N, Int64}, 1}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.removefreqs-Union{Tuple{N}, Tuple{JosephsonCircuits.Frequencies{N}, AbstractArray{NTuple{N, Int64}, 1}}} where N"><code>JosephsonCircuits.removefreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">removefreqs(frequencies::Frequencies{N},
    removemodes::AbstractVector{NTuple{N,Int}})</code></pre><p>Return a new Frequency struct with the coordinates and modes for the modes in removemodes removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(2,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,)], [(0,), (1,)])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[(0,),(1,),(2,),(3,)])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[], Tuple{Int64}[])

julia&gt; JosephsonCircuits.removefreqs(JosephsonCircuits.calcfreqsrdft((2,)),Tuple{Int64}[])
JosephsonCircuits.Frequencies{1}((2,), (3,), (4,), CartesianIndex{1}[CartesianIndex(1,), CartesianIndex(2,), CartesianIndex(3,)], [(0,), (1,), (2,)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.showstruct-Tuple{IO, Any}"><a class="docstring-binding" href="#JosephsonCircuits.showstruct-Tuple{IO, Any}"><code>JosephsonCircuits.showstruct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">showstruct(io::IO,out)</code></pre><p>Recursively print the struct <code>out</code> to the IOStream or IOBuffer <code>io</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.warmupnumericmatrices())
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], [1.0e-13, -1.0e-13, -1.0e-13, 1.1e-12], 2, 2), sparse([1], [1], [0.02], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], [1.0e-9], 2), sparsevec([2], [1.0e-9], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [2], Int64[], 1.0e-9, Real[1, 50.0, 1.0e-13, 1.0e-9, 1.0e-12])

julia&gt; JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.warmupsyms())</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sincosnl-Tuple{Matrix{ComplexF64}}"><a class="docstring-binding" href="#JosephsonCircuits.sincosnl-Tuple{Matrix{ComplexF64}}"><code>JosephsonCircuits.sincosnl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sincosnl(am::Array{Complex{Float64},2})</code></pre><p>Applies the junction nonlinearity to a vector of Fourier coefficients of the phases across the junction of size 2*m by (Nnodes-1) where m is the number of pump harmonics (0w, 1w, 2w, 3w, etc). To save time, this calculates both the sine and cosine nonlinearities at the same time. If the input is odd harmonics, the sine terms will also be odd harmonics the cosine terms will be even harmonics.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0.001+0im;0 0]),ComplexF64[1.0 + 0.0im 1.000999499833375 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im])
true

julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0;0 0;0 0; 0 0]), ComplexF64[0.99999900000025 + 0.0im 1.0 + 0.0im; 0.0009999995000000916 + 0.0im 0.0 + 0.0im; -4.999998333421463e-7 + 0.0im 0.0 + 0.0im; -1.6666664597909941e-10 + 0.0im 0.0 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0 + 0.0im])
true

julia&gt; isapprox(JosephsonCircuits.sincosnl([0 0;0.001+0im 0.25+0im;0 0;0 0; 0 0]),ComplexF64[0.99999900000025 + 0.0im 0.9384698079924576 + 0.0im; 0.0009999995000000916 + 0.0im 0.24226844566945333 + 0.0im; -4.999998333421463e-7 + 0.0im -0.03060435952740681 + 0.0im; -1.6666664597909941e-10 + 0.0im -0.0025556763673518224 + 0.0im; 8.337774914934926e-14 + 0.0im 0.0003214729527288296 + 0.0im])
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sincosnloddtoboth-Tuple{Vector{ComplexF64}, Int64, Int64}"><a class="docstring-binding" href="#JosephsonCircuits.sincosnloddtoboth-Tuple{Vector{ComplexF64}, Int64, Int64}"><code>JosephsonCircuits.sincosnloddtoboth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sincosnloddtoboth(amodd::Array{Complex{Float64},1},Nbranches::Int,m::Int)</code></pre><p>Applies the junction nonlinearity to a vector of branch fluxes of length <code>Nbranches*m</code> where <code>m</code> is the number of odd pump harmonics (1w, 3w, 5w, etc). The ordering is (mode 1, node 1), (mode 2, node 1) ... (mode 1, node 2) ... Returns even AND odd terms in a 2d array with dimensions 2*m by Nbranches.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isapprox(JosephsonCircuits.sincosnloddtoboth([0.5+0.0im,0,0,0],1,4),ComplexF64[0.765197686557965 + 0.0im; 0.44005058574495276 + 0.0im; -0.11490348493140057 + 0.0im; -0.019563353994648498 + 0.0im; 0.0024766387010484486 + 0.0im; 0.0002497629794614272 + 0.0im; -2.084411456066653e-5 + 0.0im; -3.0046516347986037e-6 + 0.0im;;])
true

julia&gt; isapprox(JosephsonCircuits.sincosnloddtoboth([0.02+0.0im,0,0.01+0.0im,0],2,2),ComplexF64[0.9996000399980445 + 0.0im 0.9999000024999694 + 0.0im; 0.019996000293322436 + 0.0im 0.009999500009166587 + 0.0im; -0.00019996666853328016 + 0.0im -4.999791669583568e-5 + 0.0im; -2.6664000106757513e-6 + 0.0im -3.3332500006440685e-7 + 0.0im])
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.solveS!-NTuple{23, Any}"><a class="docstring-binding" href="#JosephsonCircuits.solveS!-NTuple{23, Any}"><code>JosephsonCircuits.solveS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solveS!(Se, Si, portse, portsi, gammaii, See, Sei, Sie, Sii,
    See_indices, Sei_indices, Sie_indices, Sii_indices, networkdata,
    nbatches, factorization, internal_ports)</code></pre><p>In-place version of <code>solveS</code>. See <a href="#JosephsonCircuits.solveS-Tuple{AbstractVector, AbstractVector}"><code>solveS</code></a> for description. The use- case for this function is to perform in-place updates of a network connection, for example, by changing the arrays that are referenced in <code>networks</code> then recomputing the scattering parameters for the connected system.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])];
connections = [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]];
init = JosephsonCircuits.solveS_initialize(networks, connections);
JosephsonCircuits.solveS!(init...)

# output
(S = [0.5 0.5; 0.5 0.5], ports = [(&quot;S1&quot;, 2), (&quot;S2&quot;, 1)], Sinternal = Float64[], portsinternal = [(&quot;S1&quot;, 1), (&quot;S2&quot;, 2)])</code></pre><p><strong>References</strong></p><p>V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.solveS-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.solveS-Tuple{AbstractVector, AbstractVector}"><code>JosephsonCircuits.solveS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solveS(networks, connections; small_splitters::Bool = true,
    factorization = KLUfactorization(), internal_ports::Bool = false,
    nbatches::Integer = Base.Threads.nthreads())</code></pre><p>Perform the connections between the networks in <code>networks</code> specified by the vector of vectors of tuples <code>connections</code>. Return the sparse matrix of scattering parameters for the external ports <code>S</code> and the external ports <code>ports</code>. Also return the internal port scattering parameters <code>Sinternal</code> and the internal ports <code>portsinternal</code>.</p><p><strong>Arguments</strong></p><ul><li><code>networks</code>: a vector of tuples of the network name, scattering parameter   matrix, and optionally the ports  such as   [(&quot;network1name&quot;,rand(Complex{Float64},2,2))] or   [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])].</li><li><code>connections::AbstractVector{&lt;:AbstractVector{Tuple{T,Int}}}</code>: a vector of   vectors of tuples of networks names and ports such as [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]]   or [[(&quot;network1name&quot;,1),(&quot;network2name&quot;,2)]] where network1 and network2   are the two networks being connected and 1 and 2 are integers describing   the ports to connect.</li></ul><p><strong>Keywords</strong></p><ul><li><code>small_splitters::Bool = true</code>: if true, then generate any N port splitter   by combining (N-2) 3 port splitters. if false, then make the N port   splitter and connect the components to it.</li><li><code>factorization = KLUfactorization()</code>: use KLU factorization by default.    JosephsonCircuits.LUfactorization() is another good choice. Keyword   arguments can be passed to the solver as keyword arguments to these   functions.</li><li><code>internal_ports::Bool = false</code>: return the scattering parameters for the   internal ports.</li><li><code>nbatches::Integer = Base.Threads.nthreads()</code>: the number of batches to run   on threads. Defaults to the number of threads with which Julia was   launched.</li></ul><p><strong>Returns</strong></p><ul><li><code>S</code>: sparse matrix of scattering parameters for the external ports.</li><li><code>ports</code>: the vector of tuples of network name and port number for the   external ports.</li><li><code>Sinternal</code>: sparse matrix of scattering parameters for the internal ports.</li><li><code>portsinternal</code>: the vector of tuples of network name and port number for the   internal ports.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5])];
connections = [[(&quot;S1&quot;,1),(&quot;S2&quot;,2)]];
JosephsonCircuits.solveS(networks,connections;internal_ports=true)

# output
(S = [0.5 0.5; 0.5 0.5], ports = [(&quot;S1&quot;, 2), (&quot;S2&quot;, 1)], Sinternal = [1.0 0.0; 0.5 0.5], portsinternal = [(&quot;S1&quot;, 1), (&quot;S2&quot;, 2)])</code></pre><pre><code class="language-julia hljs">networks = [(&quot;S1&quot;,[0.0 1.0;1.0 0.0]),(&quot;S2&quot;,[0.5 0.5;0.5 0.5],[(&quot;S3&quot;,5),(&quot;S3&quot;,6)])];
connections = [(&quot;S1&quot;,&quot;S3&quot;,1,6)];
JosephsonCircuits.solveS(networks,connections)

# output
(S = [0.5 0.5; 0.5 0.5], ports = [(&quot;S1&quot;, 2), (&quot;S3&quot;, 5)], Sinternal = Float64[], portsinternal = [(&quot;S1&quot;, 1), (&quot;S3&quot;, 6)])</code></pre><p><strong>References</strong></p><p>V. A. Monaco and P. Tiberio, &quot;Computer-Aided Analysis of Microwave Circuits,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 22, no. 3, pp. 249-263, Mar. 1974, doi: 10.1109/TMTT.1974.1128208.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.solveS_update!-NTuple{10, Any}"><a class="docstring-binding" href="#JosephsonCircuits.solveS_update!-NTuple{10, Any}"><code>JosephsonCircuits.solveS_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solveS_update!(See, Sei, Sie, Sii, See_indices, Sei_indices,
    Sie_indices, Sii_indices, networkdata, i)</code></pre><p>Update the sparse matrices <code>See</code>, <code>Sei</code>, <code>Sie</code>, and <code>Sii</code> using the indices from <code>See_indices</code>, <code>Sei_indices</code>, <code>Sie_indices</code>, and <code>Sii_indices</code> which are indices into <code>networkdata</code> with frequency index <code>i</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><a class="docstring-binding" href="#JosephsonCircuits.sortnodes-Tuple{Vector{String}, Vector{Int64}}"><code>JosephsonCircuits.sortnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sortnodes(uniquenodevector::Vector{String},
    nodeindexvector::Vector{Int};sorting=:name)</code></pre><p>Sort the unique node names in <code>uniquenodevector</code> according to the specified sorting scheme, always placing the ground node at the beginning.</p><p>Return the sorted <code>uniquenodevector</code> and <code>nodeindexvector</code> (with the vector reshaped from a vector of length 2*Nnodes into a matrix with dimensions 2 by Nnodes).</p><p><strong>Keywords</strong></p><ul><li><code>sorting = :name</code>: Sort the vector of strings. This always works but leads   to results like &quot;101&quot; comes before &quot;11&quot;.</li><li><code>sorting = :number</code>: Convert the node strings to integer and sort by these   (this errors if the nodes names cannot be converted to integers).</li><li><code>sorting = :none</code>: Don&#39;t perform any sorting except to place the ground node   first.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:none);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;101&quot;, &quot;111&quot;, &quot;11&quot;]
[2 2 2 2 3 3 4; 1 1 1 3 1 1 2]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:name);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;101&quot;, &quot;11&quot;, &quot;111&quot;]
[2 2 2 2 4 4 3; 1 1 1 4 1 1 2]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;101&quot;,&quot;0&quot;,&quot;111&quot;,&quot;11&quot;],[1,2,1,2,1,2,1,3,3,2,3,2,4,1],sorting=:number);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;11&quot;, &quot;101&quot;, &quot;111&quot;]
[3 3 3 3 4 4 2; 1 1 1 4 1 1 3]

julia&gt; nodenames,nodeindexarray=JosephsonCircuits.sortnodes([&quot;1&quot;, &quot;0&quot;, &quot;2&quot;],[1, 2, 1, 2, 1, 2, 1, 2, 0, 0, 3, 2, 3, 2],sorting=:number);println(nodenames);println(nodeindexarray);
[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]
[2 2 2 2 0 3 3; 1 1 1 1 0 1 1]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spaddkeepzeros-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#JosephsonCircuits.spaddkeepzeros-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>JosephsonCircuits.spaddkeepzeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spaddkeepzeros(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Add sparse matrices <code>A</code> and <code>B</code> and return the result, keeping any structural zeros, unlike the default Julia sparse matrix addition functions. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = JosephsonCircuits.SparseArrays.sprand(10,10,0.2); B = JosephsonCircuits.SparseArrays.sprand(10,10,0.2);JosephsonCircuits.spaddkeepzeros(A,B) == A+B
true</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,0],2,2);
B = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [1,1],2,2);
JosephsonCircuits.spaddkeepzeros(A,B)

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  0
 ⋅  3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, LinearAlgebra.Diagonal, SparseArrays.SparseMatrixCSC, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, LinearAlgebra.Diagonal, SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseadd!(A::SparseMatrixCSC, c::Number, Ad::Diagonal,
    As::SparseMatrixCSC, indexmap::Vector)</code></pre><p>Add sparse matrices <code>A</code> and <code>c*Ad*As</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,Ad,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  5
 ⋅  2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC,
    Ad::Diagonal, indexmap)</code></pre><p>Add sparse matrices <code>A</code> and <code>c*As*Ad</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,As,Ad,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  -19
 ⋅    2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, Vector}"><a class="docstring-binding" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, Vector}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseadd!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC, indexmap)</code></pre><p>Add sparse matrices <code>A</code> and <code>c*As</code> and return the result in <code>A</code>. The sparse matrix <code>As</code> must have nonzero entries only in a subset of the positions in <code>A</code> which have nonzero (structural zeros are ok) entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,2,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 7  5
 ⋅  2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}"><a class="docstring-binding" href="#JosephsonCircuits.sparseadd!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Any}"><code>JosephsonCircuits.sparseadd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseadd!(A::SparseMatrixCSC, As::SparseMatrixCSC, indexmap)</code></pre><p>Add sparse matrices <code>A</code> and <code>As</code> and return the result in <code>A</code> without performing any allocations. This is only possible if the positions of elements in <code>As</code> are a subset of the positions of elements in <code>A</code>. The <code>indexmap</code> can be generated with <a href="#JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>sparseaddmap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3,4],2,2)
indexmap = JosephsonCircuits.sparseaddmap(A,As)
JosephsonCircuits.sparseadd!(A,As,indexmap)
A

# output
2×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 4  1
 ⋅  2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseaddconjsubst!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Any, LinearAlgebra.Diagonal, LinearAlgebra.Diagonal, Vector, Any}"><a class="docstring-binding" href="#JosephsonCircuits.sparseaddconjsubst!-Tuple{SparseArrays.SparseMatrixCSC, Number, SparseArrays.SparseMatrixCSC, LinearAlgebra.Diagonal, Any, LinearAlgebra.Diagonal, LinearAlgebra.Diagonal, Vector, Any}"><code>JosephsonCircuits.sparseaddconjsubst!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseaddconjsubst!(A::SparseMatrixCSC, c::Number, As::SparseMatrixCSC,
    Ad::Diagonal, indexmap, conjflag::Diagonal, wmodesm::Diagonal,
    freqsubstindices::Vector, symfreqvar)</code></pre><p>Perform the operation <code>A+c*As*Ad</code> and return the result in <code>A</code>. Take the complex conjugate of <code>As</code> for any column where <code>conjflag = true</code>.</p><p>The sparse matrix <code>As</code> must have nonzero elements only in a subset of the  positions in <code>A</code> which has nonzero lements.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1.0+1.0im,2.0+1.0im,-3.0+0.0im],2,2)
Ad = JosephsonCircuits.LinearAlgebra.Diagonal([1,-2])
As = JosephsonCircuits.SparseArrays.sparse([1,1], [1,2], [3.0+2.0im,4.0+3.0im],2,2)
wmodesm = JosephsonCircuits.LinearAlgebra.Diagonal([-1,1])
indexmap = JosephsonCircuits.sparseaddmap(A,As)
freqsubstindices  = JosephsonCircuits.symbolicindices(As)
JosephsonCircuits.sparseaddconjsubst!(A,2,As,Ad,indexmap,wmodesm .&lt; 0,wmodesm,freqsubstindices,nothing)
A

# output
2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 3 stored entries:
 7.0-3.0im  -19.0-12.0im
     ⋅        2.0+1.0im</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#JosephsonCircuits.sparseaddmap-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>JosephsonCircuits.sparseaddmap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparseaddmap(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Return a vector of length <code>nnz(B)</code> which maps the indices of elements of <code>B</code> in <code>B.nzval</code> to the corresponding indices in <code>A.nzval</code>. The sparse matrix <code>B</code> must have elements in a subset of the positions in <code>A</code> which have nonzero entries (structural zeros are elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1], [2], [4],2,2)
JosephsonCircuits.sparseaddmap(A,As)

# output
1-element Vector{Int64}:
 2</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,2,-3],2,2)
As = JosephsonCircuits.SparseArrays.sparse([1,2], [1,2], [4,2],2,2)
JosephsonCircuits.sparseaddmap(A,As)

# output
2-element Vector{Int64}:
 1
 3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spice_hb_load-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.spice_hb_load-Tuple{Any}"><code>JosephsonCircuits.spice_hb_load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spice_hb_load(filename)</code></pre><p>Load a Xyce harmonic balance simulation.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spice_raw_load-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.spice_raw_load-Tuple{Any}"><code>JosephsonCircuits.spice_raw_load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spice_raw_load(filename)</code></pre><p>Parse the binary raw output file from WRSPICE or Xyce. Tested for transient analysis and frequency domain analysis. The file format is documented in the <a href="http://www.srware.com/xictools/docs/wrsmanual-4.3.13.pdf">WRSPICE manual</a> in Appendix 1, File Formats, A.1 Rawfile Format.</p><p>The Xyce rawfile format is very similar and described <a href="https://xyce.sandia.gov/files/xyce/Reference_Guide.pdf#section.8.2">here</a>.</p><p>The function outputs a header, the times/frequencies, the currents, and the voltages. The voltage and current arrays have dimensions nVoltages by nPoints and nCurrents by nPoints.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spice_run-Tuple{AbstractVector, Any}"><a class="docstring-binding" href="#JosephsonCircuits.spice_run-Tuple{AbstractVector, Any}"><code>JosephsonCircuits.spice_run</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spice_run(input::AbstractVector,spicecmd; ntasks = Threads.nthreads())</code></pre><p>If the input to wrspice_run() is an array of strings, then call multiple processes in parallel. The number of parallel processes is decided from Threads.nthreads(). It can be changed manually.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spice_run-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.spice_run-Tuple{Any, Any}"><code>JosephsonCircuits.spice_run</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spice_run(input, spicecmd::String)</code></pre><p>Argument is a string or command containing the input commands for wrspice.  This function saves the string to disk, runs spice, parses the results with wrsplice_load(), then returns those parsed results.</p><p>The input should not should have a file name listed after the write command in the .control block so that we can specify the raw output file with a command line argument.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.spmatmul!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{Bool}}"><a class="docstring-binding" href="#JosephsonCircuits.spmatmul!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{Bool}}"><code>JosephsonCircuits.spmatmul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spmatmul!(C::SparseMatrixCSC, A::SparseMatrixCSC, B::SparseMatrixCSC,
    xb::Vector{Bool})</code></pre><p>Non-allocating sparse matrix multiplication of <code>A</code> and <code>B</code> when sparsity pattern of product <code>C</code> is known. Based on spmatmul from <a href="https://github.com/JuliaSparse/SparseArrays.jl/blob/main/src/linalg.jl">SparseArrays.jl</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = JosephsonCircuits.sprand(100,100,0.1);b = JosephsonCircuits.sprand(100,100,0.1);c = a*b; d = copy(c);xb = fill(false, size(a,1));JosephsonCircuits.spmatmul!(c,a,b,xb);c == d
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sprandsubset"><a class="docstring-binding" href="#JosephsonCircuits.sprandsubset"><code>JosephsonCircuits.sprandsubset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sprandsubset(A::SparseMatrixCSC, p::AbstractFloat, dropzeros = true)</code></pre><p>Given a sparse matrix <code>A</code>, return a sparse matrix with random values in some fraction of the non-zero elements with probability p. If <code>dropzeros = false</code>, then the zeros will be retained as structural zeros otherwise they are dropped.</p><p>This is used for testing non-allocating sparse matrix addition.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sprand(2,2,0.5)
B = JosephsonCircuits.sprandsubset(A, 0.1)
length(A.nzval) &gt;= length(B.nzval)

# output
true</code></pre><pre><code class="language-julia hljs">A = JosephsonCircuits.SparseArrays.sprand(100,100,0.5)
B = JosephsonCircuits.sprandsubset(A, 0.1)
length(A.nzval) &gt;= length(B.nzval)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.storeuniqueloops!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.storeuniqueloops!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.storeuniqueloops!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">storeuniqueloops!(lvarray, vmap, ul)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],[[1,2,3]]);lvarray
1-element Vector{Vector{Int64}}:
 [1, 2, 3]

julia&gt; lvarray = Vector{Int}[];JosephsonCircuits.storeuniqueloops!(lvarray,[1, 2, 3],Vector{Int64}[]);lvarray
1-element Vector{Vector{Int64}}:
 []</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sumbranchvalues!-Tuple{Symbol, Int64, Int64, Vector, Dict, Dict}"><a class="docstring-binding" href="#JosephsonCircuits.sumbranchvalues!-Tuple{Symbol, Int64, Int64, Vector, Dict, Dict}"><code>JosephsonCircuits.sumbranchvalues!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sumbranchvalues!(type::Symbol, node1::Int, node2::Int,componentvalues::Vector,
    countdict, indexdict)</code></pre><p>Given a branch and a type, return the sum of all of the values of the same type and branch. The sum will behave differently depending on the type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vvn = Real[1, 50.0, 1.0e-13, 2.0e-9, 2.0e-9, 5.0e-13, 5.0e-13, 0.1]
countdict = Dict((:L, 1, 3) =&gt; 2, (:R, 1, 2) =&gt; 1, (:P, 1, 2) =&gt; 1, (:C, 1, 3) =&gt; 2, (:C, 2, 3) =&gt; 1, (:I, 1, 3) =&gt; 1)
indexdict = Dict((:C, 2, 3, 1) =&gt; 3, (:C, 1, 3, 1) =&gt; 6, (:R, 1, 2, 1) =&gt; 2, (:L, 1, 3, 1) =&gt; 4, (:C, 1, 3, 2) =&gt; 7, (:L, 1, 3, 2) =&gt; 5, (:P, 1, 2, 1) =&gt; 1, (:I, 1, 3, 1) =&gt; 8)
println(JosephsonCircuits.sumbranchvalues!(:C, 1, 3, vvn, countdict, indexdict))

# output
(true, 1.0e-12, 6)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.sumvalues-Tuple{Symbol, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.sumvalues-Tuple{Symbol, Any, Any}"><code>JosephsonCircuits.sumvalues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sumvalues(type::Symbol, value1, value2)</code></pre><p>Sum together two values in different ways depending on the circuit component type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.sumvalues(:L, 1.0, 4.0)
0.8

julia&gt; JosephsonCircuits.sumvalues(:Lj, 1.0, 4.0)
0.8

julia&gt; JosephsonCircuits.sumvalues(:C, 1.0, 4.0)
5.0

julia&gt; JosephsonCircuits.sumvalues(:K, 1.0, 4.0)
5.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.symbolicindices-Tuple{Any}"><a class="docstring-binding" href="#JosephsonCircuits.symbolicindices-Tuple{Any}"><code>JosephsonCircuits.symbolicindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbolicindices(A)</code></pre><p>Return the indices in <code>A.nzval</code> where the elements of the matrix <code>A</code> are symbolic variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables w;A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [w,1.0,3*w+1]);println(A.nzval);JosephsonCircuits.symbolicindices(A)
Num[w, 1 + 3w, 1.0]
2-element Vector{Int64}:
 1
 2

julia&gt; A = JosephsonCircuits.SparseArrays.sparse([1,2,1], [1,2,2], [1,1.0,2+3im]);JosephsonCircuits.symbolicindices(A)
Int64[]</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.symbolicmatrices-Tuple{AbstractVector}"><a class="docstring-binding" href="#JosephsonCircuits.symbolicmatrices-Tuple{AbstractVector}"><code>JosephsonCircuits.symbolicmatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbolicmatrices(circuit; Nmodes = 1, sorting = :number)</code></pre><p>Return the symbolic matrices describing the circuit properties.</p><p>See also  <a href="#JosephsonCircuits.CircuitMatrices"><code>CircuitMatrices</code></a>, <a href="#JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><code>numericmatrices</code></a>, <a href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcCn</code></a>, <a href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcGn</code></a>, <a href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLb</code></a>,<a href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLjb</code></a>, <a href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>calcMb</code></a>, <a href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>calcinvLn</code></a>, <a href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>calcLmean</code></a>, <a href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportindicesnumbers</code></a>, <a href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportimpedanceindices</code></a>, and <a href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcnoiseportimpedanceindices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
JosephsonCircuits.testshow(stdout,symbolicmatrices(circuit))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[1 / Rleft], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Lj], 2), sparsevec([2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Lj], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.symbolicmatrices-Tuple{JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph}"><a class="docstring-binding" href="#JosephsonCircuits.symbolicmatrices-Tuple{JosephsonCircuits.ParsedSortedCircuit, JosephsonCircuits.CircuitGraph}"><code>JosephsonCircuits.symbolicmatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbolicmatrices(psc::ParsedSortedCircuit, cg::CircuitGraph;
Nmodes::Int = 1)</code></pre><p>Return the symbolic matrices describing the circuit properties.</p><p>See also  <a href="#JosephsonCircuits.CircuitMatrices"><code>CircuitMatrices</code></a>, <a href="#JosephsonCircuits.numericmatrices-Tuple{AbstractVector, Dict}"><code>numericmatrices</code></a>, <a href="#JosephsonCircuits.calcCn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcCn</code></a>, <a href="#JosephsonCircuits.calcGn-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Any, Any}"><code>calcGn</code></a>, <a href="#JosephsonCircuits.calcLb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLb</code></a>,<a href="#JosephsonCircuits.calcLjb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Any, Any}"><code>calcLjb</code></a>, <a href="#JosephsonCircuits.calcMb-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Dict, Vector, Dict, Any, Any}"><code>calcMb</code></a>, <a href="#JosephsonCircuits.calcinvLn-Tuple{SparseArrays.SparseVector, SparseArrays.SparseMatrixCSC, Any}"><code>calcinvLn</code></a>, <a href="#JosephsonCircuits.calcLmean-Tuple{Vector{Symbol}, Vector}"><code>calcLmean</code></a>, <a href="#JosephsonCircuits.calcportindicesnumbers-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportindicesnumbers</code></a>, <a href="#JosephsonCircuits.calcportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcportimpedanceindices</code></a>, and <a href="#JosephsonCircuits.calcnoiseportimpedanceindices-Tuple{Vector{Symbol}, Matrix{Int64}, Vector, Vector}"><code>calcnoiseportimpedanceindices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Ipump Rleft Cc Lj Cj
circuit = Vector{Tuple{String,String,String,Num}}(undef,0)
push!(circuit,(&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1))
push!(circuit,(&quot;I1&quot;,&quot;1&quot;,&quot;0&quot;,Ipump))
push!(circuit,(&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,Rleft))
push!(circuit,(&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,Cc)) 
push!(circuit,(&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,Lj)) 
push!(circuit,(&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,Cj))
psc = JosephsonCircuits.parsesortcircuit(circuit)
cg = JosephsonCircuits.calccircuitgraph(psc)
JosephsonCircuits.testshow(stdout,symbolicmatrices(psc,cg))

# output
JosephsonCircuits.CircuitMatrices(sparse([1, 2, 1, 2], [1, 1, 2, 2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Cc, -Cc, -Cc, Cc + Cj], 2, 2), sparse([1], [1], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[1 / Rleft], 2, 2), sparsevec(Int64[], Nothing[], 2), sparsevec(Int64[], Nothing[], 2), sparsevec([2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Lj], 2), sparsevec([2], SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}[Lj], 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse(Int64[], Int64[], Nothing[], 2, 2), sparse([1, 2], [1, 2], [1, 1], 2, 2), [1], [1], [3], Int64[], Lj, Any[1, Ipump, Rleft, Cc, Lj, Cj])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.testshow-Tuple{IO, SparseArrays.AbstractSparseVector}"><a class="docstring-binding" href="#JosephsonCircuits.testshow-Tuple{IO, SparseArrays.AbstractSparseVector}"><code>JosephsonCircuits.testshow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">testshow(io::IO,S)</code></pre><p>Print <code>S</code> to the IOStream or IOBuffer <code>io</code>. This is used to generate the inputs for testing purposes. The default <code>show</code> function doesn&#39;t always produce an output which can be evaluated as the input. For example, for sparse vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([1],[2],3))
sparsevec([1], [2], 3)

julia&gt; JosephsonCircuits.testshow(stdout,JosephsonCircuits.SparseArrays.sparsevec([],Nothing[],3))
sparsevec(Int64[], Nothing[], 3)

julia&gt; JosephsonCircuits.testshow(IOBuffer(),JosephsonCircuits.AxisKeys.KeyedArray(rand(Int8, 2,10), ([:a, :b], 10:10:100)))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.truncfreqs-Tuple{JosephsonCircuits.Frequencies}"><a class="docstring-binding" href="#JosephsonCircuits.truncfreqs-Tuple{JosephsonCircuits.Frequencies}"><code>JosephsonCircuits.truncfreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">truncfreqs(frequencies::Frequencies;
    dc = false, odd = true, even = false, maxintermodorder = Inf)</code></pre><p>Return a new Frequencies struct with the coordinates and modes truncated according to the user specified criteria.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2).modes
12-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (3, 0)
 (0, 1)
 (1, 1)
 (0, 2)
 (0, 3)
 (0, -3)
 (0, -2)
 (0, -1)
 (1, -1)

julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));dc=false,even=false,maxintermodorder=3).modes
10-element Vector{Tuple{Int64, Int64}}:
 (1, 0)
 (3, 0)
 (0, 1)
 (2, 1)
 (1, 2)
 (0, 3)
 (0, -3)
 (1, -2)
 (0, -1)
 (2, -1)

julia&gt; JosephsonCircuits.truncfreqs(JosephsonCircuits.calcfreqsrdft((3,3));maxintermodorder=2)
JosephsonCircuits.Frequencies{2}((3, 3), (4, 7), (6, 7), CartesianIndex{2}[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(1, 2), CartesianIndex(2, 2), CartesianIndex(1, 3), CartesianIndex(1, 4), CartesianIndex(1, 5), CartesianIndex(1, 6), CartesianIndex(1, 7), CartesianIndex(2, 7)], [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (0, 2), (0, 3), (0, -3), (0, -2), (0, -1), (1, -1)])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.tryfactorize!-Tuple{JosephsonCircuits.FactorizationCache, JosephsonCircuits.Factorization, AbstractMatrix}"><a class="docstring-binding" href="#JosephsonCircuits.tryfactorize!-Tuple{JosephsonCircuits.FactorizationCache, JosephsonCircuits.Factorization, AbstractMatrix}"><code>JosephsonCircuits.tryfactorize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tryfactorize!(cache::FactorizationCache,
    factorization::Factorization, A::AbstractArray)</code></pre><p>Factorize the matrix <code>A</code> using the factorization from <code>factorization</code> and store the result in <code>cache</code>. Attempt to reuse the symbolic factorization. Redo the symbolic factorization if we get a SingularException.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.trysolve!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.trysolve!-Tuple{Any, Any, Any}"><code>JosephsonCircuits.trysolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trysolve!(x,factorization,b)</code></pre><p>First try to solve a linear system using ldiv! then if it errors, use . The motivation for this function is some factorizations such as <code>qr</code> with sparse matrices don&#39;t support ldiv!. </p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.tuple2edge-Tuple{Vector{NTuple{4, Int64}}}"><a class="docstring-binding" href="#JosephsonCircuits.tuple2edge-Tuple{Vector{NTuple{4, Int64}}}"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuple2edge(tuplevector::Vector{Tuple{Int, Int, Int, Int}})</code></pre><p>Converts a vector of edges specified with tuples of integers to a vector of Graphs edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge([(1,2,3,4),(5,6,7,8)])
2-element Vector{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}}:
 (Edge 1 =&gt; 2, Edge 3 =&gt; 4)
 (Edge 5 =&gt; 6, Edge 7 =&gt; 8)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.tuple2edge-Tuple{Vector{Tuple{Int64, Int64}}}"><a class="docstring-binding" href="#JosephsonCircuits.tuple2edge-Tuple{Vector{Tuple{Int64, Int64}}}"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuple2edge(tuplevector::Vector{Tuple{Int, Int}})</code></pre><p>Converts a vector of edges specified with tuples of integers to a vector of Graphs edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge([(1,2),(3,4)])
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 3 =&gt; 4</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.tuple2edge-Union{Tuple{Dict{NTuple{4, Int64}, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{NTuple{4, Int64}, T}}, Tuple{T}} where T"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuple2edge(tupledict::Dict{Tuple{Int, Int, Int, Int},T})</code></pre><p>Converts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Int}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Int64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Float64}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Float64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1.0
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3.0

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Complex{Float64}}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, ComplexF64} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1.0+0.0im
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3.0+0.0im

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int, Int, Int}, Any}((1, 2, 3, 4) =&gt; 1, (5, 6, 7, 8) =&gt; 3))
Dict{Tuple{Graphs.SimpleGraphs.SimpleEdge{Int64}, Graphs.SimpleGraphs.SimpleEdge{Int64}}, Any} with 2 entries:
  (Edge 1 =&gt; 2, Edge 3 =&gt; 4) =&gt; 1
  (Edge 5 =&gt; 6, Edge 7 =&gt; 8) =&gt; 3</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.tuple2edge-Union{Tuple{Dict{Tuple{Int64, Int64}, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#JosephsonCircuits.tuple2edge-Union{Tuple{Dict{Tuple{Int64, Int64}, T}}, Tuple{T}} where T"><code>JosephsonCircuits.tuple2edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuple2edge(tupledict::Dict{Tuple{Int, Int},T})</code></pre><p>Converts a dictionary whose keys are edges specified by tuples of integers to a dictionary whose keys are Graphs edges. The values associated with each key are preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Int}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Int64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1
  Edge 3 =&gt; 4 =&gt; 3
  Edge 2 =&gt; 3 =&gt; 2

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Float64}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Float64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1.0
  Edge 3 =&gt; 4 =&gt; 3.0
  Edge 2 =&gt; 3 =&gt; 2.0

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Complex{Float64}}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, ComplexF64} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1.0+0.0im
  Edge 3 =&gt; 4 =&gt; 3.0+0.0im
  Edge 2 =&gt; 3 =&gt; 2.0+0.0im

julia&gt; JosephsonCircuits.tuple2edge(Dict{Tuple{Int, Int}, Any}((1, 2) =&gt; 1, (3, 4) =&gt; 3, (2, 3) =&gt; 2))
Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Any} with 3 entries:
  Edge 1 =&gt; 2 =&gt; 1
  Edge 3 =&gt; 4 =&gt; 3
  Edge 2 =&gt; 3 =&gt; 2</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.updateAoLjbm!-Tuple{SparseArrays.SparseMatrixCSC, Any, SparseArrays.SparseVector, Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.updateAoLjbm!-Tuple{SparseArrays.SparseMatrixCSC, Any, SparseArrays.SparseVector, Any, Any, Any}"><code>JosephsonCircuits.updateAoLjbm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">updateAoLjbm!(AoLjbm::SparseMatrixCSC, Am, Ljb::SparseVector, Lmean, Nmodes,
    Nbranches)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;
AoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2);
AoLjbmcopy = copy(AoLjbm);
AoLjbmcopy.nzval .= 0;
JosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,2,2)
all(JosephsonCircuits.Symbolics.simplify.(AoLjbmcopy.nzval .- AoLjbm.nzval) .== 0)

# output
true</code></pre><pre><code class="language-julia hljs">@variables Lj1 Lj2 A11 A12 A21 A22 A31 A32;
AoLjbm = JosephsonCircuits.calcAoLjbm([A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2);
AoLjbmcopy = copy(AoLjbm);
AoLjbmcopy.nzval .= 0;
JosephsonCircuits.updateAoLjbm!(AoLjbmcopy,[A11 A12;A21 A22;A31 A32],JosephsonCircuits.SparseArrays.sparsevec([1,2],[Lj1,Lj2]),1,3,2)
all(JosephsonCircuits.Symbolics.simplify.(AoLjbmcopy.nzval .- AoLjbm.nzval) .== 0)

# output
true</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.updateAoLjbm2!-Tuple{SparseArrays.SparseMatrixCSC, Array, Any, Any, SparseArrays.SparseVector, Any}"><a class="docstring-binding" href="#JosephsonCircuits.updateAoLjbm2!-Tuple{SparseArrays.SparseMatrixCSC, Array, Any, Any, SparseArrays.SparseVector, Any}"><code>JosephsonCircuits.updateAoLjbm2!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">updateAoLjbm2!(AoLjbm::SparseMatrixCSC, Am::Array, AoLjbmindices,
    conjindicessorted, Ljb::SparseVector, Lmean)</code></pre><p>Update the values in the sparse AoLjbm matrix in place.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.valuetonumber-Tuple{Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.valuetonumber-Tuple{Any, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">valuetonumber(value, circuitdefs)</code></pre><p>If the component value <code>value</code> is a number (or a type we haven&#39;t considered, return it as is.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(1.0,Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
1.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.valuetonumber-Tuple{Num, Any}"><a class="docstring-binding" href="#JosephsonCircuits.valuetonumber-Tuple{Num, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbolics.Num,circuitdefs)</code></pre><p>If the component value is Symbolics.Num, then try substituting in the definition from <code>circuitdefs</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=&gt;3.0e-12))
3.0e-12

julia&gt; @variables Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=&gt;3.0e-12,Lj2=&gt;1.0e-12))
4.0e-12</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.valuetonumber-Tuple{String, Any}"><a class="docstring-binding" href="#JosephsonCircuits.valuetonumber-Tuple{String, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">valuetonumber(value::String,circuitdefs)</code></pre><p>If the component value is a string, assume it is a dictionary key.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(&quot;Lj1&quot;,Dict(&quot;Lj1&quot;=&gt;1e-12,&quot;Lj2&quot;=&gt;2e-12))
1.0e-12</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.valuetonumber-Tuple{Symbol, Any}"><a class="docstring-binding" href="#JosephsonCircuits.valuetonumber-Tuple{Symbol, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbol,circuitdefs)</code></pre><p>If the component value is a symbol, assume it is a dictionary key.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; JosephsonCircuits.valuetonumber(:Lj1,Dict(:Lj1=&gt;1e-12,:Lj2=&gt;2e-12))
1.0e-12</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.valuetonumber-Tuple{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}, Any}"><a class="docstring-binding" href="#JosephsonCircuits.valuetonumber-Tuple{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymbolicUtils.SymReal}, Any}"><code>JosephsonCircuits.valuetonumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">valuetonumber(value::Symbolics.SymbolicT, circuitdefs)</code></pre><p>If the component value <code>value</code> has a type Symbolics.SymbolicT, then try substituting in the definition from <code>circuitdefs</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms Lj1;JosephsonCircuits.valuetonumber(Lj1,Dict(Lj1=&gt;3.0e-12))
3.0e-12

julia&gt; @syms Lj1 Lj2;JosephsonCircuits.valuetonumber(Lj1+Lj2,Dict(Lj1=&gt;3.0e-12,Lj2=&gt;1.0e-12))
4.0e-12</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.visualizefreqs-Union{Tuple{N}, Tuple{NTuple{N, Any}, JosephsonCircuits.Frequencies{N}}} where N"><a class="docstring-binding" href="#JosephsonCircuits.visualizefreqs-Union{Tuple{N}, Tuple{NTuple{N, Any}, JosephsonCircuits.Frequencies{N}}} where N"><code>JosephsonCircuits.visualizefreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">visualizefreqs(w::NTuple{N,Any}, freq::Frequencies{N})</code></pre><p>Create a vector or array containing the mixing products for visualization purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@variables wp1
w = (wp1,)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,)),
        dc=true, odd=true, even=true, maxintermodorder=Inf,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4-element Vector{Num}:
    0
  wp1
 2wp1
 3wp1</code></pre><pre><code class="language-julia hljs">@variables wp1,wp2
w = (wp1,wp2)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,3)),
        dc=true, odd=true, even=true, maxintermodorder=3,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4×7 Matrix{Num}:
    0         wp2        2wp2  3wp2  -3wp2       -2wp2        -wp2
  wp1   wp1 + wp2  wp1 + 2wp2     0      0  wp1 - 2wp2   wp1 - wp2
 2wp1  2wp1 + wp2           0     0      0           0  2wp1 - wp2
 3wp1           0           0     0      0           0           0</code></pre><pre><code class="language-julia hljs">w = (1.1,1.2)
freq = JosephsonCircuits.truncfreqs(
    JosephsonCircuits.calcfreqsrdft((3,3)),
        dc=true, odd=true, even=true, maxintermodorder=3,
)
JosephsonCircuits.visualizefreqs(w,freq)

# output
4×7 Matrix{Float64}:
 0.0  1.2  2.4  3.6  -3.6  -2.4  -1.2
 1.1  2.3  3.5  0.0   0.0  -1.3  -0.1
 2.2  3.4  0.0  0.0   0.0   0.0   1.0
 3.3  0.0  0.0  0.0   0.0   0.0   0.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.wrspice_calcS_paramp-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.wrspice_calcS_paramp-Tuple{Any, Any, Any}"><code>JosephsonCircuits.wrspice_calcS_paramp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrspice_calcS_paramp(out, wswrspice, Nnodes, stepsperperiod = 80,
    Is = 1e-13)</code></pre><p>This function assume the first node is the input port and the last node is the output port. Nnodes is the number of nodes including the ground node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Nnodes = 2
ws = 2*pi*5e9
wp = 2*pi*6e9
stepsperperiod = 80
t = LinRange(0,2*pi/wp,stepsperperiod)
Is = 1e-13
Vpump = zeros(1,length(t))
Vsignalsin = zeros(1,length(t))
Vsignalcos = zeros(1,length(t))
Vpump[1,:] .= sin.(2*pi*wp*t)
Vsignalsin[1,:] .= sin.(2*pi*wp*t)+Is/50*sin.(2*pi*ws*t)
Vsignalcos[1,:] .= sin.(2*pi*wp*t)+Is/50*cos.(2*pi*ws*t)

out = [(values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vpump),),
        (values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vsignalsin),),
        (values=Dict(&quot;S&quot;=&gt;t,&quot;V&quot;=&gt;Vsignalcos),),
        ];
out[1].values[&quot;V&quot;];
out[2].values[&quot;V&quot;];
out[3].values[&quot;V&quot;];
JosephsonCircuits.wrspice_calcS_paramp(out, 2*pi, Nnodes;
    stepsperperiod = stepsperperiod, Is = Is)

# output
(S11 = ComplexF64[-0.9999710828404902 + 2.7521387922213123e-5im], S21 = ComplexF64[2.8917159509832197e-5 + 2.7521387922213123e-5im])</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.wrspice_cmd-Tuple{}"><a class="docstring-binding" href="#JosephsonCircuits.wrspice_cmd-Tuple{}"><code>JosephsonCircuits.wrspice_cmd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrspice_cmd()</code></pre><p>This returns the path of the WRSPICE executable.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.wrspice_input_ac-Tuple{String, AbstractVector{Float64}, Any, Any}"><a class="docstring-binding" href="#JosephsonCircuits.wrspice_input_ac-Tuple{String, AbstractVector{Float64}, Any, Any}"><code>JosephsonCircuits.wrspice_input_ac</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrspice_input_ac(netlist,nsteps,fstart,fstop)</code></pre><p>Generate the WRSPICE input file for an AC small signal simulation using circuit parameters from the given netlist, and the specified frequency range. Example usage:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_ac(&quot;* SPICE Simulation&quot;,100,4e9,5e9,[1,2],1e-6))
* SPICE Simulation
* AC current source with magnitude 1 and phase 0
isrc 1 0 ac 1.0e-6 0.0

* Set up the AC small signal simulation
.ac lin 100 4.0g 5.0g

* The control block
.control

* Maximum size of data to export in kilobytes from 1e3 to 2e9 with
* default 2.56e5. This has to come before the run command
set maxdata=2.0e9

* Run the simulation
run

* Binary files are faster to save and load.
set filetype=binary

* Leave filename empty so we can add that as a command line argument.
* Don&#39;t specify any variables so it saves everything.
write

.endc</code></pre><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_ac(&quot;* SPICE Simulation&quot;,(4:0.01:5)*1e9,[1,2],1e-6))
* SPICE Simulation
* AC current source with magnitude 1 and phase 0
isrc 1 0 ac 1.0e-6 0.0

* Set up the AC small signal simulation
.ac lin 99 4.0g 5.0g

* The control block
.control

* Maximum size of data to export in kilobytes from 1e3 to 2e9 with
* default 2.56e5. This has to come before the run command
set maxdata=2.0e9

* Run the simulation
run

* Binary files are faster to save and load.
set filetype=binary

* Leave filename empty so we can add that as a command line argument.
* Don&#39;t specify any variables so it saves everything.
write

.endc</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.wrspice_input_paramp-NTuple{6, Any}"><a class="docstring-binding" href="#JosephsonCircuits.wrspice_input_paramp-NTuple{6, Any}"><code>JosephsonCircuits.wrspice_input_paramp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrspice_input_paramp(netlist, ws, wp, Ip; stepsperperiod = 80, Is = 1e-13,
    tstop = 200e-9, trise = 10e-9)</code></pre><p>Generate the WRSPICE input files for a time domain domain simulation in which the signal angular frequency is swept over <code>ws</code> with pump angular frequency <code>wp</code> and pump current <code>Ip</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using JosephsonCircuits
using Plots
circuit = [
    (&quot;P1&quot;,&quot;1&quot;,&quot;0&quot;,1),
    (&quot;R1&quot;,&quot;1&quot;,&quot;0&quot;,:R),
    (&quot;C1&quot;,&quot;1&quot;,&quot;2&quot;,:Cc),
    (&quot;Lj1&quot;,&quot;2&quot;,&quot;0&quot;,:Lj),
    (&quot;C2&quot;,&quot;2&quot;,&quot;0&quot;,:Cj)]
circuitdefs = Dict(
    :Lj =&gt;1000.0e-12,
    :Cc =&gt; 100.0e-15,
    :Cj =&gt; 1000.0e-15,
    :R =&gt; 50.0)
ws = 2*pi*(4.5:0.001:5.0)*1e9
wp = (2*pi*4.75001*1e9,)
Ip = 0.00565e-6
sources = [(mode=(1,),port=1,current=Ip)]
Npumpharmonics = (16,)
Nmodulationharmonics = (8,)
@time jpa = hbsolve(ws, wp, sources, Nmodulationharmonics,
    Npumpharmonics, circuit, circuitdefs)
wswrspice=2*pi*(4.5:0.01:5.0)*1e9
n = JosephsonCircuits.exportnetlist(circuit,circuitdefs);
input = JosephsonCircuits.wrspice_input_paramp(n.netlist,wswrspice,wp[1],2*Ip);
@time output = JosephsonCircuits.spice_run(input,JosephsonCircuits.wrspice_cmd());
S11,S21=JosephsonCircuits.wrspice_calcS_paramp(output,wswrspice,n.Nnodes);
plot(ws/(2*pi*1e9),
    10*log10.(abs2.(jpa.linearized.S((0,),1,(0,),1,:))),
    label=&quot;JosephsonCircuits.jl&quot;,
    xlabel=&quot;Frequency (GHz)&quot;,
    ylabel=&quot;S11 (dB)&quot;)
plot!(wswrspice/(2*pi*1e9),10*log10.(abs2.(S11)),
    label=&quot;WRSPICE&quot;,
    seriestype=:scatter)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="JosephsonCircuits.wrspice_input_transient-Tuple{String, Vararg{Any, 7}}"><a class="docstring-binding" href="#JosephsonCircuits.wrspice_input_transient-Tuple{String, Vararg{Any, 7}}"><code>JosephsonCircuits.wrspice_input_transient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrspice_input_transient(netlist::String, current, frequency, phase, tstep,
    tstop, trise; maxdata = 2e9, jjaccel = 1, dphimax = 0.01,
    filetype = &quot;binary&quot;)</code></pre><p>Generate the WRSPICE input file for a transient simulation using circuit  parameters from the given netlist, the source current, frequency phase, and nodes for the sources, and the time step and stop time. Leave filename empty so we can add that as a command line argument. Don&#39;t specify any variables so it saves everything.</p><p><strong>Arguments</strong></p><ul><li><code>netlist</code>: String containing the circuit netlist, excluding sources.</li><li><code>current</code>: Vector of current source amplitudes in Ampere.</li><li><code>frequency</code>: Vector of current source frequencies in Hz.</li><li><code>phase</code>: Vector of current source phases in radians.</li><li><code>sourcenodes</code>: Vector of tuples of nodes (src,dst) at which to place the   current source(s).</li><li><code>tstep</code>: Time step in seconds.</li><li><code>tstop</code>: Time for which to run the simulation in seconds.</li><li><code>trise</code>: The simulation ramps up the current source amplitude with a   1-sech(t/trise) envelope which reaches 35 percent of the peak in one   <code>trise</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>maxdata = 2e9</code>: Maximum size of data to export in kilobytes from 1e3 to   2e9 with WRspice default 2.56e5. This has to come before the run command.</li><li><code>jjaccel = 1</code>: Causes a faster convergence testing and iteration control   algorithm to be used, rather than the standard more comprehensive   algorithm suitable for all devices.</li><li><code>dphimax = 0.01</code>: The maximum allowed phase change per time step. Decreasing   dphimax from the default of pi/5 to a smaller value is critical for   matching the accuracy of the harmonic balance method simulations. This   increases simulation time by pi/5/(dphimax).</li><li><code>filetype = &quot;binary&quot; or &quot;ascii&quot;</code>: Binary files are faster to save and load.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(JosephsonCircuits.wrspice_input_transient(&quot;* SPICE Simulation&quot;,[1e-6,1e-3],[5e9,6e9],[3.14,6.28],[(1,0),(1,0)],1e-9,100e-9,10e-9))
* SPICE Simulation
* Current source
* 1-hyperbolic secant rise
isrc1 1 0 1.0u*cos(31.41592653589793g*x+3.14)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))
isrc2 1 0 1000.0u*cos(37.69911184307752g*x+6.28)*(1-2/(exp(x/1.0e-8)+exp(-x/1.0e-8)))
* Set up the transient simulation
* .tran 5p 10n
.tran 1000.0000000000001p 100.0n uic

* The control block
.control
set maxdata=2.0e9
set jjaccel=1
set dphimax=0.01
run
set filetype=binary
write
.endc</code></pre></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« JosephsonCircuits.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 08:36">Tuesday 13 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
